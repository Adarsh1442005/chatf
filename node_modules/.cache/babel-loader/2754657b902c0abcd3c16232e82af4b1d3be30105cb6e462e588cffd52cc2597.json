{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n    var _a;\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.connector = connector;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.transport = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = new Set();\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.channelzTrace = new channelz_1.ChannelzTraceStub();\n      this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n      this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n      this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n    } else {\n      this.channelzTrace = new channelz_1.ChannelzTrace();\n      this.callTracker = new channelz_1.ChannelzCallTracker();\n      this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n      this.streamTracker = new channelz_1.ChannelzCallTracker();\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n    this.secureConnector = credentials._createSecureConnector(channelTarget, options);\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n      options = Object.assign(Object.assign({}, options), {\n        'grpc.keepalive_time_ms': adjustedKeepaliveTime\n      });\n    }\n    this.connector.connect(this.subchannelAddress, this.secureConnector, options).then(transport => {\n      if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n        this.transport = transport;\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(transport.getChannelzRef());\n        }\n        transport.addDisconnectListener(tooManyPings => {\n          this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n          if (tooManyPings && this.keepaliveTime > 0) {\n            this.keepaliveTime *= 2;\n            logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n          }\n        });\n      } else {\n        /* If we can't transition from CONNECTING to READY here, we will\n         * not be using this transport, so release its resources. */\n        transport.shutdown();\n      }\n    }, error => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState, errorMessage) {\n    var _a, _b;\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    if (errorMessage) {\n      this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState] + ' with error \"' + errorMessage + '\"');\n    } else {\n      this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    for (const listener of this.stateListeners) {\n      listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n    }\n    return true;\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      this.secureConnector.destroy();\n      process.nextTick(() => {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      });\n    }\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  createCall(metadata, host, method, listener) {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        }\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(metadata, host, method, listener, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    process.nextTick(() => {\n      /* First, try to transition from IDLE to connecting. If that doesn't happen\n       * because the state is not currently IDLE, check if it is\n       * TRANSIENT_FAILURE, and if so indicate that it should go back to\n       * connecting after the backoff timer ends. Otherwise do nothing */\n      if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n          this.continueConnecting = true;\n        }\n      }\n    });\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.add(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    this.stateListeners.delete(listener);\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    process.nextTick(() => {\n      this.backoffTimeout.reset();\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    });\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  isHealthy() {\n    return true;\n  }\n  addHealthStateWatcher(listener) {\n    // Do nothing with the listener\n  }\n  removeHealthStateWatcher(listener) {\n    // Do nothing with the listener\n  }\n  getRealSubchannel() {\n    return this;\n  }\n  realSubchannelEquals(other) {\n    return other.getRealSubchannel() === this;\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n  getCallCredentials() {\n    return this.secureConnector.getCallCredentials();\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"names":["connectivity_state_1","require","backoff_timeout_1","logging","constants_1","uri_parser_1","subchannel_address_1","channelz_1","TRACER_NAME","KEEPALIVE_MAX_TIME_MS","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connector","connectivityState","ConnectivityState","IDLE","transport","continueConnecting","stateListeners","Set","refcount","channelzEnabled","backoffOptions","initialDelay","maxDelay","backoffTimeout","BackoffTimeout","handleBackoffTimer","unref","subchannelAddressString","subchannelAddressToString","keepaliveTime","_a","channelzTrace","ChannelzTraceStub","callTracker","ChannelzCallTrackerStub","childrenTracker","ChannelzChildrenTrackerStub","streamTracker","ChannelzTrace","ChannelzCallTracker","ChannelzChildrenTracker","channelzRef","registerChannelzSubchannel","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","secureConnector","_createSecureConnector","state","children","getChildLists","target","text","LogVerbosity","DEBUG","id","refTrace","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","startConnectingInternal","adjustedKeepaliveTime","Math","min","Object","assign","connect","then","READY","refChild","getChannelzRef","addDisconnectListener","tooManyPings","log","ERROR","uriToString","shutdown","error","oldStates","newState","errorMessage","indexOf","previousState","unrefChild","isRunning","process","nextTick","_b","Error","listener","ref","unregisterChannelzRef","destroy","unrefIfOneRef","createCall","metadata","host","method","statsTracker","addCallStarted","onCallEnd","status","code","Status","OK","addCallSucceeded","addCallFailed","startConnecting","getConnectivityState","addConnectivityStateListener","add","removeConnectivityStateListener","delete","resetBackoff","getAddress","isHealthy","addHealthStateWatcher","removeHealthStateWatcher","getRealSubchannel","realSubchannelEquals","other","throttleKeepalive","newKeepaliveTime","getCallCredentials","exports"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials, SecureConnector } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport {\n  SubchannelRef,\n  ChannelzTrace,\n  ChannelzChildrenTracker,\n  ChannelzChildrenTrackerStub,\n  SubchannelInfo,\n  registerChannelzSubchannel,\n  ChannelzCallTracker,\n  ChannelzCallTrackerStub,\n  unregisterChannelzRef,\n  ChannelzTraceStub,\n} from './channelz';\nimport {\n  ConnectivityStateListener,\n  SubchannelInterface,\n} from './subchannel-interface';\nimport { SubchannelCallInterceptingListener } from './subchannel-call';\nimport { SubchannelCall } from './subchannel-call';\nimport { CallEventTracker, SubchannelConnector, Transport } from './transport';\nimport { CallCredentials } from './call-credentials';\n\nconst TRACER_NAME = 'subchannel';\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\n\nexport class Subchannel implements SubchannelInterface {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private transport: Transport | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: Set<ConnectivityStateListener> = new Set();\n\n  private backoffTimeout: BackoffTimeout;\n\n  private keepaliveTime: number;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n\n  private channelzTrace: ChannelzTrace | ChannelzTraceStub;\n  private callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  private childrenTracker:\n    | ChannelzChildrenTracker\n    | ChannelzChildrenTrackerStub;\n\n  // Channelz socket info\n  private streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n\n  private secureConnector: SecureConnector;\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    credentials: ChannelCredentials,\n    private connector: SubchannelConnector\n  ) {\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.channelzTrace = new ChannelzTraceStub();\n      this.callTracker = new ChannelzCallTrackerStub();\n      this.childrenTracker = new ChannelzChildrenTrackerStub();\n      this.streamTracker = new ChannelzCallTrackerStub();\n    } else {\n      this.channelzTrace = new ChannelzTrace();\n      this.callTracker = new ChannelzCallTracker();\n      this.childrenTracker = new ChannelzChildrenTracker();\n      this.streamTracker = new ChannelzCallTracker();\n    }\n\n    this.channelzRef = registerChannelzSubchannel(\n      this.subchannelAddressString,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n\n    this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    this.trace(\n      'Subchannel constructed with options ' +\n        JSON.stringify(options, undefined, 2)\n    );\n    this.secureConnector = credentials._createSecureConnector(channelTarget, options);\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString,\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'subchannel_refcount',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(\n        this.keepaliveTime,\n        KEEPALIVE_MAX_TIME_MS\n      );\n      options = { ...options, 'grpc.keepalive_time_ms': adjustedKeepaliveTime };\n    }\n    this.connector\n      .connect(this.subchannelAddress, this.secureConnector, options)\n      .then(\n        transport => {\n          if (\n            this.transitionToState(\n              [ConnectivityState.CONNECTING],\n              ConnectivityState.READY\n            )\n          ) {\n            this.transport = transport;\n            if (this.channelzEnabled) {\n              this.childrenTracker.refChild(transport.getChannelzRef());\n            }\n            transport.addDisconnectListener(tooManyPings => {\n              this.transitionToState(\n                [ConnectivityState.READY],\n                ConnectivityState.IDLE\n              );\n              if (tooManyPings && this.keepaliveTime > 0) {\n                this.keepaliveTime *= 2;\n                logging.log(\n                  LogVerbosity.ERROR,\n                  `Connection to ${uriToString(this.channelTarget)} at ${\n                    this.subchannelAddressString\n                  } rejected by server because of excess pings. Increasing ping interval to ${\n                    this.keepaliveTime\n                  } ms`\n                );\n              }\n            });\n          } else {\n            /* If we can't transition from CONNECTING to READY here, we will\n             * not be using this transport, so release its resources. */\n            transport.shutdown();\n          }\n        },\n        error => {\n          this.transitionToState(\n            [ConnectivityState.CONNECTING],\n            ConnectivityState.TRANSIENT_FAILURE,\n            `${error}`\n          );\n        }\n      );\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState,\n    errorMessage?: string\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    if (errorMessage) {\n      this.trace(\n        ConnectivityState[this.connectivityState] +\n          ' -> ' +\n          ConnectivityState[newState] +\n          ' with error \"' + errorMessage + '\"'\n      );\n\n    } else {\n      this.trace(\n        ConnectivityState[this.connectivityState] +\n          ' -> ' +\n          ConnectivityState[newState]\n      );\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace(\n        'CT_INFO',\n        'Connectivity state change to ' + ConnectivityState[newState]\n      );\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    for (const listener of this.stateListeners) {\n      listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n    }\n    return true;\n  }\n\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      unregisterChannelzRef(this.channelzRef);\n      this.secureConnector.destroy();\n      process.nextTick(() => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING, ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      });\n    }\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener\n  ): SubchannelCall {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker: Partial<CallEventTracker>;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        },\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(\n      metadata,\n      host,\n      method,\n      listener,\n      statsTracker\n    );\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    process.nextTick(() => {\n      /* First, try to transition from IDLE to connecting. If that doesn't happen\n       * because the state is not currently IDLE, check if it is\n       * TRANSIENT_FAILURE, and if so indicate that it should go back to\n       * connecting after the backoff timer ends. Otherwise do nothing */\n      if (\n        !this.transitionToState(\n          [ConnectivityState.IDLE],\n          ConnectivityState.CONNECTING\n        )\n      ) {\n        if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n          this.continueConnecting = true;\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.add(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.delete(listener);\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    process.nextTick(() => {\n      this.backoffTimeout.reset();\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    });\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  isHealthy(): boolean {\n    return true;\n  }\n\n  addHealthStateWatcher(listener: (healthy: boolean) => void): void {\n    // Do nothing with the listener\n  }\n\n  removeHealthStateWatcher(listener: (healthy: boolean) => void): void {\n    // Do nothing with the listener\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n\n  realSubchannelEquals(other: SubchannelInterface): boolean {\n    return other.getRealSubchannel() === this;\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n  getCallCredentials(): CallCredentials {\n    return this.secureConnector.getCallCredentials();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}