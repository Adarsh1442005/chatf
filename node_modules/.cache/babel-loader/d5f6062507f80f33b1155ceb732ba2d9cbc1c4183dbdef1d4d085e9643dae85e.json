{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelCredentials = void 0;\nexports.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;\nconst tls_1 = require(\"tls\");\nconst call_credentials_1 = require(\"./call-credentials\");\nconst tls_helpers_1 = require(\"./tls-helpers\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nclass ChannelCredentials {\n  /**\n   * Returns a copy of this object with the included set of per-call credentials\n   * expanded to include callCredentials.\n   * @param callCredentials A CallCredentials object to associate with this\n   * instance.\n   */\n  compose(callCredentials) {\n    return new ComposedChannelCredentialsImpl(this, callCredentials);\n  }\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n    var _a;\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error('Private key must be given with accompanying certificate chain');\n    }\n    if (!privateKey && certChain) {\n      throw new Error('Certificate chain must be given with accompanying private key');\n    }\n    const secureContext = (0, tls_1.createSecureContext)({\n      ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n      key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n      cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n      ciphers: tls_helpers_1.CIPHER_SUITES\n    });\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(secureContext, verifyOptions) {\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure() {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor() {\n    super();\n  }\n  compose(callCredentials) {\n    throw new Error('Cannot compose insecure credentials');\n  }\n  _isSecure() {\n    return false;\n  }\n  _equals(other) {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n  _createSecureConnector(channelTarget, options, callCredentials) {\n    return {\n      connect(socket) {\n        return Promise.resolve({\n          socket,\n          secure: false\n        });\n      },\n      waitForReady: () => {\n        return Promise.resolve();\n      },\n      getCallCredentials: () => {\n        return callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty();\n      },\n      destroy() {}\n    };\n  }\n}\nfunction getConnectionOptions(secureContext, verifyOptions, channelTarget, options) {\n  var _a, _b, _c, _d;\n  const connectionOptions = {\n    secureContext: secureContext\n  };\n  if (verifyOptions.checkServerIdentity) {\n    connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n  }\n  if (verifyOptions.rejectUnauthorized !== undefined) {\n    connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;\n  }\n  connectionOptions.ALPNProtocols = ['h2'];\n  if (options['grpc.ssl_target_name_override']) {\n    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n    const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== void 0 ? _a : tls_1.checkServerIdentity;\n    connectionOptions.checkServerIdentity = (host, cert) => {\n      return originalCheckServerIdentity(sslTargetNameOverride, cert);\n    };\n    connectionOptions.servername = sslTargetNameOverride;\n  } else {\n    if ('grpc.http_connect_target' in options) {\n      /* This is more or less how servername will be set in createSession\n       * if a connection is successfully established through the proxy.\n       * If the proxy is not used, these connectionOptions are discarded\n       * anyway */\n      const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _b !== void 0 ? _b : {\n        path: 'localhost'\n      });\n      const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n      connectionOptions.servername = (_c = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c !== void 0 ? _c : targetPath;\n    }\n  }\n  if (options['grpc-node.tls_enable_trace']) {\n    connectionOptions.enableTrace = true;\n  }\n  let realTarget = channelTarget;\n  if ('grpc.http_connect_target' in options) {\n    const parsedTarget = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target']);\n    if (parsedTarget) {\n      realTarget = parsedTarget;\n    }\n  }\n  const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\n  const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n  const remoteHost = (_d = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _d !== void 0 ? _d : targetPath;\n  connectionOptions.host = remoteHost;\n  connectionOptions.servername = remoteHost;\n  return connectionOptions;\n}\nclass SecureConnectorImpl {\n  constructor(connectionOptions, callCredentials) {\n    this.connectionOptions = connectionOptions;\n    this.callCredentials = callCredentials;\n  }\n  connect(socket) {\n    const tlsConnectOptions = Object.assign({\n      socket: socket\n    }, this.connectionOptions);\n    return new Promise((resolve, reject) => {\n      const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {\n        if (!tlsSocket.authorized) {\n          reject(tlsSocket.authorizationError);\n          return;\n        }\n        resolve({\n          socket: tlsSocket,\n          secure: true\n        });\n      });\n      tlsSocket.on('error', error => {\n        reject(error);\n      });\n    });\n  }\n  waitForReady() {\n    return Promise.resolve();\n  }\n  getCallCredentials() {\n    return this.callCredentials;\n  }\n  destroy() {}\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(secureContext, verifyOptions) {\n    super();\n    this.secureContext = secureContext;\n    this.verifyOptions = verifyOptions;\n  }\n  _isSecure() {\n    return true;\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n    } else {\n      return false;\n    }\n  }\n  _createSecureConnector(channelTarget, options, callCredentials) {\n    const connectionOptions = getConnectionOptions(this.secureContext, this.verifyOptions, channelTarget, options);\n    return new SecureConnectorImpl(connectionOptions, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n  }\n}\nclass CertificateProviderChannelCredentialsImpl extends ChannelCredentials {\n  constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {\n    super();\n    this.caCertificateProvider = caCertificateProvider;\n    this.identityCertificateProvider = identityCertificateProvider;\n    this.verifyOptions = verifyOptions;\n    this.refcount = 0;\n    /**\n     * `undefined` means that the certificates have not yet been loaded. `null`\n     * means that an attempt to load them has completed, and has failed.\n     */\n    this.latestCaUpdate = undefined;\n    /**\n     * `undefined` means that the certificates have not yet been loaded. `null`\n     * means that an attempt to load them has completed, and has failed.\n     */\n    this.latestIdentityUpdate = undefined;\n    this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\n    this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\n    this.secureContextWatchers = [];\n  }\n  _isSecure() {\n    return true;\n  }\n  _equals(other) {\n    var _a, _b;\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof CertificateProviderChannelCredentialsImpl) {\n      return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && ((_a = this.verifyOptions) === null || _a === void 0 ? void 0 : _a.checkServerIdentity) === ((_b = other.verifyOptions) === null || _b === void 0 ? void 0 : _b.checkServerIdentity);\n    } else {\n      return false;\n    }\n  }\n  ref() {\n    var _a;\n    if (this.refcount === 0) {\n      this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);\n      (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.addIdentityCertificateListener(this.identityCertificateUpdateListener);\n    }\n    this.refcount += 1;\n  }\n  unref() {\n    var _a;\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);\n      (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\n    }\n  }\n  _createSecureConnector(channelTarget, options, callCredentials) {\n    this.ref();\n    return new CertificateProviderChannelCredentialsImpl.SecureConnectorImpl(this, channelTarget, options, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n  }\n  maybeUpdateWatchers() {\n    if (this.hasReceivedUpdates()) {\n      for (const watcher of this.secureContextWatchers) {\n        watcher(this.getLatestSecureContext());\n      }\n      this.secureContextWatchers = [];\n    }\n  }\n  handleCaCertificateUpdate(update) {\n    this.latestCaUpdate = update;\n    this.maybeUpdateWatchers();\n  }\n  handleIdentityCertitificateUpdate(update) {\n    this.latestIdentityUpdate = update;\n    this.maybeUpdateWatchers();\n  }\n  hasReceivedUpdates() {\n    if (this.latestCaUpdate === undefined) {\n      return false;\n    }\n    if (this.identityCertificateProvider && this.latestIdentityUpdate === undefined) {\n      return false;\n    }\n    return true;\n  }\n  getSecureContext() {\n    if (this.hasReceivedUpdates()) {\n      return Promise.resolve(this.getLatestSecureContext());\n    } else {\n      return new Promise(resolve => {\n        this.secureContextWatchers.push(resolve);\n      });\n    }\n  }\n  getLatestSecureContext() {\n    var _a, _b;\n    if (!this.latestCaUpdate) {\n      return null;\n    }\n    if (this.identityCertificateProvider !== null && !this.latestIdentityUpdate) {\n      return null;\n    }\n    try {\n      return (0, tls_1.createSecureContext)({\n        ca: this.latestCaUpdate.caCertificate,\n        key: (_a = this.latestIdentityUpdate) === null || _a === void 0 ? void 0 : _a.privateKey,\n        cert: (_b = this.latestIdentityUpdate) === null || _b === void 0 ? void 0 : _b.certificate,\n        ciphers: tls_helpers_1.CIPHER_SUITES\n      });\n    } catch (e) {\n      (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to createSecureContext with error ' + e.message);\n      return null;\n    }\n  }\n}\nCertificateProviderChannelCredentialsImpl.SecureConnectorImpl = class {\n  constructor(parent, channelTarget, options, callCredentials) {\n    this.parent = parent;\n    this.channelTarget = channelTarget;\n    this.options = options;\n    this.callCredentials = callCredentials;\n  }\n  connect(socket) {\n    return new Promise((resolve, reject) => {\n      const secureContext = this.parent.getLatestSecureContext();\n      if (!secureContext) {\n        reject(new Error('Failed to load credentials'));\n        return;\n      }\n      if (socket.closed) {\n        reject(new Error('Socket closed while loading credentials'));\n      }\n      const connnectionOptions = getConnectionOptions(secureContext, this.parent.verifyOptions, this.channelTarget, this.options);\n      const tlsConnectOptions = Object.assign({\n        socket: socket\n      }, connnectionOptions);\n      const closeCallback = () => {\n        reject(new Error('Socket closed'));\n      };\n      const errorCallback = error => {\n        reject(error);\n      };\n      const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {\n        tlsSocket.removeListener('close', closeCallback);\n        tlsSocket.removeListener('error', errorCallback);\n        if (!tlsSocket.authorized) {\n          reject(tlsSocket.authorizationError);\n          return;\n        }\n        resolve({\n          socket: tlsSocket,\n          secure: true\n        });\n      });\n      tlsSocket.once('close', closeCallback);\n      tlsSocket.once('error', errorCallback);\n    });\n  }\n  async waitForReady() {\n    await this.parent.getSecureContext();\n  }\n  getCallCredentials() {\n    return this.callCredentials;\n  }\n  destroy() {\n    this.parent.unref();\n  }\n};\nfunction createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {\n  return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(channelCredentials, callCredentials) {\n    super();\n    this.channelCredentials = channelCredentials;\n    this.callCredentials = callCredentials;\n    if (!channelCredentials._isSecure()) {\n      throw new Error('Cannot compose insecure credentials');\n    }\n  }\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n  }\n  _isSecure() {\n    return true;\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n    } else {\n      return false;\n    }\n  }\n  _createSecureConnector(channelTarget, options, callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\n    return this.channelCredentials._createSecureConnector(channelTarget, options, combinedCallCredentials);\n  }\n}","map":{"version":3,"names":["exports","createCertificateProviderChannelCredentials","tls_1","require","call_credentials_1","tls_helpers_1","uri_parser_1","resolver_1","logging_1","constants_1","verifyIsBufferOrNull","obj","friendlyName","Buffer","TypeError","ChannelCredentials","compose","callCredentials","ComposedChannelCredentialsImpl","createSsl","rootCerts","privateKey","certChain","verifyOptions","Error","secureContext","createSecureContext","ca","_a","getDefaultRootsData","undefined","key","cert","ciphers","CIPHER_SUITES","SecureChannelCredentialsImpl","createFromSecureContext","createInsecure","InsecureChannelCredentialsImpl","constructor","_isSecure","_equals","other","_createSecureConnector","channelTarget","options","connect","socket","Promise","resolve","secure","waitForReady","getCallCredentials","CallCredentials","createEmpty","destroy","getConnectionOptions","connectionOptions","checkServerIdentity","rejectUnauthorized","ALPNProtocols","sslTargetNameOverride","originalCheckServerIdentity","host","servername","targetPath","getDefaultAuthority","_b","parseUri","path","hostPort","splitHostPort","_c","enableTrace","realTarget","parsedTarget","remoteHost","_d","SecureConnectorImpl","tlsConnectOptions","Object","assign","reject","tlsSocket","authorized","authorizationError","on","error","CertificateProviderChannelCredentialsImpl","caCertificateProvider","identityCertificateProvider","refcount","latestCaUpdate","latestIdentityUpdate","caCertificateUpdateListener","handleCaCertificateUpdate","bind","identityCertificateUpdateListener","handleIdentityCertitificateUpdate","secureContextWatchers","ref","addCaCertificateListener","addIdentityCertificateListener","unref","removeCaCertificateListener","removeIdentityCertificateListener","maybeUpdateWatchers","hasReceivedUpdates","watcher","getLatestSecureContext","update","getSecureContext","push","caCertificate","certificate","e","log","LogVerbosity","ERROR","message","parent","closed","connnectionOptions","closeCallback","errorCallback","removeListener","once","channelCredentials","combinedCallCredentials"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\channel-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ConnectionOptions,\n  createSecureContext,\n  PeerCertificate,\n  SecureContext,\n  checkServerIdentity,\n  connect as tlsConnect\n} from 'tls';\n\nimport { CallCredentials } from './call-credentials';\nimport { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';\nimport { CaCertificateUpdate, CaCertificateUpdateListener, CertificateProvider, IdentityCertificateUpdate, IdentityCertificateUpdateListener } from './certificate-provider';\nimport { Socket } from 'net';\nimport { ChannelOptions } from './channel-options';\nimport { GrpcUri, parseUri, splitHostPort } from './uri-parser';\nimport { getDefaultAuthority } from './resolver';\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj: any, friendlyName: string): void {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\n/**\n * A callback that will receive the expected hostname and presented peer\n * certificate as parameters. The callback should return an error to\n * indicate that the presented certificate is considered invalid and\n * otherwise returned undefined.\n */\nexport type CheckServerIdentityCallback = (\n  hostname: string,\n  cert: PeerCertificate\n) => Error | undefined;\n\n/**\n * Additional peer verification options that can be set when creating\n * SSL credentials.\n */\nexport interface VerifyOptions {\n  /**\n   * If set, this callback will be invoked after the usual hostname verification\n   * has been performed on the peer certificate.\n   */\n  checkServerIdentity?: CheckServerIdentityCallback;\n  rejectUnauthorized?: boolean;\n}\n\nexport interface SecureConnectResult {\n  socket: Socket;\n  secure: boolean;\n}\n\nexport interface SecureConnector {\n  connect(socket: Socket): Promise<SecureConnectResult>;\n  waitForReady(): Promise<void>;\n  getCallCredentials(): CallCredentials;\n  destroy(): void;\n}\n\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nexport abstract class ChannelCredentials {\n  /**\n   * Returns a copy of this object with the included set of per-call credentials\n   * expanded to include callCredentials.\n   * @param callCredentials A CallCredentials object to associate with this\n   * instance.\n   */\n  compose(callCredentials: CallCredentials): ChannelCredentials {\n    return new ComposedChannelCredentialsImpl(this, callCredentials);\n  }\n\n  /**\n   * Indicates whether this credentials object creates a secure channel.\n   */\n  abstract _isSecure(): boolean;\n\n  /**\n   * Check whether two channel credentials objects are equal. Two secure\n   * credentials are equal if they were constructed with the same parameters.\n   * @param other The other ChannelCredentials Object\n   */\n  abstract _equals(other: ChannelCredentials): boolean;\n\n  abstract _createSecureConnector(channelTarget: GrpcUri, options: ChannelOptions, callCredentials?: CallCredentials): SecureConnector;\n\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(\n    rootCerts?: Buffer | null,\n    privateKey?: Buffer | null,\n    certChain?: Buffer | null,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error(\n        'Private key must be given with accompanying certificate chain'\n      );\n    }\n    if (!privateKey && certChain) {\n      throw new Error(\n        'Certificate chain must be given with accompanying private key'\n      );\n    }\n    const secureContext = createSecureContext({\n      ca: rootCerts ?? getDefaultRootsData() ?? undefined,\n      key: privateKey ?? undefined,\n      cert: certChain ?? undefined,\n      ciphers: CIPHER_SUITES,\n    });\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(\n    secureContext: SecureContext,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure(): ChannelCredentials {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor() {\n    super();\n  }\n\n  override compose(callCredentials: CallCredentials): never {\n    throw new Error('Cannot compose insecure credentials');\n  }\n  _isSecure(): boolean {\n    return false;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n  _createSecureConnector(channelTarget: GrpcUri, options: ChannelOptions, callCredentials?: CallCredentials): SecureConnector {\n    return {\n      connect(socket) {\n        return Promise.resolve({\n          socket,\n          secure: false\n        });\n      },\n      waitForReady: () => {\n        return Promise.resolve();\n      },\n      getCallCredentials: () => {\n        return callCredentials ?? CallCredentials.createEmpty();\n      },\n      destroy() {}\n    }\n  }\n}\n\nfunction getConnectionOptions(secureContext: SecureContext, verifyOptions: VerifyOptions, channelTarget: GrpcUri, options: ChannelOptions): ConnectionOptions {\n  const connectionOptions: ConnectionOptions = {\n    secureContext: secureContext\n  };\n  if (verifyOptions.checkServerIdentity) {\n    connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n  }\n  if (verifyOptions.rejectUnauthorized !== undefined) {\n    connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;\n  }\n  connectionOptions.ALPNProtocols = ['h2'];\n  if (options['grpc.ssl_target_name_override']) {\n    const sslTargetNameOverride = options['grpc.ssl_target_name_override']!;\n    const originalCheckServerIdentity =\n      connectionOptions.checkServerIdentity ?? checkServerIdentity;\n    connectionOptions.checkServerIdentity = (\n      host: string,\n      cert: PeerCertificate\n    ): Error | undefined => {\n      return originalCheckServerIdentity(sslTargetNameOverride, cert);\n    };\n    connectionOptions.servername = sslTargetNameOverride;\n  } else {\n    if ('grpc.http_connect_target' in options) {\n      /* This is more or less how servername will be set in createSession\n       * if a connection is successfully established through the proxy.\n       * If the proxy is not used, these connectionOptions are discarded\n       * anyway */\n      const targetPath = getDefaultAuthority(\n        parseUri(options['grpc.http_connect_target'] as string) ?? {\n          path: 'localhost',\n        }\n      );\n      const hostPort = splitHostPort(targetPath);\n      connectionOptions.servername = hostPort?.host ?? targetPath;\n    }\n  }\n  if (options['grpc-node.tls_enable_trace']) {\n    connectionOptions.enableTrace = true;\n  }\n\n  let realTarget: GrpcUri = channelTarget;\n  if ('grpc.http_connect_target' in options) {\n    const parsedTarget = parseUri(options['grpc.http_connect_target']!);\n    if (parsedTarget) {\n      realTarget = parsedTarget;\n    }\n  }\n  const targetPath = getDefaultAuthority(realTarget);\n  const hostPort = splitHostPort(targetPath);\n  const remoteHost = hostPort?.host ?? targetPath;\n  connectionOptions.host = remoteHost;\n  connectionOptions.servername = remoteHost;\n  return connectionOptions;\n}\n\nclass SecureConnectorImpl implements SecureConnector {\n  constructor(private connectionOptions: ConnectionOptions, private callCredentials: CallCredentials) {\n  }\n  connect(socket: Socket): Promise<SecureConnectResult> {\n    const tlsConnectOptions: ConnectionOptions = {\n      socket: socket,\n      ...this.connectionOptions\n    };\n    return new Promise<SecureConnectResult>((resolve, reject) => {\n      const tlsSocket = tlsConnect(tlsConnectOptions, () => {\n        if (!tlsSocket.authorized) {\n          reject(tlsSocket.authorizationError);\n          return;\n        }\n        resolve({\n          socket: tlsSocket,\n          secure: true\n        })\n      });\n      tlsSocket.on('error', (error: Error) => {\n        reject(error);\n      });\n    });\n  }\n  waitForReady(): Promise<void> {\n    return Promise.resolve();\n  }\n  getCallCredentials(): CallCredentials {\n    return this.callCredentials;\n  }\n  destroy() {}\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(\n    private secureContext: SecureContext,\n    private verifyOptions: VerifyOptions\n  ) {\n    super();\n  }\n\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return (\n        this.secureContext === other.secureContext &&\n        this.verifyOptions.checkServerIdentity ===\n          other.verifyOptions.checkServerIdentity\n      );\n    } else {\n      return false;\n    }\n  }\n  _createSecureConnector(channelTarget: GrpcUri, options: ChannelOptions, callCredentials?: CallCredentials): SecureConnector {\n    const connectionOptions = getConnectionOptions(this.secureContext, this.verifyOptions, channelTarget, options);\n    return new SecureConnectorImpl(connectionOptions, callCredentials ?? CallCredentials.createEmpty());\n  }\n}\n\nclass CertificateProviderChannelCredentialsImpl extends ChannelCredentials {\n  private refcount: number = 0;\n  /**\n   * `undefined` means that the certificates have not yet been loaded. `null`\n   * means that an attempt to load them has completed, and has failed.\n   */\n  private latestCaUpdate: CaCertificateUpdate | null | undefined = undefined;\n  /**\n   * `undefined` means that the certificates have not yet been loaded. `null`\n   * means that an attempt to load them has completed, and has failed.\n   */\n  private latestIdentityUpdate: IdentityCertificateUpdate | null | undefined = undefined;\n  private caCertificateUpdateListener: CaCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\n  private identityCertificateUpdateListener: IdentityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\n  private secureContextWatchers: ((context: SecureContext | null) => void)[] = [];\n  private static SecureConnectorImpl = class implements SecureConnector {\n    constructor(private parent: CertificateProviderChannelCredentialsImpl, private channelTarget: GrpcUri, private options: ChannelOptions, private callCredentials: CallCredentials) {}\n\n    connect(socket: Socket): Promise<SecureConnectResult> {\n      return new Promise((resolve, reject) => {\n        const secureContext = this.parent.getLatestSecureContext();\n        if (!secureContext) {\n          reject(new Error('Failed to load credentials'));\n          return;\n        }\n        if (socket.closed) {\n          reject(new Error('Socket closed while loading credentials'));\n        }\n        const connnectionOptions = getConnectionOptions(secureContext, this.parent.verifyOptions, this.channelTarget, this.options);\n        const tlsConnectOptions: ConnectionOptions = {\n          socket: socket,\n          ...connnectionOptions\n        }\n        const closeCallback = () => {\n          reject(new Error('Socket closed'));\n        };\n        const errorCallback = (error: Error) => {\n          reject(error);\n        }\n        const tlsSocket = tlsConnect(tlsConnectOptions, () => {\n          tlsSocket.removeListener('close', closeCallback);\n          tlsSocket.removeListener('error', errorCallback);\n          if (!tlsSocket.authorized) {\n            reject(tlsSocket.authorizationError);\n            return;\n          }\n          resolve({\n            socket: tlsSocket,\n            secure: true\n          });\n        });\n        tlsSocket.once('close', closeCallback);\n        tlsSocket.once('error', errorCallback);\n      });\n    }\n\n    async waitForReady(): Promise<void> {\n      await this.parent.getSecureContext();\n    }\n\n    getCallCredentials(): CallCredentials {\n      return this.callCredentials;\n    }\n\n    destroy() {\n      this.parent.unref();\n    }\n  }\n  constructor(\n    private caCertificateProvider: CertificateProvider,\n    private identityCertificateProvider: CertificateProvider | null,\n    private verifyOptions: VerifyOptions\n  ) {\n    super();\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof CertificateProviderChannelCredentialsImpl) {\n      return this.caCertificateProvider === other.caCertificateProvider &&\n        this.identityCertificateProvider === other.identityCertificateProvider &&\n        this.verifyOptions?.checkServerIdentity === other.verifyOptions?.checkServerIdentity;\n    } else {\n      return false;\n    }\n  }\n  private ref(): void {\n    if (this.refcount === 0) {\n      this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);\n      this.identityCertificateProvider?.addIdentityCertificateListener(this.identityCertificateUpdateListener);\n    }\n    this.refcount += 1;\n  }\n  private unref(): void {\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);\n      this.identityCertificateProvider?.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\n    }\n  }\n  _createSecureConnector(channelTarget: GrpcUri, options: ChannelOptions, callCredentials?: CallCredentials): SecureConnector {\n    this.ref();\n    return new CertificateProviderChannelCredentialsImpl.SecureConnectorImpl(this, channelTarget, options, callCredentials ?? CallCredentials.createEmpty());\n  }\n\n  private maybeUpdateWatchers() {\n    if (this.hasReceivedUpdates()) {\n      for (const watcher of this.secureContextWatchers) {\n        watcher(this.getLatestSecureContext());\n      }\n      this.secureContextWatchers = [];\n    }\n  }\n\n  private handleCaCertificateUpdate(update: CaCertificateUpdate | null) {\n    this.latestCaUpdate = update;\n    this.maybeUpdateWatchers();\n  }\n\n  private handleIdentityCertitificateUpdate(update: IdentityCertificateUpdate | null) {\n    this.latestIdentityUpdate = update;\n    this.maybeUpdateWatchers();\n  }\n\n  private hasReceivedUpdates(): boolean {\n    if (this.latestCaUpdate === undefined) {\n      return false;\n    }\n    if (this.identityCertificateProvider && this.latestIdentityUpdate === undefined) {\n      return false;\n    }\n    return true;\n  }\n\n  private getSecureContext(): Promise<SecureContext | null> {\n    if (this.hasReceivedUpdates()) {\n      return Promise.resolve(this.getLatestSecureContext());\n    } else {\n      return new Promise(resolve => {\n        this.secureContextWatchers.push(resolve);\n      });\n    }\n  }\n\n  private getLatestSecureContext(): SecureContext | null {\n    if (!this.latestCaUpdate) {\n      return null;\n    }\n    if (this.identityCertificateProvider !== null && !this.latestIdentityUpdate) {\n      return null;\n    }\n    try {\n      return createSecureContext({\n        ca: this.latestCaUpdate.caCertificate,\n        key: this.latestIdentityUpdate?.privateKey,\n        cert: this.latestIdentityUpdate?.certificate,\n        ciphers: CIPHER_SUITES\n      });\n    } catch (e) {\n      log(LogVerbosity.ERROR, 'Failed to createSecureContext with error ' + (e as Error).message);\n      return null;\n    }\n  }\n}\n\nexport function createCertificateProviderChannelCredentials(caCertificateProvider: CertificateProvider, identityCertificateProvider: CertificateProvider | null, verifyOptions?: VerifyOptions) {\n  return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions ?? {});\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(\n    private channelCredentials: ChannelCredentials,\n    private callCredentials: CallCredentials\n  ) {\n    super();\n    if (!channelCredentials._isSecure()) {\n      throw new Error('Cannot compose insecure credentials');\n    }\n  }\n  compose(callCredentials: CallCredentials) {\n    const combinedCallCredentials =\n      this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(\n      this.channelCredentials,\n      combinedCallCredentials\n    );\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return (\n        this.channelCredentials._equals(other.channelCredentials) &&\n        this.callCredentials._equals(other.callCredentials)\n      );\n    } else {\n      return false;\n    }\n  }\n  _createSecureConnector(channelTarget: GrpcUri, options: ChannelOptions, callCredentials?: CallCredentials): SecureConnector {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials ?? CallCredentials.createEmpty());\n    return this.channelCredentials._createSecureConnector(channelTarget, options, combinedCallCredentials);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}