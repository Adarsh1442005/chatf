{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.registerResolver = registerResolver;\nexports.registerDefaultScheme = registerDefaultScheme;\nexports.createResolver = createResolver;\nexports.getDefaultAuthority = getDefaultAuthority;\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\nconst uri_parser_1 = require(\"./uri-parser\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(scheme, resolverClass) {\n  registeredResolvers[scheme] = resolverClass;\n}\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultScheme(scheme) {\n  defaultScheme = scheme;\n}\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener, options) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n  }\n}\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n  }\n}\nfunction mapUriDefaultScheme(target) {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: (0, uri_parser_1.uriToString)(target)\n      };\n    } else {\n      return null;\n    }\n  }\n  return target;\n}","map":{"version":3,"names":["exports","registerResolver","registerDefaultScheme","createResolver","getDefaultAuthority","mapUriDefaultScheme","uri_parser_1","require","registeredResolvers","defaultScheme","scheme","resolverClass","target","listener","options","undefined","Error","uriToString","authority","path"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\resolver.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { MethodConfig, ServiceConfig } from './service-config';\nimport { StatusObject } from './call-interface';\nimport { Endpoint } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChannelOptions } from './channel-options';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { Filter, FilterFactory } from './filter';\n\nexport interface CallConfig {\n  methodConfig: MethodConfig;\n  onCommitted?: () => void;\n  pickInformation: { [key: string]: string };\n  status: Status;\n  dynamicFilterFactories: FilterFactory<Filter>[];\n}\n\n/**\n * Selects a configuration for a method given the name and metadata. Defined in\n * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#new-functionality-in-grpc\n */\nexport interface ConfigSelector {\n  invoke(methodName: string, metadata: Metadata, channelId: number): CallConfig;\n  unref(): void;\n}\n\n/**\n * A listener object passed to the resolver's constructor that provides name\n * resolution updates back to the resolver's owner.\n */\nexport interface ResolverListener {\n  /**\n   * Called whenever the resolver has new name resolution results to report\n   * @param addressList The new list of backend addresses\n   * @param serviceConfig The new service configuration corresponding to the\n   *     `addressList`. Will be `null` if no service configuration was\n   *     retrieved or if the service configuration was invalid\n   * @param serviceConfigError If non-`null`, indicates that the retrieved\n   *     service configuration was invalid\n   */\n  onSuccessfulResolution(\n    addressList: Endpoint[],\n    serviceConfig: ServiceConfig | null,\n    serviceConfigError: StatusObject | null,\n    configSelector: ConfigSelector | null,\n    attributes: { [key: string]: unknown }\n  ): void;\n  /**\n   * Called whenever a name resolution attempt fails.\n   * @param error Describes how resolution failed\n   */\n  onError(error: StatusObject): void;\n}\n\n/**\n * A resolver class that handles one or more of the name syntax schemes defined\n * in the [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n */\nexport interface Resolver {\n  /**\n   * Indicates that the caller wants new name resolution data. Calling this\n   * function may eventually result in calling one of the `ResolverListener`\n   * functions, but that is not guaranteed. Those functions will never be\n   * called synchronously with the constructor or updateResolution.\n   */\n  updateResolution(): void;\n\n  /**\n   * Discard all resources owned by the resolver. A later call to\n   * `updateResolution` should reinitialize those resources.  No\n   * `ResolverListener` callbacks should be called after `destroy` is called\n   * until `updateResolution` is called again.\n   */\n  destroy(): void;\n}\n\nexport interface ResolverConstructor {\n  new (\n    target: GrpcUri,\n    listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ): Resolver;\n  /**\n   * Get the default authority for a target. This loosely corresponds to that\n   * target's hostname. Throws an error if this resolver class cannot parse the\n   * `target`.\n   * @param target\n   */\n  getDefaultAuthority(target: GrpcUri): string;\n}\n\nconst registeredResolvers: { [scheme: string]: ResolverConstructor } = {};\nlet defaultScheme: string | null = null;\n\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nexport function registerResolver(\n  scheme: string,\n  resolverClass: ResolverConstructor\n) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nexport function registerDefaultScheme(scheme: string) {\n  defaultScheme = scheme;\n}\n\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nexport function createResolver(\n  target: GrpcUri,\n  listener: ResolverListener,\n  options: ChannelOptions\n): Resolver {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(\n      `No resolver could be created for target ${uriToString(target)}`\n    );\n  }\n}\n\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nexport function getDefaultAuthority(target: GrpcUri): string {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uriToString(target)}`);\n  }\n}\n\nexport function mapUriDefaultScheme(target: GrpcUri): GrpcUri | null {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uriToString(target),\n      };\n    } else {\n      return null;\n    }\n  }\n  return target;\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;AAsHAA,OAAA,CAAAC,gBAAA,GAAAA,gBAAA;AAYAD,OAAA,CAAAE,qBAAA,GAAAA,qBAAA;AAUAF,OAAA,CAAAG,cAAA,GAAAA,cAAA;AAmBAH,OAAA,CAAAI,mBAAA,GAAAA,mBAAA;AAQAJ,OAAA,CAAAK,mBAAA,GAAAA,mBAAA;AAnJA,MAAAC,YAAA,GAAAC,OAAA;AAwFA,MAAMC,mBAAmB,GAA8C,EAAE;AACzE,IAAIC,aAAa,GAAkB,IAAI;AAEvC;;;;;;;AAOA,SAAgBR,gBAAgBA,CAC9BS,MAAc,EACdC,aAAkC;EAElCH,mBAAmB,CAACE,MAAM,CAAC,GAAGC,aAAa;AAC7C;AAEA;;;;;AAKA,SAAgBT,qBAAqBA,CAACQ,MAAc;EAClDD,aAAa,GAAGC,MAAM;AACxB;AAEA;;;;;;AAMA,SAAgBP,cAAcA,CAC5BS,MAAe,EACfC,QAA0B,EAC1BC,OAAuB;EAEvB,IAAIF,MAAM,CAACF,MAAM,KAAKK,SAAS,IAAIH,MAAM,CAACF,MAAM,IAAIF,mBAAmB,EAAE;IACvE,OAAO,IAAIA,mBAAmB,CAACI,MAAM,CAACF,MAAM,CAAC,CAACE,MAAM,EAAEC,QAAQ,EAAEC,OAAO,CAAC;EAC1E,CAAC,MAAM;IACL,MAAM,IAAIE,KAAK,CACb,2CAA2C,IAAAV,YAAA,CAAAW,WAAW,EAACL,MAAM,CAAC,EAAE,CACjE;EACH;AACF;AAEA;;;;;AAKA,SAAgBR,mBAAmBA,CAACQ,MAAe;EACjD,IAAIA,MAAM,CAACF,MAAM,KAAKK,SAAS,IAAIH,MAAM,CAACF,MAAM,IAAIF,mBAAmB,EAAE;IACvE,OAAOA,mBAAmB,CAACI,MAAM,CAACF,MAAM,CAAC,CAACN,mBAAmB,CAACQ,MAAM,CAAC;EACvE,CAAC,MAAM;IACL,MAAM,IAAII,KAAK,CAAC,kBAAkB,IAAAV,YAAA,CAAAW,WAAW,EAACL,MAAM,CAAC,EAAE,CAAC;EAC1D;AACF;AAEA,SAAgBP,mBAAmBA,CAACO,MAAe;EACjD,IAAIA,MAAM,CAACF,MAAM,KAAKK,SAAS,IAAI,EAAEH,MAAM,CAACF,MAAM,IAAIF,mBAAmB,CAAC,EAAE;IAC1E,IAAIC,aAAa,KAAK,IAAI,EAAE;MAC1B,OAAO;QACLC,MAAM,EAAED,aAAa;QACrBS,SAAS,EAAEH,SAAS;QACpBI,IAAI,EAAE,IAAAb,YAAA,CAAAW,WAAW,EAACL,MAAM;OACzB;IACH,CAAC,MAAM;MACL,OAAO,IAAI;IACb;EACF;EACA,OAAOA,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}