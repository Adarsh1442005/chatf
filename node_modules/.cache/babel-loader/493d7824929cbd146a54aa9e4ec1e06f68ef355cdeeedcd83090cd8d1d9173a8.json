{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InternalChannel = exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = void 0;\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst metadata_1 = require(\"./metadata\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst channelz_1 = require(\"./channelz\");\nconst load_balancing_call_1 = require(\"./load-balancing-call\");\nconst deadline_1 = require(\"./deadline\");\nconst resolving_call_1 = require(\"./resolving-call\");\nconst call_number_1 = require(\"./call-number\");\nconst control_plane_status_1 = require(\"./control-plane-status\");\nconst retrying_call_1 = require(\"./retrying-call\");\nconst subchannel_interface_1 = require(\"./subchannel-interface\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n  constructor(childSubchannel, channel) {\n    super(childSubchannel);\n    this.channel = channel;\n    this.refCount = 0;\n    this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\n      channel.throttleKeepalive(keepaliveTime);\n    };\n  }\n  ref() {\n    if (this.refCount === 0) {\n      this.child.addConnectivityStateListener(this.subchannelStateListener);\n      this.channel.addWrappedSubchannel(this);\n    }\n    this.child.ref();\n    this.refCount += 1;\n  }\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      this.child.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channel.removeWrappedSubchannel(this);\n    }\n  }\n}\nclass ShutdownPicker {\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.DROP,\n      status: {\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Channel closed before call started',\n        metadata: new metadata_1.Metadata()\n      },\n      subchannel: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n}\nexports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = 'grpc.internal.no_subchannel';\nclass ChannelzInfoTracker {\n  constructor(target) {\n    this.target = target;\n    this.trace = new channelz_1.ChannelzTrace();\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.state = connectivity_state_1.ConnectivityState.IDLE;\n  }\n  getChannelzInfoCallback() {\n    return () => {\n      return {\n        target: this.target,\n        state: this.state,\n        trace: this.trace,\n        callTracker: this.callTracker,\n        children: this.childrenTracker.getChildLists()\n      };\n    };\n  }\n}\nclass InternalChannel {\n  constructor(target, credentials, options) {\n    var _a, _b, _c, _d, _e, _f;\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    /**\n     * This timer does not do anything on its own. Its purpose is to hold the\n     * event loop open while there are any pending calls for the channel that\n     * have not yet been assigned to specific subchannels. In other words,\n     * the invariant is that callRefTimer is reffed if and only if pickQueue\n     * is non-empty. In addition, the timer is null while the state is IDLE or\n     * SHUTDOWN and there are no pending calls.\n     */\n    this.callRefTimer = null;\n    this.configSelector = null;\n    /**\n     * This is the error from the name resolver if it failed most recently. It\n     * is only used to end calls that start while there is no config selector\n     * and the name resolver is in backoff, so it should be nulled if\n     * configSelector becomes set or the channel state becomes anything other\n     * than TRANSIENT_FAILURE.\n     */\n    this.currentResolutionError = null;\n    this.wrappedSubchannels = new Set();\n    this.callCount = 0;\n    this.idleTimer = null;\n    // Channelz info\n    this.channelzEnabled = true;\n    /**\n     * Randomly generated ID to be passed to the config selector, for use by\n     * ring_hash in xDS. An integer distributed approximately uniformly between\n     * 0 and MAX_SAFE_INTEGER.\n     */\n    this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.channelzInfoTracker = new ChannelzInfoTracker(target);\n    const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, this.channelzInfoTracker.getChannelzInfoCallback(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Channel created');\n    }\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n    }\n    const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_a = options['grpc.use_local_subchannel_pool']) !== null && _a !== void 0 ? _a : 0) === 0);\n    this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_b = options['grpc.retry_buffer_size']) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_c = options['grpc.per_rpc_retry_buffer_size']) !== null && _c !== void 0 ? _c : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n    this.keepaliveTime = (_d = options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : -1;\n    this.idleTimeoutMs = Math.max((_e = options['grpc.client_idle_timeout_ms']) !== null && _e !== void 0 ? _e : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const finalSubchannelArgs = {};\n        for (const [key, value] of Object.entries(subchannelArgs)) {\n          if (!key.startsWith(exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX)) {\n            finalSubchannelArgs[key] = value;\n          }\n        }\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, finalSubchannelArgs, this.credentials);\n        subchannel.throttleKeepalive(this.keepaliveTime);\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n        return wrappedSubchannel;\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        if (queueCopy.length > 0) {\n          this.callRefTimerUnref();\n        }\n        for (const call of queueCopy) {\n          call.doPick();\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      },\n      addChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {\n      var _a;\n      if (serviceConfig.retryThrottling) {\n        RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n      } else {\n        RETRY_THROTTLER_MAP.delete(this.getTarget());\n      }\n      if (this.channelzEnabled) {\n        this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Address resolution succeeded');\n      }\n      (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\n      this.configSelector = configSelector;\n      this.currentResolutionError = null;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        if (localQueue.length > 0) {\n          this.callRefTimerUnref();\n        }\n        for (const call of localQueue) {\n          call.getConfig();\n        }\n      });\n    }, status => {\n      if (this.channelzEnabled) {\n        this.channelzInfoTracker.trace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n      }\n      if (this.configSelectionQueue.length > 0) {\n        this.trace('Name resolution failed with calls queued for config selection');\n      }\n      if (this.configSelector === null) {\n        this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), {\n          metadata: status.metadata\n        });\n      }\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      if (localQueue.length > 0) {\n        this.callRefTimerUnref();\n      }\n      for (const call of localQueue) {\n        call.reportResolverError(status);\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new compression_filter_1.CompressionFilterFactory(this, this.options)]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    if ((0, logging_1.isTracerEnabled)('channel_stacktrace')) {\n      (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + ((_f = error.stack) === null || _f === void 0 ? void 0 : _f.substring(error.stack.indexOf('\\n') + 1)));\n    }\n    this.lastActivityTimestamp = new Date();\n  }\n  trace(text, verbosityOverride) {\n    (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);\n  }\n  callRefTimerRef() {\n    var _a, _b, _c, _d;\n    if (!this.callRefTimer) {\n      this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    }\n    // If the hasRef function does not exist, always run the code\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      this.trace('callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n  callRefTimerUnref() {\n    var _a, _b, _c;\n    // If the timer or the hasRef function does not exist, always run the code\n    if (!((_a = this.callRefTimer) === null || _a === void 0 ? void 0 : _a.hasRef) || this.callRefTimer.hasRef()) {\n      this.trace('callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_c = (_b = this.callRefTimer) === null || _b === void 0 ? void 0 : _b.unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n  }\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n  updateState(newState) {\n    (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    this.channelzInfoTracker.state = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n      for (const wrappedSubchannel of this.wrappedSubchannels) {\n        wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n      }\n    }\n  }\n  addWrappedSubchannel(wrappedSubchannel) {\n    this.wrappedSubchannels.add(wrappedSubchannel);\n  }\n  removeWrappedSubchannel(wrappedSubchannel) {\n    this.wrappedSubchannels.delete(wrappedSubchannel);\n  }\n  doPick(metadata, extraPickInfo) {\n    return this.currentPicker.pick({\n      metadata: metadata,\n      extraPickInfo: extraPickInfo\n    });\n  }\n  queueCallForPick(call) {\n    this.pickQueue.push(call);\n    this.callRefTimerRef();\n  }\n  getConfig(method, metadata) {\n    if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    if (this.configSelector) {\n      return {\n        type: 'SUCCESS',\n        config: this.configSelector.invoke(method, metadata, this.randomChannelId)\n      };\n    } else {\n      if (this.currentResolutionError) {\n        return {\n          type: 'ERROR',\n          error: this.currentResolutionError\n        };\n      } else {\n        return {\n          type: 'NONE'\n        };\n      }\n    }\n  }\n  queueCallForConfig(call) {\n    this.configSelectionQueue.push(call);\n    this.callRefTimerRef();\n  }\n  enterIdle() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.IDLE);\n    this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n      this.idleTimer = null;\n    }\n    if (this.callRefTimer) {\n      clearInterval(this.callRefTimer);\n      this.callRefTimer = null;\n    }\n  }\n  startIdleTimeout(timeoutMs) {\n    var _a, _b;\n    this.idleTimer = setTimeout(() => {\n      if (this.callCount > 0) {\n        /* If there is currently a call, the channel will not go idle for a\n         * period of at least idleTimeoutMs, so check again after that time.\n         */\n        this.startIdleTimeout(this.idleTimeoutMs);\n        return;\n      }\n      const now = new Date();\n      const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\n      if (timeSinceLastActivity >= this.idleTimeoutMs) {\n        this.trace('Idle timer triggered after ' + this.idleTimeoutMs + 'ms of inactivity');\n        this.enterIdle();\n      } else {\n        /* Whenever the timer fires with the latest activity being too recent,\n         * set the timer again for the time when the time since the last\n         * activity is equal to the timeout. This should result in the timer\n         * firing no more than once every idleTimeoutMs/2 on average. */\n        this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\n      }\n    }, timeoutMs);\n    (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  maybeStartIdleTimer() {\n    if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {\n      this.startIdleTimeout(this.idleTimeoutMs);\n    }\n  }\n  onCallStart() {\n    if (this.channelzEnabled) {\n      this.channelzInfoTracker.callTracker.addCallStarted();\n    }\n    this.callCount += 1;\n  }\n  onCallEnd(status) {\n    if (this.channelzEnabled) {\n      if (status.code === constants_1.Status.OK) {\n        this.channelzInfoTracker.callTracker.addCallSucceeded();\n      } else {\n        this.channelzInfoTracker.callTracker.addCallFailed();\n      }\n    }\n    this.callCount -= 1;\n    this.lastActivityTimestamp = new Date();\n    this.maybeStartIdleTimer();\n  }\n  createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n    const callNumber = (0, call_number_1.getNextCallNumber)();\n    this.trace('createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"');\n    return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n  }\n  createRetryingCall(callConfig, method, host, credentials, deadline) {\n    const callNumber = (0, call_number_1.getNextCallNumber)();\n    this.trace('createRetryingCall [' + callNumber + '] method=\"' + method + '\"');\n    return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n  }\n  createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n    const callNumber = (0, call_number_1.getNextCallNumber)();\n    this.trace('createResolvingCall [' + callNumber + '] method=\"' + method + '\", deadline=' + (0, deadline_1.deadlineToString)(deadline));\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), callNumber);\n    this.onCallStart();\n    call.addStatusWatcher(status => {\n      this.onCallEnd(status);\n    });\n    return call;\n  }\n  close() {\n    var _a;\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n    this.currentPicker = new ShutdownPicker();\n    for (const call of this.configSelectionQueue) {\n      call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');\n    }\n    this.configSelectionQueue = [];\n    for (const call of this.pickQueue) {\n      call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');\n    }\n    this.pickQueue = [];\n    if (this.callRefTimer) {\n      clearInterval(this.callRefTimer);\n    }\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n    }\n    if (this.channelzEnabled) {\n      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n    this.subchannelPool.unrefUnusedSubchannels();\n    (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\n    this.configSelector = null;\n  }\n  getTarget() {\n    return (0, uri_parser_1.uriToString)(this.target);\n  }\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n      this.lastActivityTimestamp = new Date();\n      this.maybeStartIdleTimer();\n    }\n    return connectivityState;\n  }\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n  }\n  getOptions() {\n    return this.options;\n  }\n}\nexports.InternalChannel = InternalChannel;","map":{"version":3,"names":["channel_credentials_1","require","resolving_load_balancer_1","subchannel_pool_1","picker_1","metadata_1","constants_1","filter_stack_1","compression_filter_1","resolver_1","logging_1","http_proxy_1","uri_parser_1","connectivity_state_1","channelz_1","load_balancing_call_1","deadline_1","resolving_call_1","call_number_1","control_plane_status_1","retrying_call_1","subchannel_interface_1","MAX_TIMEOUT_TIME","MIN_IDLE_TIMEOUT_MS","DEFAULT_IDLE_TIMEOUT_MS","RETRY_THROTTLER_MAP","Map","DEFAULT_RETRY_BUFFER_SIZE_BYTES","DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES","ChannelSubchannelWrapper","BaseSubchannelWrapper","constructor","childSubchannel","channel","refCount","subchannelStateListener","subchannel","previousState","newState","keepaliveTime","throttleKeepalive","ref","child","addConnectivityStateListener","addWrappedSubchannel","unref","removeConnectivityStateListener","removeWrappedSubchannel","ShutdownPicker","pick","pickArgs","pickResultType","PickResultType","DROP","status","code","Status","UNAVAILABLE","details","metadata","Metadata","onCallStarted","onCallEnded","exports","SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX","ChannelzInfoTracker","target","trace","ChannelzTrace","callTracker","ChannelzCallTracker","childrenTracker","ChannelzChildrenTracker","state","ConnectivityState","IDLE","getChannelzInfoCallback","children","getChildLists","InternalChannel","credentials","options","connectivityState","currentPicker","UnavailablePicker","configSelectionQueue","pickQueue","connectivityStateWatchers","callRefTimer","configSelector","currentResolutionError","wrappedSubchannels","Set","callCount","idleTimer","channelzEnabled","randomChannelId","Math","floor","random","Number","MAX_SAFE_INTEGER","TypeError","ChannelCredentials","channelzInfoTracker","originalTargetUri","parseUri","Error","defaultSchemeMapResult","mapUriDefaultScheme","channelzRef","registerChannelzChannel","addTrace","defaultAuthority","getDefaultAuthority","proxyMapResult","mapProxyName","Object","assign","extraOptions","subchannelPool","getSubchannelPool","_a","retryBufferTracker","MessageBufferTracker","_b","_c","_d","idleTimeoutMs","max","_e","channelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","finalSubchannelArgs","key","value","entries","startsWith","getOrCreateSubchannel","getChannelzRef","wrappedSubchannel","updateState","picker","queueCopy","slice","length","callRefTimerUnref","call","doPick","requestReresolution","addChannelzChild","refChild","removeChannelzChild","unrefChild","resolvingLoadBalancer","ResolvingLoadBalancer","serviceConfig","retryThrottling","set","getTarget","RetryThrottler","maxTokens","tokenRatio","get","delete","process","nextTick","localQueue","getConfig","restrictControlPlaneStatusCode","reportResolverError","filterStackFactory","FilterStackFactory","CompressionFilterFactory","JSON","stringify","undefined","error","isTracerEnabled","LogVerbosity","DEBUG","id","_f","stack","substring","indexOf","lastActivityTimestamp","Date","text","verbosityOverride","uriToString","callRefTimerRef","setInterval","hasRef","removeConnectivityStateWatcher","watcherObject","watcherIndex","findIndex","splice","watchersCopy","currentState","timer","clearTimeout","callback","TRANSIENT_FAILURE","newKeepaliveTime","add","extraPickInfo","queueCallForPick","push","method","SHUTDOWN","exitIdle","type","config","invoke","queueCallForConfig","enterIdle","destroy","QueuePicker","clearInterval","startIdleTimeout","timeoutMs","setTimeout","now","timeSinceLastActivity","valueOf","maybeStartIdleTimer","onCallStart","addCallStarted","onCallEnd","OK","addCallSucceeded","addCallFailed","createLoadBalancingCall","callConfig","host","deadline","callNumber","getNextCallNumber","LoadBalancingCall","createRetryingCall","RetryingCall","createResolvingCall","parentCall","propagateFlags","deadlineToString","finalOptions","flags","Propagate","DEFAULTS","ResolvingCall","clone","addStatusWatcher","close","cancelWithStatus","unregisterChannelzRef","unrefUnusedSubchannels","getConnectivityState","tryToConnect","watchConnectivityState","Infinity","deadlineDate","getTime","createCall","getOptions"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\internal-channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ResolvingLoadBalancer } from './resolving-load-balancer';\nimport { SubchannelPool, getSubchannelPool } from './subchannel-pool';\nimport { ChannelControlHelper } from './load-balancer';\nimport { UnavailablePicker, Picker, QueuePicker, PickArgs, PickResult, PickResultType } from './picker';\nimport { Metadata } from './metadata';\nimport { Status, LogVerbosity, Propagate } from './constants';\nimport { FilterStackFactory } from './filter-stack';\nimport { CompressionFilterFactory } from './compression-filter';\nimport {\n  CallConfig,\n  ConfigSelector,\n  getDefaultAuthority,\n  mapUriDefaultScheme,\n} from './resolver';\nimport { trace, isTracerEnabled } from './logging';\nimport { SubchannelAddress } from './subchannel-address';\nimport { mapProxyName } from './http_proxy';\nimport { GrpcUri, parseUri, uriToString } from './uri-parser';\nimport { ServerSurfaceCall } from './server-call';\n\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  ChannelInfo,\n  ChannelRef,\n  ChannelzCallTracker,\n  ChannelzChildrenTracker,\n  ChannelzTrace,\n  registerChannelzChannel,\n  SubchannelRef,\n  unregisterChannelzRef,\n} from './channelz';\nimport { LoadBalancingCall } from './load-balancing-call';\nimport { CallCredentials } from './call-credentials';\nimport { Call, CallStreamOptions, StatusObject } from './call-interface';\nimport { Deadline, deadlineToString } from './deadline';\nimport { ResolvingCall } from './resolving-call';\nimport { getNextCallNumber } from './call-number';\nimport { restrictControlPlaneStatusCode } from './control-plane-status';\nimport {\n  MessageBufferTracker,\n  RetryingCall,\n  RetryThrottler,\n} from './retrying-call';\nimport {\n  BaseSubchannelWrapper,\n  ConnectivityStateListener,\n  SubchannelInterface,\n} from './subchannel-interface';\n\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\n\ninterface ConnectivityStateWatcher {\n  currentState: ConnectivityState;\n  timer: NodeJS.Timeout | null;\n  callback: (error?: Error) => void;\n}\n\ninterface NoneConfigResult {\n  type: 'NONE';\n}\n\ninterface SuccessConfigResult {\n  type: 'SUCCESS';\n  config: CallConfig;\n}\n\ninterface ErrorConfigResult {\n  type: 'ERROR';\n  error: StatusObject;\n}\n\ntype GetConfigResult =\n  | NoneConfigResult\n  | SuccessConfigResult\n  | ErrorConfigResult;\n\nconst RETRY_THROTTLER_MAP: Map<string, RetryThrottler> = new Map();\n\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\n\nclass ChannelSubchannelWrapper\n  extends BaseSubchannelWrapper\n  implements SubchannelInterface\n{\n  private refCount = 0;\n  private subchannelStateListener: ConnectivityStateListener;\n  constructor(\n    childSubchannel: SubchannelInterface,\n    private channel: InternalChannel\n  ) {\n    super(childSubchannel);\n    this.subchannelStateListener = (\n      subchannel,\n      previousState,\n      newState,\n      keepaliveTime\n    ) => {\n      channel.throttleKeepalive(keepaliveTime);\n    };\n  }\n\n  ref(): void {\n    if (this.refCount === 0) {\n      this.child.addConnectivityStateListener(this.subchannelStateListener);\n      this.channel.addWrappedSubchannel(this);\n    }\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref(): void {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      this.child.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channel.removeWrappedSubchannel(this);\n    }\n  }\n}\n\nclass ShutdownPicker implements Picker {\n  pick(pickArgs: PickArgs): PickResult {\n    return {\n      pickResultType: PickResultType.DROP,\n      status: {\n        code: Status.UNAVAILABLE,\n        details: 'Channel closed before call started',\n        metadata: new Metadata()\n      },\n      subchannel: null,\n      onCallStarted: null,\n      onCallEnded: null\n    }\n  }\n}\n\nexport const SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = 'grpc.internal.no_subchannel';\nclass ChannelzInfoTracker {\n  readonly trace = new ChannelzTrace();\n  readonly callTracker = new ChannelzCallTracker();\n  readonly childrenTracker = new ChannelzChildrenTracker();\n  state: ConnectivityState = ConnectivityState.IDLE;\n  constructor(private target: string) {}\n\n  getChannelzInfoCallback(): () => ChannelInfo {\n    return () => {\n      return {\n        target: this.target,\n        state: this.state,\n        trace: this.trace,\n        callTracker: this.callTracker,\n        children: this.childrenTracker.getChildLists()\n      };\n    };\n  }\n}\n\nexport class InternalChannel {\n  private readonly resolvingLoadBalancer: ResolvingLoadBalancer;\n  private readonly subchannelPool: SubchannelPool;\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  private currentPicker: Picker = new UnavailablePicker();\n  /**\n   * Calls queued up to get a call config. Should only be populated before the\n   * first time the resolver returns a result, which includes the ConfigSelector.\n   */\n  private configSelectionQueue: ResolvingCall[] = [];\n  private pickQueue: LoadBalancingCall[] = [];\n  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];\n  private readonly defaultAuthority: string;\n  private readonly filterStackFactory: FilterStackFactory;\n  private readonly target: GrpcUri;\n  /**\n   * This timer does not do anything on its own. Its purpose is to hold the\n   * event loop open while there are any pending calls for the channel that\n   * have not yet been assigned to specific subchannels. In other words,\n   * the invariant is that callRefTimer is reffed if and only if pickQueue\n   * is non-empty. In addition, the timer is null while the state is IDLE or\n   * SHUTDOWN and there are no pending calls.\n   */\n  private callRefTimer: NodeJS.Timeout | null = null;\n  private configSelector: ConfigSelector | null = null;\n  /**\n   * This is the error from the name resolver if it failed most recently. It\n   * is only used to end calls that start while there is no config selector\n   * and the name resolver is in backoff, so it should be nulled if\n   * configSelector becomes set or the channel state becomes anything other\n   * than TRANSIENT_FAILURE.\n   */\n  private currentResolutionError: StatusObject | null = null;\n  private readonly retryBufferTracker: MessageBufferTracker;\n  private keepaliveTime: number;\n  private readonly wrappedSubchannels: Set<ChannelSubchannelWrapper> =\n    new Set();\n\n  private callCount = 0;\n  private idleTimer: NodeJS.Timeout | null = null;\n  private readonly idleTimeoutMs: number;\n  private lastActivityTimestamp: Date;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private readonly channelzRef: ChannelRef;\n  private readonly channelzInfoTracker: ChannelzInfoTracker;\n\n  /**\n   * Randomly generated ID to be passed to the config selector, for use by\n   * ring_hash in xDS. An integer distributed approximately uniformly between\n   * 0 and MAX_SAFE_INTEGER.\n   */\n  private readonly randomChannelId = Math.floor(\n    Math.random() * Number.MAX_SAFE_INTEGER\n  );\n\n  constructor(\n    target: string,\n    private readonly credentials: ChannelCredentials,\n    private readonly options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.channelzInfoTracker = new ChannelzInfoTracker(target);\n    const originalTargetUri = parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\n        `Could not find a default scheme for target name \"${target}\"`\n      );\n    }\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzRef = registerChannelzChannel(\n      target,\n      this.channelzInfoTracker.getChannelzInfoCallback(),\n      this.channelzEnabled\n    );\n    if (this.channelzEnabled) {\n      this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Channel created');\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'] as string;\n    } else {\n      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = getSubchannelPool(\n      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0\n    );\n    this.retryBufferTracker = new MessageBufferTracker(\n      options['grpc.retry_buffer_size'] ?? DEFAULT_RETRY_BUFFER_SIZE_BYTES,\n      options['grpc.per_rpc_retry_buffer_size'] ??\n        DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES\n    );\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n    this.idleTimeoutMs = Math.max(\n      options['grpc.client_idle_timeout_ms'] ?? DEFAULT_IDLE_TIMEOUT_MS,\n      MIN_IDLE_TIMEOUT_MS\n    );\n    const channelControlHelper: ChannelControlHelper = {\n      createSubchannel: (\n        subchannelAddress: SubchannelAddress,\n        subchannelArgs: ChannelOptions\n      ) => {\n        const finalSubchannelArgs: ChannelOptions = {};\n        for (const [key, value] of Object.entries(subchannelArgs)) {\n          if (!key.startsWith(SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX)) {\n            finalSubchannelArgs[key] = value;\n          }\n        }\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(\n          this.target,\n          subchannelAddress,\n          finalSubchannelArgs,\n          this.credentials\n        );\n        subchannel.throttleKeepalive(this.keepaliveTime);\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.trace.addTrace(\n            'CT_INFO',\n            'Created subchannel or used existing subchannel',\n            subchannel.getChannelzRef()\n          );\n        }\n        const wrappedSubchannel = new ChannelSubchannelWrapper(\n          subchannel,\n          this\n        );\n        return wrappedSubchannel;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        if (queueCopy.length > 0) {\n          this.callRefTimerUnref();\n        }\n        for (const call of queueCopy) {\n          call.doPick();\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error(\n          'Resolving load balancer should never call requestReresolution'\n        );\n      },\n      addChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.childrenTracker.unrefChild(child);\n        }\n      },\n    };\n    this.resolvingLoadBalancer = new ResolvingLoadBalancer(\n      this.target,\n      channelControlHelper,\n      options,\n      (serviceConfig, configSelector) => {\n        if (serviceConfig.retryThrottling) {\n          RETRY_THROTTLER_MAP.set(\n            this.getTarget(),\n            new RetryThrottler(\n              serviceConfig.retryThrottling.maxTokens,\n              serviceConfig.retryThrottling.tokenRatio,\n              RETRY_THROTTLER_MAP.get(this.getTarget())\n            )\n          );\n        } else {\n          RETRY_THROTTLER_MAP.delete(this.getTarget());\n        }\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.trace.addTrace(\n            'CT_INFO',\n            'Address resolution succeeded'\n          );\n        }\n        this.configSelector?.unref();\n        this.configSelector = configSelector;\n        this.currentResolutionError = null;\n        /* We process the queue asynchronously to ensure that the corresponding\n         * load balancer update has completed. */\n        process.nextTick(() => {\n          const localQueue = this.configSelectionQueue;\n          this.configSelectionQueue = [];\n          if (localQueue.length > 0) {\n            this.callRefTimerUnref();\n          }\n          for (const call of localQueue) {\n            call.getConfig();\n          }\n        });\n      },\n      status => {\n        if (this.channelzEnabled) {\n          this.channelzInfoTracker.trace.addTrace(\n            'CT_WARNING',\n            'Address resolution failed with code ' +\n              status.code +\n              ' and details \"' +\n              status.details +\n              '\"'\n          );\n        }\n        if (this.configSelectionQueue.length > 0) {\n          this.trace(\n            'Name resolution failed with calls queued for config selection'\n          );\n        }\n        if (this.configSelector === null) {\n          this.currentResolutionError = {\n            ...restrictControlPlaneStatusCode(status.code, status.details),\n            metadata: status.metadata,\n          };\n        }\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        if (localQueue.length > 0) {\n          this.callRefTimerUnref();\n        }\n        for (const call of localQueue) {\n          call.reportResolverError(status);\n        }\n      }\n    );\n    this.filterStackFactory = new FilterStackFactory([\n      new CompressionFilterFactory(this, this.options),\n    ]);\n    this.trace(\n      'Channel constructed with options ' +\n        JSON.stringify(options, undefined, 2)\n    );\n    const error = new Error();\n    if (isTracerEnabled('channel_stacktrace')){\n      trace(\n        LogVerbosity.DEBUG,\n        'channel_stacktrace',\n        '(' +\n          this.channelzRef.id +\n          ') ' +\n          'Channel constructed \\n' +\n          error.stack?.substring(error.stack.indexOf('\\n') + 1)\n      );\n    }\n    this.lastActivityTimestamp = new Date();\n  }\n\n  private trace(text: string, verbosityOverride?: LogVerbosity) {\n    trace(\n      verbosityOverride ?? LogVerbosity.DEBUG,\n      'channel',\n      '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text\n    );\n  }\n\n  private callRefTimerRef() {\n    if (!this.callRefTimer) {\n      this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME)\n    }\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef?.()) {\n      this.trace(\n        'callRefTimer.ref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.ref?.();\n    }\n  }\n\n  private callRefTimerUnref() {\n    // If the timer or the hasRef function does not exist, always run the code\n    if (!this.callRefTimer?.hasRef || this.callRefTimer.hasRef()) {\n      this.trace(\n        'callRefTimer.unref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer?.unref?.();\n    }\n  }\n\n  private removeConnectivityStateWatcher(\n    watcherObject: ConnectivityStateWatcher\n  ) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(\n      value => value === watcherObject\n    );\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  private updateState(newState: ConnectivityState): void {\n    trace(\n      LogVerbosity.DEBUG,\n      'connectivity_state',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzInfoTracker.trace.addTrace(\n        'CT_INFO',\n        'Connectivity state change to ' + ConnectivityState[newState]\n      );\n    }\n    this.connectivityState = newState;\n    this.channelzInfoTracker.state = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n      for (const wrappedSubchannel of this.wrappedSubchannels) {\n        wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n      }\n    }\n  }\n\n  addWrappedSubchannel(wrappedSubchannel: ChannelSubchannelWrapper) {\n    this.wrappedSubchannels.add(wrappedSubchannel);\n  }\n\n  removeWrappedSubchannel(wrappedSubchannel: ChannelSubchannelWrapper) {\n    this.wrappedSubchannels.delete(wrappedSubchannel);\n  }\n\n  doPick(metadata: Metadata, extraPickInfo: { [key: string]: string }) {\n    return this.currentPicker.pick({\n      metadata: metadata,\n      extraPickInfo: extraPickInfo,\n    });\n  }\n\n  queueCallForPick(call: LoadBalancingCall) {\n    this.pickQueue.push(call);\n    this.callRefTimerRef();\n  }\n\n  getConfig(method: string, metadata: Metadata): GetConfigResult {\n    if (this.connectivityState !== ConnectivityState.SHUTDOWN) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    if (this.configSelector) {\n      return {\n        type: 'SUCCESS',\n        config: this.configSelector.invoke(method, metadata, this.randomChannelId),\n      };\n    } else {\n      if (this.currentResolutionError) {\n        return {\n          type: 'ERROR',\n          error: this.currentResolutionError,\n        };\n      } else {\n        return {\n          type: 'NONE',\n        };\n      }\n    }\n  }\n\n  queueCallForConfig(call: ResolvingCall) {\n    this.configSelectionQueue.push(call);\n    this.callRefTimerRef();\n  }\n\n  private enterIdle() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.IDLE);\n    this.currentPicker = new QueuePicker(this.resolvingLoadBalancer);\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n      this.idleTimer = null;\n    }\n    if (this.callRefTimer) {\n      clearInterval(this.callRefTimer);\n      this.callRefTimer = null;\n    }\n  }\n\n  private startIdleTimeout(timeoutMs: number) {\n    this.idleTimer = setTimeout(() => {\n      if (this.callCount > 0) {\n        /* If there is currently a call, the channel will not go idle for a\n         * period of at least idleTimeoutMs, so check again after that time.\n         */\n        this.startIdleTimeout(this.idleTimeoutMs);\n        return;\n      }\n      const now = new Date();\n      const timeSinceLastActivity =\n        now.valueOf() - this.lastActivityTimestamp.valueOf();\n      if (timeSinceLastActivity >= this.idleTimeoutMs) {\n        this.trace(\n          'Idle timer triggered after ' +\n            this.idleTimeoutMs +\n            'ms of inactivity'\n        );\n        this.enterIdle();\n      } else {\n        /* Whenever the timer fires with the latest activity being too recent,\n         * set the timer again for the time when the time since the last\n         * activity is equal to the timeout. This should result in the timer\n         * firing no more than once every idleTimeoutMs/2 on average. */\n        this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\n      }\n    }, timeoutMs);\n    this.idleTimer.unref?.();\n  }\n\n  private maybeStartIdleTimer() {\n    if (\n      this.connectivityState !== ConnectivityState.SHUTDOWN &&\n      !this.idleTimer\n    ) {\n      this.startIdleTimeout(this.idleTimeoutMs);\n    }\n  }\n\n  private onCallStart() {\n    if (this.channelzEnabled) {\n      this.channelzInfoTracker.callTracker.addCallStarted();\n    }\n    this.callCount += 1;\n  }\n\n  private onCallEnd(status: StatusObject) {\n    if (this.channelzEnabled) {\n      if (status.code === Status.OK) {\n        this.channelzInfoTracker.callTracker.addCallSucceeded();\n      } else {\n        this.channelzInfoTracker.callTracker.addCallFailed();\n      }\n    }\n    this.callCount -= 1;\n    this.lastActivityTimestamp = new Date();\n    this.maybeStartIdleTimer();\n  }\n\n  createLoadBalancingCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): LoadBalancingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"'\n    );\n    return new LoadBalancingCall(\n      this,\n      callConfig,\n      method,\n      host,\n      credentials,\n      deadline,\n      callNumber\n    );\n  }\n\n  createRetryingCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): RetryingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createRetryingCall [' + callNumber + '] method=\"' + method + '\"'\n    );\n    return new RetryingCall(\n      this,\n      callConfig,\n      method,\n      host,\n      credentials,\n      deadline,\n      callNumber,\n      this.retryBufferTracker,\n      RETRY_THROTTLER_MAP.get(this.getTarget())\n    );\n  }\n\n  createResolvingCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): ResolvingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createResolvingCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\", deadline=' +\n        deadlineToString(deadline)\n    );\n    const finalOptions: CallStreamOptions = {\n      deadline: deadline,\n      flags: propagateFlags ?? Propagate.DEFAULTS,\n      host: host ?? this.defaultAuthority,\n      parentCall: parentCall,\n    };\n\n    const call = new ResolvingCall(\n      this,\n      method,\n      finalOptions,\n      this.filterStackFactory.clone(),\n      callNumber\n    );\n\n    this.onCallStart();\n    call.addStatusWatcher(status => {\n      this.onCallEnd(status);\n    });\n    return call;\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    this.currentPicker = new ShutdownPicker();\n    for (const call of this.configSelectionQueue) {\n      call.cancelWithStatus(Status.UNAVAILABLE, 'Channel closed before call started');\n    }\n    this.configSelectionQueue = [];\n    for (const call of this.pickQueue) {\n      call.cancelWithStatus(Status.UNAVAILABLE, 'Channel closed before call started');\n    }\n    this.pickQueue = [];\n    if (this.callRefTimer) {\n      clearInterval(this.callRefTimer);\n    }\n    if (this.idleTimer) {\n      clearTimeout(this.idleTimer);\n    }\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n    this.configSelector?.unref();\n    this.configSelector = null;\n  }\n\n  getTarget() {\n    return uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n      this.lastActivityTimestamp = new Date();\n      this.maybeStartIdleTimer();\n    }\n    return connectivityState;\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate: Date =\n        deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(\n          callback,\n          new Error('Deadline passed without connectivity state change')\n        );\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(\n          new Error('Deadline passed without connectivity state change')\n        );\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer,\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    return this.createResolvingCall(\n      method,\n      deadline,\n      host,\n      parentCall,\n      propagateFlags\n    );\n  }\n\n  getOptions() {\n    return this.options;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}