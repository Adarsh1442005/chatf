{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EndpointMap = void 0;\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nexports.subchannelAddressEqual = subchannelAddressEqual;\nexports.subchannelAddressToString = subchannelAddressToString;\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\nexports.endpointEqual = endpointEqual;\nexports.endpointToString = endpointToString;\nexports.endpointHasAddress = endpointHasAddress;\nconst net_1 = require(\"net\");\nfunction isTcpSubchannelAddress(address) {\n  return 'port' in address;\n}\nfunction subchannelAddressEqual(address1, address2) {\n  if (!address1 && !address2) {\n    return true;\n  }\n  if (!address1 || !address2) {\n    return false;\n  }\n  if (isTcpSubchannelAddress(address1)) {\n    return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n  } else {\n    return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n  }\n}\nfunction subchannelAddressToString(address) {\n  if (isTcpSubchannelAddress(address)) {\n    if ((0, net_1.isIPv6)(address.host)) {\n      return '[' + address.host + ']:' + address.port;\n    } else {\n      return address.host + ':' + address.port;\n    }\n  } else {\n    return address.path;\n  }\n}\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n  if ((0, net_1.isIP)(addressString)) {\n    return {\n      host: addressString,\n      port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n    };\n  } else {\n    return {\n      path: addressString\n    };\n  }\n}\nfunction endpointEqual(endpoint1, endpoint2) {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (let i = 0; i < endpoint1.addresses.length; i++) {\n    if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction endpointToString(endpoint) {\n  return '[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']';\n}\nfunction endpointHasAddress(endpoint, expectedAddress) {\n  for (const address of endpoint.addresses) {\n    if (subchannelAddressEqual(address, expectedAddress)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction endpointEqualUnordered(endpoint1, endpoint2) {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (const address1 of endpoint1.addresses) {\n    let matchFound = false;\n    for (const address2 of endpoint2.addresses) {\n      if (subchannelAddressEqual(address1, address2)) {\n        matchFound = true;\n        break;\n      }\n    }\n    if (!matchFound) {\n      return false;\n    }\n  }\n  return true;\n}\nclass EndpointMap {\n  constructor() {\n    this.map = new Set();\n  }\n  get size() {\n    return this.map.size;\n  }\n  getForSubchannelAddress(address) {\n    for (const entry of this.map) {\n      if (endpointHasAddress(entry.key, address)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Delete any entries in this map with keys that are not in endpoints\n   * @param endpoints\n   */\n  deleteMissing(endpoints) {\n    const removedValues = [];\n    for (const entry of this.map) {\n      let foundEntry = false;\n      for (const endpoint of endpoints) {\n        if (endpointEqualUnordered(endpoint, entry.key)) {\n          foundEntry = true;\n        }\n      }\n      if (!foundEntry) {\n        removedValues.push(entry.value);\n        this.map.delete(entry);\n      }\n    }\n    return removedValues;\n  }\n  get(endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n  set(endpoint, mapEntry) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        entry.value = mapEntry;\n        return;\n      }\n    }\n    this.map.add({\n      key: endpoint,\n      value: mapEntry\n    });\n  }\n  delete(endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        this.map.delete(entry);\n        return;\n      }\n    }\n  }\n  has(endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  clear() {\n    this.map.clear();\n  }\n  *keys() {\n    for (const entry of this.map) {\n      yield entry.key;\n    }\n  }\n  *values() {\n    for (const entry of this.map) {\n      yield entry.value;\n    }\n  }\n  *entries() {\n    for (const entry of this.map) {\n      yield [entry.key, entry.value];\n    }\n  }\n}\nexports.EndpointMap = EndpointMap;","map":{"version":3,"names":["exports","isTcpSubchannelAddress","subchannelAddressEqual","subchannelAddressToString","stringToSubchannelAddress","endpointEqual","endpointToString","endpointHasAddress","net_1","require","address","address1","address2","host","port","path","isIPv6","DEFAULT_PORT","addressString","isIP","endpoint1","endpoint2","addresses","length","i","endpoint","map","join","expectedAddress","endpointEqualUnordered","matchFound","EndpointMap","constructor","Set","size","getForSubchannelAddress","entry","key","value","undefined","deleteMissing","endpoints","removedValues","foundEntry","push","delete","get","set","mapEntry","add","has","clear","keys","values","entries"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\subchannel-address.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIP, isIPv6 } from 'net';\n\nexport interface TcpSubchannelAddress {\n  port: number;\n  host: string;\n}\n\nexport interface IpcSubchannelAddress {\n  path: string;\n}\n/**\n * This represents a single backend address to connect to. This interface is a\n * subset of net.SocketConnectOpts, i.e. the options described at\n * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener.\n * Those are in turn a subset of the options that can be passed to http2.connect.\n */\n\nexport type SubchannelAddress = TcpSubchannelAddress | IpcSubchannelAddress;\n\nexport function isTcpSubchannelAddress(\n  address: SubchannelAddress\n): address is TcpSubchannelAddress {\n  return 'port' in address;\n}\n\nexport function subchannelAddressEqual(\n  address1?: SubchannelAddress,\n  address2?: SubchannelAddress\n): boolean {\n  if (!address1 && !address2) {\n    return true;\n  }\n  if (!address1 || !address2) {\n    return false;\n  }\n  if (isTcpSubchannelAddress(address1)) {\n    return (\n      isTcpSubchannelAddress(address2) &&\n      address1.host === address2.host &&\n      address1.port === address2.port\n    );\n  } else {\n    return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n  }\n}\n\nexport function subchannelAddressToString(address: SubchannelAddress): string {\n  if (isTcpSubchannelAddress(address)) {\n    if (isIPv6(address.host)) {\n      return '[' + address.host + ']:' + address.port;\n    } else {\n      return address.host + ':' + address.port;\n    }\n  } else {\n    return address.path;\n  }\n}\n\nconst DEFAULT_PORT = 443;\n\nexport function stringToSubchannelAddress(\n  addressString: string,\n  port?: number\n): SubchannelAddress {\n  if (isIP(addressString)) {\n    return {\n      host: addressString,\n      port: port ?? DEFAULT_PORT,\n    };\n  } else {\n    return {\n      path: addressString,\n    };\n  }\n}\n\nexport interface Endpoint {\n  addresses: SubchannelAddress[];\n}\n\nexport function endpointEqual(endpoint1: Endpoint, endpoint2: Endpoint) {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (let i = 0; i < endpoint1.addresses.length; i++) {\n    if (\n      !subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function endpointToString(endpoint: Endpoint): string {\n  return (\n    '[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']'\n  );\n}\n\nexport function endpointHasAddress(\n  endpoint: Endpoint,\n  expectedAddress: SubchannelAddress\n): boolean {\n  for (const address of endpoint.addresses) {\n    if (subchannelAddressEqual(address, expectedAddress)) {\n      return true;\n    }\n  }\n  return false;\n}\n\ninterface EndpointMapEntry<ValueType> {\n  key: Endpoint;\n  value: ValueType;\n}\n\nfunction endpointEqualUnordered(\n  endpoint1: Endpoint,\n  endpoint2: Endpoint\n): boolean {\n  if (endpoint1.addresses.length !== endpoint2.addresses.length) {\n    return false;\n  }\n  for (const address1 of endpoint1.addresses) {\n    let matchFound = false;\n    for (const address2 of endpoint2.addresses) {\n      if (subchannelAddressEqual(address1, address2)) {\n        matchFound = true;\n        break;\n      }\n    }\n    if (!matchFound) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport class EndpointMap<ValueType> {\n  private map: Set<EndpointMapEntry<ValueType>> = new Set();\n\n  get size() {\n    return this.map.size;\n  }\n\n  getForSubchannelAddress(address: SubchannelAddress): ValueType | undefined {\n    for (const entry of this.map) {\n      if (endpointHasAddress(entry.key, address)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Delete any entries in this map with keys that are not in endpoints\n   * @param endpoints\n   */\n  deleteMissing(endpoints: Endpoint[]): ValueType[] {\n    const removedValues: ValueType[] = [];\n    for (const entry of this.map) {\n      let foundEntry = false;\n      for (const endpoint of endpoints) {\n        if (endpointEqualUnordered(endpoint, entry.key)) {\n          foundEntry = true;\n        }\n      }\n      if (!foundEntry) {\n        removedValues.push(entry.value);\n        this.map.delete(entry);\n      }\n    }\n    return removedValues;\n  }\n\n  get(endpoint: Endpoint): ValueType | undefined {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return entry.value;\n      }\n    }\n    return undefined;\n  }\n\n  set(endpoint: Endpoint, mapEntry: ValueType) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        entry.value = mapEntry;\n        return;\n      }\n    }\n    this.map.add({ key: endpoint, value: mapEntry });\n  }\n\n  delete(endpoint: Endpoint) {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        this.map.delete(entry);\n        return;\n      }\n    }\n  }\n\n  has(endpoint: Endpoint): boolean {\n    for (const entry of this.map) {\n      if (endpointEqualUnordered(endpoint, entry.key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n  *keys(): IterableIterator<Endpoint> {\n    for (const entry of this.map) {\n      yield entry.key;\n    }\n  }\n\n  *values(): IterableIterator<ValueType> {\n    for (const entry of this.map) {\n      yield entry.value;\n    }\n  }\n\n  *entries(): IterableIterator<[Endpoint, ValueType]> {\n    for (const entry of this.map) {\n      yield [entry.key, entry.value];\n    }\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAoCAA,OAAA,CAAAC,sBAAA,GAAAA,sBAAA;AAMAD,OAAA,CAAAE,sBAAA,GAAAA,sBAAA;AAqBAF,OAAA,CAAAG,yBAAA,GAAAA,yBAAA;AAcAH,OAAA,CAAAI,yBAAA,GAAAA,yBAAA;AAoBAJ,OAAA,CAAAK,aAAA,GAAAA,aAAA;AAcAL,OAAA,CAAAM,gBAAA,GAAAA,gBAAA;AAMAN,OAAA,CAAAO,kBAAA,GAAAA,kBAAA;AApGA,MAAAC,KAAA,GAAAC,OAAA;AAmBA,SAAgBR,sBAAsBA,CACpCS,OAA0B;EAE1B,OAAO,MAAM,IAAIA,OAAO;AAC1B;AAEA,SAAgBR,sBAAsBA,CACpCS,QAA4B,EAC5BC,QAA4B;EAE5B,IAAI,CAACD,QAAQ,IAAI,CAACC,QAAQ,EAAE;IAC1B,OAAO,IAAI;EACb;EACA,IAAI,CAACD,QAAQ,IAAI,CAACC,QAAQ,EAAE;IAC1B,OAAO,KAAK;EACd;EACA,IAAIX,sBAAsB,CAACU,QAAQ,CAAC,EAAE;IACpC,OACEV,sBAAsB,CAACW,QAAQ,CAAC,IAChCD,QAAQ,CAACE,IAAI,KAAKD,QAAQ,CAACC,IAAI,IAC/BF,QAAQ,CAACG,IAAI,KAAKF,QAAQ,CAACE,IAAI;EAEnC,CAAC,MAAM;IACL,OAAO,CAACb,sBAAsB,CAACW,QAAQ,CAAC,IAAID,QAAQ,CAACI,IAAI,KAAKH,QAAQ,CAACG,IAAI;EAC7E;AACF;AAEA,SAAgBZ,yBAAyBA,CAACO,OAA0B;EAClE,IAAIT,sBAAsB,CAACS,OAAO,CAAC,EAAE;IACnC,IAAI,IAAAF,KAAA,CAAAQ,MAAM,EAACN,OAAO,CAACG,IAAI,CAAC,EAAE;MACxB,OAAO,GAAG,GAAGH,OAAO,CAACG,IAAI,GAAG,IAAI,GAAGH,OAAO,CAACI,IAAI;IACjD,CAAC,MAAM;MACL,OAAOJ,OAAO,CAACG,IAAI,GAAG,GAAG,GAAGH,OAAO,CAACI,IAAI;IAC1C;EACF,CAAC,MAAM;IACL,OAAOJ,OAAO,CAACK,IAAI;EACrB;AACF;AAEA,MAAME,YAAY,GAAG,GAAG;AAExB,SAAgBb,yBAAyBA,CACvCc,aAAqB,EACrBJ,IAAa;EAEb,IAAI,IAAAN,KAAA,CAAAW,IAAI,EAACD,aAAa,CAAC,EAAE;IACvB,OAAO;MACLL,IAAI,EAAEK,aAAa;MACnBJ,IAAI,EAAEA,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAIG;KACf;EACH,CAAC,MAAM;IACL,OAAO;MACLF,IAAI,EAAEG;KACP;EACH;AACF;AAMA,SAAgBb,aAAaA,CAACe,SAAmB,EAAEC,SAAmB;EACpE,IAAID,SAAS,CAACE,SAAS,CAACC,MAAM,KAAKF,SAAS,CAACC,SAAS,CAACC,MAAM,EAAE;IAC7D,OAAO,KAAK;EACd;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,SAAS,CAACE,SAAS,CAACC,MAAM,EAAEC,CAAC,EAAE,EAAE;IACnD,IACE,CAACtB,sBAAsB,CAACkB,SAAS,CAACE,SAAS,CAACE,CAAC,CAAC,EAAEH,SAAS,CAACC,SAAS,CAACE,CAAC,CAAC,CAAC,EACvE;MACA,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AAEA,SAAgBlB,gBAAgBA,CAACmB,QAAkB;EACjD,OACE,GAAG,GAAGA,QAAQ,CAACH,SAAS,CAACI,GAAG,CAACvB,yBAAyB,CAAC,CAACwB,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;AAE5E;AAEA,SAAgBpB,kBAAkBA,CAChCkB,QAAkB,EAClBG,eAAkC;EAElC,KAAK,MAAMlB,OAAO,IAAIe,QAAQ,CAACH,SAAS,EAAE;IACxC,IAAIpB,sBAAsB,CAACQ,OAAO,EAAEkB,eAAe,CAAC,EAAE;MACpD,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AAOA,SAASC,sBAAsBA,CAC7BT,SAAmB,EACnBC,SAAmB;EAEnB,IAAID,SAAS,CAACE,SAAS,CAACC,MAAM,KAAKF,SAAS,CAACC,SAAS,CAACC,MAAM,EAAE;IAC7D,OAAO,KAAK;EACd;EACA,KAAK,MAAMZ,QAAQ,IAAIS,SAAS,CAACE,SAAS,EAAE;IAC1C,IAAIQ,UAAU,GAAG,KAAK;IACtB,KAAK,MAAMlB,QAAQ,IAAIS,SAAS,CAACC,SAAS,EAAE;MAC1C,IAAIpB,sBAAsB,CAACS,QAAQ,EAAEC,QAAQ,CAAC,EAAE;QAC9CkB,UAAU,GAAG,IAAI;QACjB;MACF;IACF;IACA,IAAI,CAACA,UAAU,EAAE;MACf,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AAEA,MAAaC,WAAW;EAAxBC,YAAA;IACU,KAAAN,GAAG,GAAqC,IAAIO,GAAG,EAAE;EA8F3D;EA5FE,IAAIC,IAAIA,CAAA;IACN,OAAO,IAAI,CAACR,GAAG,CAACQ,IAAI;EACtB;EAEAC,uBAAuBA,CAACzB,OAA0B;IAChD,KAAK,MAAM0B,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,IAAInB,kBAAkB,CAAC6B,KAAK,CAACC,GAAG,EAAE3B,OAAO,CAAC,EAAE;QAC1C,OAAO0B,KAAK,CAACE,KAAK;MACpB;IACF;IACA,OAAOC,SAAS;EAClB;EAEA;;;;EAIAC,aAAaA,CAACC,SAAqB;IACjC,MAAMC,aAAa,GAAgB,EAAE;IACrC,KAAK,MAAMN,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,IAAIiB,UAAU,GAAG,KAAK;MACtB,KAAK,MAAMlB,QAAQ,IAAIgB,SAAS,EAAE;QAChC,IAAIZ,sBAAsB,CAACJ,QAAQ,EAAEW,KAAK,CAACC,GAAG,CAAC,EAAE;UAC/CM,UAAU,GAAG,IAAI;QACnB;MACF;MACA,IAAI,CAACA,UAAU,EAAE;QACfD,aAAa,CAACE,IAAI,CAACR,KAAK,CAACE,KAAK,CAAC;QAC/B,IAAI,CAACZ,GAAG,CAACmB,MAAM,CAACT,KAAK,CAAC;MACxB;IACF;IACA,OAAOM,aAAa;EACtB;EAEAI,GAAGA,CAACrB,QAAkB;IACpB,KAAK,MAAMW,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,IAAIG,sBAAsB,CAACJ,QAAQ,EAAEW,KAAK,CAACC,GAAG,CAAC,EAAE;QAC/C,OAAOD,KAAK,CAACE,KAAK;MACpB;IACF;IACA,OAAOC,SAAS;EAClB;EAEAQ,GAAGA,CAACtB,QAAkB,EAAEuB,QAAmB;IACzC,KAAK,MAAMZ,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,IAAIG,sBAAsB,CAACJ,QAAQ,EAAEW,KAAK,CAACC,GAAG,CAAC,EAAE;QAC/CD,KAAK,CAACE,KAAK,GAAGU,QAAQ;QACtB;MACF;IACF;IACA,IAAI,CAACtB,GAAG,CAACuB,GAAG,CAAC;MAAEZ,GAAG,EAAEZ,QAAQ;MAAEa,KAAK,EAAEU;IAAQ,CAAE,CAAC;EAClD;EAEAH,MAAMA,CAACpB,QAAkB;IACvB,KAAK,MAAMW,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,IAAIG,sBAAsB,CAACJ,QAAQ,EAAEW,KAAK,CAACC,GAAG,CAAC,EAAE;QAC/C,IAAI,CAACX,GAAG,CAACmB,MAAM,CAACT,KAAK,CAAC;QACtB;MACF;IACF;EACF;EAEAc,GAAGA,CAACzB,QAAkB;IACpB,KAAK,MAAMW,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,IAAIG,sBAAsB,CAACJ,QAAQ,EAAEW,KAAK,CAACC,GAAG,CAAC,EAAE;QAC/C,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd;EAEAc,KAAKA,CAAA;IACH,IAAI,CAACzB,GAAG,CAACyB,KAAK,EAAE;EAClB;EAEA,CAACC,IAAIA,CAAA;IACH,KAAK,MAAMhB,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,MAAMU,KAAK,CAACC,GAAG;IACjB;EACF;EAEA,CAACgB,MAAMA,CAAA;IACL,KAAK,MAAMjB,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,MAAMU,KAAK,CAACE,KAAK;IACnB;EACF;EAEA,CAACgB,OAAOA,CAAA;IACN,KAAK,MAAMlB,KAAK,IAAI,IAAI,CAACV,GAAG,EAAE;MAC5B,MAAM,CAACU,KAAK,CAACC,GAAG,EAAED,KAAK,CAACE,KAAK,CAAC;IAChC;EACF;;AA9FFtC,OAAA,CAAA+B,WAAA,GAAAA,WAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}