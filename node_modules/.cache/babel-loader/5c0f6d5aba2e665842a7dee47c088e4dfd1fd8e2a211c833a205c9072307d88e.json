{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleExecutor = void 0;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst warnings_1 = require(\"../warnings\");\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\nconst task_1 = require(\"./task\");\nfunction noop() {}\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\nclass BundleExecutor {\n  _options;\n  _descriptor;\n  _tasks;\n  _timers;\n  _invocations;\n  _invocationId;\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  constructor(bundleOptions, bundleDescriptor) {\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n  schedule(apiCall, request, callback) {\n    const bundleId = (0, bundlingUtils_1.computeBundleId)(request, this._descriptor.requestDiscriminatorFields);\n    callback = callback || noop;\n    if (bundleId === undefined) {\n      (0, warnings_1.warn)('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + `Invoking immediately. Request: ${JSON.stringify(request)} ` + `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n      return apiCall(request, callback);\n    }\n    if (request[this._descriptor.bundledField] === undefined) {\n      (0, warnings_1.warn)('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` + `Invoking immediately. Request: ${JSON.stringify(request)}`);\n      return apiCall(request, callback);\n    }\n    if (!(bundleId in this._tasks)) {\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n    }\n    let task = this._tasks[bundleId];\n    callback.id = String(this._invocationId++);\n    this._invocations[callback.id] = bundleId;\n    const bundledField = request[this._descriptor.bundledField];\n    const elementCount = bundledField.length;\n    let requestBytes = 0;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    bundledField.forEach(obj => {\n      requestBytes += this._descriptor.byteLengthFunction(obj);\n    });\n    const countLimit = this._options.elementCountLimit || 0;\n    const byteLimit = this._options.requestByteLimit || 0;\n    if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n      let message;\n      if (countLimit > 0 && elementCount > countLimit) {\n        message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n      } else {\n        message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n      }\n      const error = new googleError_1.GoogleError(message);\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n      return {\n        cancel: noop\n      };\n    }\n    const existingCount = task.getElementCount();\n    const existingBytes = task.getRequestByteSize();\n    if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n      this._runNow(bundleId);\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      task = this._tasks[bundleId];\n    }\n    task.extend(bundledField, requestBytes, callback);\n    const ret = {\n      cancel() {\n        self._cancel(callback.id);\n      }\n    };\n    const countThreshold = this._options.elementCountThreshold || 0;\n    const sizeThreshold = this._options.requestByteThreshold || 0;\n    if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n      this._runNow(bundleId);\n      return ret;\n    }\n    if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n      this._timers[bundleId] = setTimeout(() => {\n        delete this._timers[bundleId];\n        this._runNow(bundleId);\n      }, this._options.delayThreshold);\n    }\n    return ret;\n  }\n  /**\n   * Clears scheduled timeout if it exists.\n   *\n   * @param {String} bundleId - the id for the task whose timeout needs to be\n   *   cleared.\n   * @private\n   */\n  _maybeClearTimeout(bundleId) {\n    if (bundleId in this._timers) {\n      const timerId = this._timers[bundleId];\n      delete this._timers[bundleId];\n      clearTimeout(timerId);\n    }\n  }\n  /**\n   * Cancels an event.\n   *\n   * @param {String} id - The id for the event in the task.\n   * @private\n   */\n  _cancel(id) {\n    if (!(id in this._invocations)) {\n      return;\n    }\n    const bundleId = this._invocations[id];\n    if (!(bundleId in this._tasks)) {\n      return;\n    }\n    const task = this._tasks[bundleId];\n    delete this._invocations[id];\n    if (task.cancel(id)) {\n      this._maybeClearTimeout(bundleId);\n      delete this._tasks[bundleId];\n    }\n  }\n  /**\n   * Invokes a task.\n   *\n   * @param {String} bundleId - The id for the task.\n   * @private\n   */\n  _runNow(bundleId) {\n    if (!(bundleId in this._tasks)) {\n      (0, warnings_1.warn)('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n      return;\n    }\n    this._maybeClearTimeout(bundleId);\n    const task = this._tasks[bundleId];\n    delete this._tasks[bundleId];\n    task.run().forEach(id => {\n      delete this._invocations[id];\n    });\n  }\n}\nexports.BundleExecutor = BundleExecutor;","map":{"version":3,"names":["Object","defineProperty","exports","value","BundleExecutor","status_1","require","googleError_1","warnings_1","bundlingUtils_1","task_1","noop","_options","_descriptor","_tasks","_timers","_invocations","_invocationId","constructor","bundleOptions","bundleDescriptor","schedule","apiCall","request","callback","bundleId","computeBundleId","requestDiscriminatorFields","undefined","warn","JSON","stringify","bundledField","Task","subresponseField","task","id","String","elementCount","length","requestBytes","self","forEach","obj","byteLengthFunction","countLimit","elementCountLimit","byteLimit","requestByteLimit","message","error","GoogleError","code","Status","INVALID_ARGUMENT","cancel","existingCount","getElementCount","existingBytes","getRequestByteSize","_runNow","extend","ret","_cancel","countThreshold","elementCountThreshold","sizeThreshold","requestByteThreshold","delayThreshold","setTimeout","_maybeClearTimeout","timerId","clearTimeout","run"],"sources":["C:/Users/BIT/chatboot/node_modules/google-gax/build/src/bundlingCalls/bundleExecutor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BundleExecutor = void 0;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst warnings_1 = require(\"../warnings\");\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\nconst task_1 = require(\"./task\");\nfunction noop() { }\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\nclass BundleExecutor {\n    _options;\n    _descriptor;\n    _tasks;\n    _timers;\n    _invocations;\n    _invocationId;\n    /**\n     * Organizes requests for an api service that requires to bundle them.\n     *\n     * @param {BundleOptions} bundleOptions - configures strategy this instance\n     *   uses when executing bundled functions.\n     * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n     * @constructor\n     */\n    constructor(bundleOptions, bundleDescriptor) {\n        this._options = bundleOptions;\n        this._descriptor = bundleDescriptor;\n        this._tasks = {};\n        this._timers = {};\n        this._invocations = {};\n        this._invocationId = 0;\n    }\n    /**\n     * Schedule a method call.\n     *\n     * @param {function} apiCall - the function for an API call.\n     * @param {Object} request - the request object to be bundled with others.\n     * @param {APICallback} callback - the callback to be called when the method finished.\n     * @return {function()} - the function to cancel the scheduled invocation.\n     */\n    schedule(apiCall, request, callback) {\n        const bundleId = (0, bundlingUtils_1.computeBundleId)(request, this._descriptor.requestDiscriminatorFields);\n        callback = (callback || noop);\n        if (bundleId === undefined) {\n            (0, warnings_1.warn)('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' +\n                `Invoking immediately. Request: ${JSON.stringify(request)} ` +\n                `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n            return apiCall(request, callback);\n        }\n        if (request[this._descriptor.bundledField] === undefined) {\n            (0, warnings_1.warn)('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` +\n                `Invoking immediately. Request: ${JSON.stringify(request)}`);\n            return apiCall(request, callback);\n        }\n        if (!(bundleId in this._tasks)) {\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n        }\n        let task = this._tasks[bundleId];\n        callback.id = String(this._invocationId++);\n        this._invocations[callback.id] = bundleId;\n        const bundledField = request[this._descriptor.bundledField];\n        const elementCount = bundledField.length;\n        let requestBytes = 0;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        bundledField.forEach(obj => {\n            requestBytes += this._descriptor.byteLengthFunction(obj);\n        });\n        const countLimit = this._options.elementCountLimit || 0;\n        const byteLimit = this._options.requestByteLimit || 0;\n        if ((countLimit > 0 && elementCount > countLimit) ||\n            (byteLimit > 0 && requestBytes >= byteLimit)) {\n            let message;\n            if (countLimit > 0 && elementCount > countLimit) {\n                message =\n                    'The number of elements ' +\n                        elementCount +\n                        ' exceeds the limit ' +\n                        this._options.elementCountLimit;\n            }\n            else {\n                message =\n                    'The required bytes ' +\n                        requestBytes +\n                        ' exceeds the limit ' +\n                        this._options.requestByteLimit;\n            }\n            const error = new googleError_1.GoogleError(message);\n            error.code = status_1.Status.INVALID_ARGUMENT;\n            callback(error);\n            return {\n                cancel: noop,\n            };\n        }\n        const existingCount = task.getElementCount();\n        const existingBytes = task.getRequestByteSize();\n        if ((countLimit > 0 && elementCount + existingCount >= countLimit) ||\n            (byteLimit > 0 && requestBytes + existingBytes >= byteLimit)) {\n            this._runNow(bundleId);\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n            task = this._tasks[bundleId];\n        }\n        task.extend(bundledField, requestBytes, callback);\n        const ret = {\n            cancel() {\n                self._cancel(callback.id);\n            },\n        };\n        const countThreshold = this._options.elementCountThreshold || 0;\n        const sizeThreshold = this._options.requestByteThreshold || 0;\n        if ((countThreshold > 0 && task.getElementCount() >= countThreshold) ||\n            (sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold)) {\n            this._runNow(bundleId);\n            return ret;\n        }\n        if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n            this._timers[bundleId] = setTimeout(() => {\n                delete this._timers[bundleId];\n                this._runNow(bundleId);\n            }, this._options.delayThreshold);\n        }\n        return ret;\n    }\n    /**\n     * Clears scheduled timeout if it exists.\n     *\n     * @param {String} bundleId - the id for the task whose timeout needs to be\n     *   cleared.\n     * @private\n     */\n    _maybeClearTimeout(bundleId) {\n        if (bundleId in this._timers) {\n            const timerId = this._timers[bundleId];\n            delete this._timers[bundleId];\n            clearTimeout(timerId);\n        }\n    }\n    /**\n     * Cancels an event.\n     *\n     * @param {String} id - The id for the event in the task.\n     * @private\n     */\n    _cancel(id) {\n        if (!(id in this._invocations)) {\n            return;\n        }\n        const bundleId = this._invocations[id];\n        if (!(bundleId in this._tasks)) {\n            return;\n        }\n        const task = this._tasks[bundleId];\n        delete this._invocations[id];\n        if (task.cancel(id)) {\n            this._maybeClearTimeout(bundleId);\n            delete this._tasks[bundleId];\n        }\n    }\n    /**\n     * Invokes a task.\n     *\n     * @param {String} bundleId - The id for the task.\n     * @private\n     */\n    _runNow(bundleId) {\n        if (!(bundleId in this._tasks)) {\n            (0, warnings_1.warn)('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n            return;\n        }\n        this._maybeClearTimeout(bundleId);\n        const task = this._tasks[bundleId];\n        delete this._tasks[bundleId];\n        task.run().forEach(id => {\n            delete this._invocations[id];\n        });\n    }\n}\nexports.BundleExecutor = BundleExecutor;\n//# sourceMappingURL=bundleExecutor.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}