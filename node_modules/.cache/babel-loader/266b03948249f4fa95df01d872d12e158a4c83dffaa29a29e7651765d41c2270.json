{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseCIDR = parseCIDR;\nexports.mapProxyName = mapProxyName;\nexports.getProxiedConnection = getProxiedConnection;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst net_1 = require(\"net\");\nconst http = require(\"http\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst url_1 = require(\"url\");\nconst resolver_dns_1 = require(\"./resolver-dns\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl;\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n  let userCred = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result = {\n    address: `${hostname}:${port}`\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n/*\n * The groups correspond to CIDR parts as follows:\n * 1. ip\n * 2. prefixLength\n */\nfunction parseCIDR(cidrString) {\n  const splitRange = cidrString.split('/');\n  if (splitRange.length !== 2) {\n    return null;\n  }\n  const prefixLength = parseInt(splitRange[1], 10);\n  if (!(0, net_1.isIPv4)(splitRange[0]) || Number.isNaN(prefixLength) || prefixLength < 0 || prefixLength > 32) {\n    return null;\n  }\n  return {\n    ip: ipToInt(splitRange[0]),\n    prefixLength: prefixLength\n  };\n}\nfunction ipToInt(ip) {\n  return ip.split(\".\").reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0);\n}\nfunction isIpInCIDR(cidr, serverHost) {\n  const ip = cidr.ip;\n  const mask = -1 << 32 - cidr.prefixLength;\n  const hostIP = ipToInt(serverHost);\n  return (hostIP & mask) === (ip & mask);\n}\nfunction hostMatchesNoProxyList(serverHost) {\n  for (const host of getNoProxyHostList()) {\n    const parsedCIDR = parseCIDR(host);\n    // host is a CIDR and serverHost is an IP address\n    if ((0, net_1.isIPv4)(serverHost) && parsedCIDR && isIpInCIDR(parsedCIDR, serverHost)) {\n      return true;\n    } else if (serverHost.endsWith(host)) {\n      // host is a single IP or a domain name suffix\n      return true;\n    }\n  }\n  return false;\n}\nfunction mapProxyName(target, options) {\n  var _a;\n  const noProxyResult = {\n    target: target,\n    extraOptions: {}\n  };\n  if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  if (hostMatchesNoProxyList(serverHost)) {\n    trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\n    return noProxyResult;\n  }\n  const extraOptions = {\n    'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target)\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address\n    },\n    extraOptions: extraOptions\n  };\n}\nfunction getProxiedConnection(address, channelOptions) {\n  var _a;\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve(null);\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'];\n  const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve(null);\n  }\n  const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n  if (splitHostPost === null) {\n    return Promise.resolve(null);\n  }\n  const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n  const options = {\n    method: 'CONNECT',\n    path: hostPort\n  };\n  const headers = {\n    Host: hostPort\n  };\n  // Connect to the subchannel address as a proxy\n  if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n  }\n  options.headers = headers;\n  const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace('Successfully connected to ' + options.path + ' through proxy ' + proxyAddressString);\n        // The HTTP client may have already read a few bytes of the proxied\n        // connection. If that's the case, put them back into the socket.\n        // See https://github.com/grpc/grpc-node/issues/2744.\n        if (head.length > 0) {\n          socket.unshift(head);\n        }\n        trace('Successfully established a plaintext connection to ' + options.path + ' through proxy ' + proxyAddressString);\n        resolve(socket);\n      } else {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' + options.path + ' through proxy ' + proxyAddressString + ' with status ' + res.statusCode);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' + proxyAddressString + ' with error ' + err.message);\n      reject();\n    });\n    request.end();\n  });\n}","map":{"version":3,"names":["exports","parseCIDR","mapProxyName","getProxiedConnection","logging_1","require","constants_1","net_1","http","logging","subchannel_address_1","uri_parser_1","url_1","resolver_dns_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","getProxyInfo","proxyEnv","envVar","process","env","grpc_proxy","https_proxy","http_proxy","proxyUrl","URL","e","log","ERROR","protocol","userCred","username","password","INFO","decodeURIComponent","hostname","port","result","address","creds","getNoProxyHostList","noProxyStr","no_grpc_proxy","no_proxy","split","cidrString","splitRange","length","prefixLength","parseInt","isIPv4","Number","isNaN","ip","ipToInt","reduce","acc","octet","isIpInCIDR","cidr","serverHost","mask","hostIP","hostMatchesNoProxyList","host","parsedCIDR","endsWith","target","options","noProxyResult","extraOptions","_a","scheme","proxyInfo","hostPort","splitHostPort","path","uriToString","channelOptions","Promise","resolve","realTarget","parsedTarget","parseUri","splitHostPost","DEFAULT_PORT","method","headers","Host","isTcpSubchannelAddress","socketPath","Buffer","from","toString","proxyAddressString","subchannelAddressToString","reject","request","once","res","socket","head","removeAllListeners","statusCode","unshift","err","message","end"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\http_proxy.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nimport { isIPv4, Socket } from 'net';\nimport * as http from 'http';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { URL } from 'url';\nimport { DEFAULT_PORT } from './resolver-dns';\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface ProxyInfo {\n  address?: string;\n  creds?: string;\n}\n\nfunction getProxyInfo(): ProxyInfo {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl: URL;\n  try {\n    proxyUrl = new URL(proxyEnv);\n  } catch (e) {\n    log(LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    log(\n      LogVerbosity.ERROR,\n      `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`\n    );\n    return {};\n  }\n  let userCred: string | null = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      log(LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result: ProxyInfo = {\n    address: `${hostname}:${port}`,\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace(\n    'Proxy server ' + result.address + ' set by environment variable ' + envVar\n  );\n  return result;\n}\n\nfunction getNoProxyHostList(): string[] {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr: string | undefined = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\ninterface CIDRNotation {\n  ip: number;\n  prefixLength: number;\n}\n\n/*\n * The groups correspond to CIDR parts as follows:\n * 1. ip\n * 2. prefixLength\n */\n\nexport function parseCIDR(cidrString: string): CIDRNotation | null {\n  const splitRange = cidrString.split('/');  \n  if (splitRange.length !== 2) {  \n    return null;  \n  }  \n  const prefixLength = parseInt(splitRange[1], 10);  \n  if (!isIPv4(splitRange[0]) || Number.isNaN(prefixLength) || prefixLength < 0 || prefixLength > 32) {  \n    return null;  \n  }  \n  return {  \n    ip: ipToInt(splitRange[0]),  \n    prefixLength: prefixLength  \n  };\n}\n\nfunction ipToInt(ip: string) {\n  return ip.split(\".\").reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0);\n}\n\nfunction isIpInCIDR(cidr: CIDRNotation, serverHost: string) {\n  const ip = cidr.ip;\n  const mask = -1 << (32 - cidr.prefixLength);\n  const hostIP = ipToInt(serverHost);\n\n  return (hostIP & mask) === (ip & mask);\n}\n\nfunction hostMatchesNoProxyList(serverHost: string): boolean {\n  for (const host of getNoProxyHostList()) {\n    const parsedCIDR = parseCIDR(host);\n    // host is a CIDR and serverHost is an IP address\n    if (isIPv4(serverHost) && parsedCIDR && isIpInCIDR(parsedCIDR, serverHost)) {\n      return true;\n    } else if (serverHost.endsWith(host)) {\n      // host is a single IP or a domain name suffix\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface ProxyMapResult {\n  target: GrpcUri;\n  extraOptions: ChannelOptions;\n}\n\nexport function mapProxyName(\n  target: GrpcUri,\n  options: ChannelOptions\n): ProxyMapResult {\n  const noProxyResult: ProxyMapResult = {\n    target: target,\n    extraOptions: {},\n  };\n  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = splitHostPort(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  if (hostMatchesNoProxyList(serverHost)) {\n    trace('Not using proxy for target in no_proxy list: ' + uriToString(target));\n    return noProxyResult;\n  }\n  const extraOptions: ChannelOptions = {\n    'grpc.http_connect_target': uriToString(target),\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address,\n    },\n    extraOptions: extraOptions,\n  };\n}\n\nexport function getProxiedConnection(\n  address: SubchannelAddress,\n  channelOptions: ChannelOptions\n): Promise<Socket | null> {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve(null);\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'] as string;\n  const parsedTarget = parseUri(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve(null);\n  }\n  const splitHostPost = splitHostPort(parsedTarget.path);\n  if (splitHostPost === null) {\n    return Promise.resolve(null);\n  }\n  const hostPort = `${splitHostPost.host}:${\n    splitHostPost.port ?? DEFAULT_PORT\n  }`;\n  const options: http.RequestOptions = {\n    method: 'CONNECT',\n    path: hostPort,\n  };\n  const headers: http.OutgoingHttpHeaders = {\n    Host: hostPort,\n  };\n  // Connect to the subchannel address as a proxy\n  if (isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] =\n      'Basic ' +\n      Buffer.from(channelOptions['grpc.http_connect_creds'] as string).toString(\n        'base64'\n      );\n  }\n  options.headers = headers;\n  const proxyAddressString = subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise<Socket | null>((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace(\n          'Successfully connected to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString\n        );\n        // The HTTP client may have already read a few bytes of the proxied\n        // connection. If that's the case, put them back into the socket.\n        // See https://github.com/grpc/grpc-node/issues/2744.\n        if (head.length > 0) {\n          socket.unshift(head);\n        }\n        trace(\n          'Successfully established a plaintext connection to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString\n        );\n        resolve(socket);\n      } else {\n        log(\n          LogVerbosity.ERROR,\n          'Failed to connect to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString +\n            ' with status ' +\n            res.statusCode\n        );\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      log(\n        LogVerbosity.ERROR,\n        'Failed to connect to proxy ' +\n          proxyAddressString +\n          ' with error ' +\n          err.message\n      );\n      reject();\n    });\n    request.end();\n  });\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;AAoIAA,OAAA,CAAAC,SAAA,GAAAA,SAAA;AA8CAD,OAAA,CAAAE,YAAA,GAAAA,YAAA;AA0CAF,OAAA,CAAAG,oBAAA,GAAAA,oBAAA;AA3MA,MAAAC,SAAA,GAAAC,OAAA;AACA,MAAAC,WAAA,GAAAD,OAAA;AACA,MAAAE,KAAA,GAAAF,OAAA;AACA,MAAAG,IAAA,GAAAH,OAAA;AACA,MAAAI,OAAA,GAAAJ,OAAA;AACA,MAAAK,oBAAA,GAAAL,OAAA;AAMA,MAAAM,YAAA,GAAAN,OAAA;AACA,MAAAO,KAAA,GAAAP,OAAA;AACA,MAAAQ,cAAA,GAAAR,OAAA;AAEA,MAAMS,WAAW,GAAG,OAAO;AAE3B,SAASC,KAAKA,CAACC,IAAY;EACzBP,OAAO,CAACM,KAAK,CAACT,WAAA,CAAAW,YAAY,CAACC,KAAK,EAAEJ,WAAW,EAAEE,IAAI,CAAC;AACtD;AAOA,SAASG,YAAYA,CAAA;EACnB,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,MAAM,GAAG,EAAE;EACf;;;;EAIA,IAAIC,OAAO,CAACC,GAAG,CAACC,UAAU,EAAE;IAC1BH,MAAM,GAAG,YAAY;IACrBD,QAAQ,GAAGE,OAAO,CAACC,GAAG,CAACC,UAAU;EACnC,CAAC,MAAM,IAAIF,OAAO,CAACC,GAAG,CAACE,WAAW,EAAE;IAClCJ,MAAM,GAAG,aAAa;IACtBD,QAAQ,GAAGE,OAAO,CAACC,GAAG,CAACE,WAAW;EACpC,CAAC,MAAM,IAAIH,OAAO,CAACC,GAAG,CAACG,UAAU,EAAE;IACjCL,MAAM,GAAG,YAAY;IACrBD,QAAQ,GAAGE,OAAO,CAACC,GAAG,CAACG,UAAU;EACnC,CAAC,MAAM;IACL,OAAO,EAAE;EACX;EACA,IAAIC,QAAa;EACjB,IAAI;IACFA,QAAQ,GAAG,IAAIf,KAAA,CAAAgB,GAAG,CAACR,QAAQ,CAAC;EAC9B,CAAC,CAAC,OAAOS,CAAC,EAAE;IACV,IAAAzB,SAAA,CAAA0B,GAAG,EAACxB,WAAA,CAAAW,YAAY,CAACc,KAAK,EAAE,0BAA0BV,MAAM,WAAW,CAAC;IACpE,OAAO,EAAE;EACX;EACA,IAAIM,QAAQ,CAACK,QAAQ,KAAK,OAAO,EAAE;IACjC,IAAA5B,SAAA,CAAA0B,GAAG,EACDxB,WAAA,CAAAW,YAAY,CAACc,KAAK,EAClB,IAAIJ,QAAQ,CAACK,QAAQ,qCAAqC,CAC3D;IACD,OAAO,EAAE;EACX;EACA,IAAIC,QAAQ,GAAkB,IAAI;EAClC,IAAIN,QAAQ,CAACO,QAAQ,EAAE;IACrB,IAAIP,QAAQ,CAACQ,QAAQ,EAAE;MACrB,IAAA/B,SAAA,CAAA0B,GAAG,EAACxB,WAAA,CAAAW,YAAY,CAACmB,IAAI,EAAE,6BAA6B,CAAC;MACrDH,QAAQ,GAAGI,kBAAkB,CAAC,GAAGV,QAAQ,CAACO,QAAQ,IAAIP,QAAQ,CAACQ,QAAQ,EAAE,CAAC;IAC5E,CAAC,MAAM;MACLF,QAAQ,GAAGN,QAAQ,CAACO,QAAQ;IAC9B;EACF;EACA,MAAMI,QAAQ,GAAGX,QAAQ,CAACW,QAAQ;EAClC,IAAIC,IAAI,GAAGZ,QAAQ,CAACY,IAAI;EACxB;;;EAGA,IAAIA,IAAI,KAAK,EAAE,EAAE;IACfA,IAAI,GAAG,IAAI;EACb;EACA,MAAMC,MAAM,GAAc;IACxBC,OAAO,EAAE,GAAGH,QAAQ,IAAIC,IAAI;GAC7B;EACD,IAAIN,QAAQ,EAAE;IACZO,MAAM,CAACE,KAAK,GAAGT,QAAQ;EACzB;EACAlB,KAAK,CACH,eAAe,GAAGyB,MAAM,CAACC,OAAO,GAAG,+BAA+B,GAAGpB,MAAM,CAC5E;EACD,OAAOmB,MAAM;AACf;AAEA,SAASG,kBAAkBA,CAAA;EACzB;EACA,IAAIC,UAAU,GAAuBtB,OAAO,CAACC,GAAG,CAACsB,aAAa;EAC9D,IAAIxB,MAAM,GAAG,eAAe;EAC5B,IAAI,CAACuB,UAAU,EAAE;IACfA,UAAU,GAAGtB,OAAO,CAACC,GAAG,CAACuB,QAAQ;IACjCzB,MAAM,GAAG,UAAU;EACrB;EACA,IAAIuB,UAAU,EAAE;IACd7B,KAAK,CAAC,mDAAmD,GAAGM,MAAM,CAAC;IACnE,OAAOuB,UAAU,CAACG,KAAK,CAAC,GAAG,CAAC;EAC9B,CAAC,MAAM;IACL,OAAO,EAAE;EACX;AACF;AAOA;;;;;AAMA,SAAgB9C,SAASA,CAAC+C,UAAkB;EAC1C,MAAMC,UAAU,GAAGD,UAAU,CAACD,KAAK,CAAC,GAAG,CAAC;EACxC,IAAIE,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE;IAC3B,OAAO,IAAI;EACb;EACA,MAAMC,YAAY,GAAGC,QAAQ,CAACH,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAChD,IAAI,CAAC,IAAA1C,KAAA,CAAA8C,MAAM,EAACJ,UAAU,CAAC,CAAC,CAAC,CAAC,IAAIK,MAAM,CAACC,KAAK,CAACJ,YAAY,CAAC,IAAIA,YAAY,GAAG,CAAC,IAAIA,YAAY,GAAG,EAAE,EAAE;IACjG,OAAO,IAAI;EACb;EACA,OAAO;IACLK,EAAE,EAAEC,OAAO,CAACR,UAAU,CAAC,CAAC,CAAC,CAAC;IAC1BE,YAAY,EAAEA;GACf;AACH;AAEA,SAASM,OAAOA,CAACD,EAAU;EACzB,OAAOA,EAAE,CAACT,KAAK,CAAC,GAAG,CAAC,CAACW,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAK,CAACD,GAAG,IAAI,CAAC,IAAIP,QAAQ,CAACQ,KAAK,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;AAClF;AAEA,SAASC,UAAUA,CAACC,IAAkB,EAAEC,UAAkB;EACxD,MAAMP,EAAE,GAAGM,IAAI,CAACN,EAAE;EAClB,MAAMQ,IAAI,GAAG,CAAC,CAAC,IAAK,EAAE,GAAGF,IAAI,CAACX,YAAa;EAC3C,MAAMc,MAAM,GAAGR,OAAO,CAACM,UAAU,CAAC;EAElC,OAAO,CAACE,MAAM,GAAGD,IAAI,OAAOR,EAAE,GAAGQ,IAAI,CAAC;AACxC;AAEA,SAASE,sBAAsBA,CAACH,UAAkB;EAChD,KAAK,MAAMI,IAAI,IAAIxB,kBAAkB,EAAE,EAAE;IACvC,MAAMyB,UAAU,GAAGnE,SAAS,CAACkE,IAAI,CAAC;IAClC;IACA,IAAI,IAAA5D,KAAA,CAAA8C,MAAM,EAACU,UAAU,CAAC,IAAIK,UAAU,IAAIP,UAAU,CAACO,UAAU,EAAEL,UAAU,CAAC,EAAE;MAC1E,OAAO,IAAI;IACb,CAAC,MAAM,IAAIA,UAAU,CAACM,QAAQ,CAACF,IAAI,CAAC,EAAE;MACpC;MACA,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AAOA,SAAgBjE,YAAYA,CAC1BoE,MAAe,EACfC,OAAuB;;EAEvB,MAAMC,aAAa,GAAmB;IACpCF,MAAM,EAAEA,MAAM;IACdG,YAAY,EAAE;GACf;EACD,IAAI,CAAC,CAAAC,EAAA,GAAAH,OAAO,CAAC,wBAAwB,CAAC,cAAAG,EAAA,cAAAA,EAAA,GAAI,CAAC,MAAM,CAAC,EAAE;IAClD,OAAOF,aAAa;EACtB;EACA,IAAIF,MAAM,CAACK,MAAM,KAAK,MAAM,EAAE;IAC5B,OAAOH,aAAa;EACtB;EACA,MAAMI,SAAS,GAAGzD,YAAY,EAAE;EAChC,IAAI,CAACyD,SAAS,CAACnC,OAAO,EAAE;IACtB,OAAO+B,aAAa;EACtB;EACA,MAAMK,QAAQ,GAAG,IAAAlE,YAAA,CAAAmE,aAAa,EAACR,MAAM,CAACS,IAAI,CAAC;EAC3C,IAAI,CAACF,QAAQ,EAAE;IACb,OAAOL,aAAa;EACtB;EACA,MAAMT,UAAU,GAAGc,QAAQ,CAACV,IAAI;EAChC,IAAID,sBAAsB,CAACH,UAAU,CAAC,EAAE;IACtChD,KAAK,CAAC,+CAA+C,GAAG,IAAAJ,YAAA,CAAAqE,WAAW,EAACV,MAAM,CAAC,CAAC;IAC5E,OAAOE,aAAa;EACtB;EACA,MAAMC,YAAY,GAAmB;IACnC,0BAA0B,EAAE,IAAA9D,YAAA,CAAAqE,WAAW,EAACV,MAAM;GAC/C;EACD,IAAIM,SAAS,CAAClC,KAAK,EAAE;IACnB+B,YAAY,CAAC,yBAAyB,CAAC,GAAGG,SAAS,CAAClC,KAAK;EAC3D;EACA,OAAO;IACL4B,MAAM,EAAE;MACNK,MAAM,EAAE,KAAK;MACbI,IAAI,EAAEH,SAAS,CAACnC;KACjB;IACDgC,YAAY,EAAEA;GACf;AACH;AAEA,SAAgBtE,oBAAoBA,CAClCsC,OAA0B,EAC1BwC,cAA8B;;EAE9B,IAAI,EAAE,0BAA0B,IAAIA,cAAc,CAAC,EAAE;IACnD,OAAOC,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;EAC9B;EACA,MAAMC,UAAU,GAAGH,cAAc,CAAC,0BAA0B,CAAW;EACvE,MAAMI,YAAY,GAAG,IAAA1E,YAAA,CAAA2E,QAAQ,EAACF,UAAU,CAAC;EACzC,IAAIC,YAAY,KAAK,IAAI,EAAE;IACzB,OAAOH,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;EAC9B;EACA,MAAMI,aAAa,GAAG,IAAA5E,YAAA,CAAAmE,aAAa,EAACO,YAAY,CAACN,IAAI,CAAC;EACtD,IAAIQ,aAAa,KAAK,IAAI,EAAE;IAC1B,OAAOL,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;EAC9B;EACA,MAAMN,QAAQ,GAAG,GAAGU,aAAa,CAACpB,IAAI,IACpC,CAAAO,EAAA,GAAAa,aAAa,CAAChD,IAAI,cAAAmC,EAAA,cAAAA,EAAA,GAAI7D,cAAA,CAAA2E,YACxB,EAAE;EACF,MAAMjB,OAAO,GAAwB;IACnCkB,MAAM,EAAE,SAAS;IACjBV,IAAI,EAAEF;GACP;EACD,MAAMa,OAAO,GAA6B;IACxCC,IAAI,EAAEd;GACP;EACD;EACA,IAAI,IAAAnE,oBAAA,CAAAkF,sBAAsB,EAACnD,OAAO,CAAC,EAAE;IACnC8B,OAAO,CAACJ,IAAI,GAAG1B,OAAO,CAAC0B,IAAI;IAC3BI,OAAO,CAAChC,IAAI,GAAGE,OAAO,CAACF,IAAI;EAC7B,CAAC,MAAM;IACLgC,OAAO,CAACsB,UAAU,GAAGpD,OAAO,CAACsC,IAAI;EACnC;EACA,IAAI,yBAAyB,IAAIE,cAAc,EAAE;IAC/CS,OAAO,CAAC,qBAAqB,CAAC,GAC5B,QAAQ,GACRI,MAAM,CAACC,IAAI,CAACd,cAAc,CAAC,yBAAyB,CAAW,CAAC,CAACe,QAAQ,CACvE,QAAQ,CACT;EACL;EACAzB,OAAO,CAACmB,OAAO,GAAGA,OAAO;EACzB,MAAMO,kBAAkB,GAAG,IAAAvF,oBAAA,CAAAwF,yBAAyB,EAACzD,OAAO,CAAC;EAC7D1B,KAAK,CAAC,cAAc,GAAGkF,kBAAkB,GAAG,iBAAiB,GAAG1B,OAAO,CAACQ,IAAI,CAAC;EAC7E,OAAO,IAAIG,OAAO,CAAgB,CAACC,OAAO,EAAEgB,MAAM,KAAI;IACpD,MAAMC,OAAO,GAAG5F,IAAI,CAAC4F,OAAO,CAAC7B,OAAO,CAAC;IACrC6B,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE,CAACC,GAAG,EAAEC,MAAM,EAAEC,IAAI,KAAI;MAC5CJ,OAAO,CAACK,kBAAkB,EAAE;MAC5BF,MAAM,CAACE,kBAAkB,EAAE;MAC3B,IAAIH,GAAG,CAACI,UAAU,KAAK,GAAG,EAAE;QAC1B3F,KAAK,CACH,4BAA4B,GAC1BwD,OAAO,CAACQ,IAAI,GACZ,iBAAiB,GACjBkB,kBAAkB,CACrB;QACD;QACA;QACA;QACA,IAAIO,IAAI,CAACtD,MAAM,GAAG,CAAC,EAAE;UACnBqD,MAAM,CAACI,OAAO,CAACH,IAAI,CAAC;QACtB;QACAzF,KAAK,CACH,qDAAqD,GACnDwD,OAAO,CAACQ,IAAI,GACZ,iBAAiB,GACjBkB,kBAAkB,CACrB;QACDd,OAAO,CAACoB,MAAM,CAAC;MACjB,CAAC,MAAM;QACL,IAAAnG,SAAA,CAAA0B,GAAG,EACDxB,WAAA,CAAAW,YAAY,CAACc,KAAK,EAClB,uBAAuB,GACrBwC,OAAO,CAACQ,IAAI,GACZ,iBAAiB,GACjBkB,kBAAkB,GAClB,eAAe,GACfK,GAAG,CAACI,UAAU,CACjB;QACDP,MAAM,EAAE;MACV;IACF,CAAC,CAAC;IACFC,OAAO,CAACC,IAAI,CAAC,OAAO,EAAEO,GAAG,IAAG;MAC1BR,OAAO,CAACK,kBAAkB,EAAE;MAC5B,IAAArG,SAAA,CAAA0B,GAAG,EACDxB,WAAA,CAAAW,YAAY,CAACc,KAAK,EAClB,6BAA6B,GAC3BkE,kBAAkB,GAClB,cAAc,GACdW,GAAG,CAACC,OAAO,CACd;MACDV,MAAM,EAAE;IACV,CAAC,CAAC;IACFC,OAAO,CAACU,GAAG,EAAE;EACf,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}