{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResolvingCall = void 0;\nconst call_credentials_1 = require(\"./call-credentials\");\nconst constants_1 = require(\"./constants\");\nconst deadline_1 = require(\"./deadline\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst control_plane_status_1 = require(\"./control-plane-status\");\nconst TRACER_NAME = 'resolving_call';\nclass ResolvingCall {\n  constructor(channel, method, options, filterStackFactory, callNumber) {\n    this.channel = channel;\n    this.method = method;\n    this.filterStackFactory = filterStackFactory;\n    this.callNumber = callNumber;\n    this.child = null;\n    this.readPending = false;\n    this.pendingMessage = null;\n    this.pendingHalfClose = false;\n    this.ended = false;\n    this.readFilterPending = false;\n    this.writeFilterPending = false;\n    this.pendingChildStatus = null;\n    this.metadata = null;\n    this.listener = null;\n    this.statusWatchers = [];\n    this.deadlineTimer = setTimeout(() => {}, 0);\n    this.filterStack = null;\n    this.deadlineStartTime = null;\n    this.configReceivedTime = null;\n    this.childStartTime = null;\n    /**\n     * Credentials configured for this specific call. Does not include\n     * call credentials associated with the channel credentials used to create\n     * the channel.\n     */\n    this.credentials = call_credentials_1.CallCredentials.createEmpty();\n    this.deadline = options.deadline;\n    this.host = options.host;\n    if (options.parentCall) {\n      if (options.flags & constants_1.Propagate.CANCELLATION) {\n        options.parentCall.on('cancelled', () => {\n          this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n        });\n      }\n      if (options.flags & constants_1.Propagate.DEADLINE) {\n        this.trace('Propagating deadline from parent: ' + options.parentCall.getDeadline());\n        this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n      }\n    }\n    this.trace('Created');\n    this.runDeadlineTimer();\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  runDeadlineTimer() {\n    clearTimeout(this.deadlineTimer);\n    this.deadlineStartTime = new Date();\n    this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));\n    const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n    if (timeout !== Infinity) {\n      this.trace('Deadline will be reached in ' + timeout + 'ms');\n      const handleDeadline = () => {\n        if (!this.deadlineStartTime) {\n          this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n          return;\n        }\n        const deadlineInfo = [];\n        const deadlineEndTime = new Date();\n        deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);\n        if (this.configReceivedTime) {\n          if (this.configReceivedTime > this.deadlineStartTime) {\n            deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);\n          }\n          if (this.childStartTime) {\n            if (this.childStartTime > this.configReceivedTime) {\n              deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);\n            }\n          } else {\n            deadlineInfo.push('waiting for metadata filters');\n          }\n        } else {\n          deadlineInfo.push('waiting for name resolution');\n        }\n        if (this.child) {\n          deadlineInfo.push(...this.child.getDeadlineInfo());\n        }\n        this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));\n      };\n      if (timeout <= 0) {\n        process.nextTick(handleDeadline);\n      } else {\n        this.deadlineTimer = setTimeout(handleDeadline, timeout);\n      }\n    }\n  }\n  outputStatus(status) {\n    if (!this.ended) {\n      this.ended = true;\n      if (!this.filterStack) {\n        this.filterStack = this.filterStackFactory.createFilter();\n      }\n      clearTimeout(this.deadlineTimer);\n      const filteredStatus = this.filterStack.receiveTrailers(status);\n      this.trace('ended with status: code=' + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      process.nextTick(() => {\n        var _a;\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n      });\n    }\n  }\n  sendMessageOnChild(context, message) {\n    if (!this.child) {\n      throw new Error('sendMessageonChild called with child not populated');\n    }\n    const child = this.child;\n    this.writeFilterPending = true;\n    this.filterStack.sendMessage(Promise.resolve({\n      message: message,\n      flags: context.flags\n    })).then(filteredMessage => {\n      this.writeFilterPending = false;\n      child.sendMessageWithContext(context, filteredMessage.message);\n      if (this.pendingHalfClose) {\n        child.halfClose();\n      }\n    }, status => {\n      this.cancelWithStatus(status.code, status.details);\n    });\n  }\n  getConfig() {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata || !this.listener) {\n      throw new Error('getConfig called before start');\n    }\n    const configResult = this.channel.getConfig(this.method, this.metadata);\n    if (configResult.type === 'NONE') {\n      this.channel.queueCallForConfig(this);\n      return;\n    } else if (configResult.type === 'ERROR') {\n      if (this.metadata.getOptions().waitForReady) {\n        this.channel.queueCallForConfig(this);\n      } else {\n        this.outputStatus(configResult.error);\n      }\n      return;\n    }\n    // configResult.type === 'SUCCESS'\n    this.configReceivedTime = new Date();\n    const config = configResult.config;\n    if (config.status !== constants_1.Status.OK) {\n      const {\n        code,\n        details\n      } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);\n      this.outputStatus({\n        code: code,\n        details: details,\n        metadata: new metadata_1.Metadata()\n      });\n      return;\n    }\n    if (config.methodConfig.timeout) {\n      const configDeadline = new Date();\n      configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n      configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1000000);\n      this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n      this.runDeadlineTimer();\n    }\n    this.filterStackFactory.push(config.dynamicFilterFactories);\n    this.filterStack = this.filterStackFactory.createFilter();\n    this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\n      this.child = this.channel.createRetryingCall(config, this.method, this.host, this.credentials, this.deadline);\n      this.trace('Created child [' + this.child.getCallNumber() + ']');\n      this.childStartTime = new Date();\n      this.child.start(filteredMetadata, {\n        onReceiveMetadata: metadata => {\n          this.trace('Received metadata');\n          this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n        },\n        onReceiveMessage: message => {\n          this.trace('Received message');\n          this.readFilterPending = true;\n          this.filterStack.receiveMessage(message).then(filteredMesssage => {\n            this.trace('Finished filtering received message');\n            this.readFilterPending = false;\n            this.listener.onReceiveMessage(filteredMesssage);\n            if (this.pendingChildStatus) {\n              this.outputStatus(this.pendingChildStatus);\n            }\n          }, status => {\n            this.cancelWithStatus(status.code, status.details);\n          });\n        },\n        onReceiveStatus: status => {\n          this.trace('Received status');\n          if (this.readFilterPending) {\n            this.pendingChildStatus = status;\n          } else {\n            this.outputStatus(status);\n          }\n        }\n      });\n      if (this.readPending) {\n        this.child.startRead();\n      }\n      if (this.pendingMessage) {\n        this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n      } else if (this.pendingHalfClose) {\n        this.child.halfClose();\n      }\n    }, status => {\n      this.outputStatus(status);\n    });\n  }\n  reportResolverError(status) {\n    var _a;\n    if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n      this.channel.queueCallForConfig(this);\n    } else {\n      this.outputStatus(status);\n    }\n  }\n  cancelWithStatus(status, details) {\n    var _a;\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n    this.outputStatus({\n      code: status,\n      details: details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.metadata = metadata.clone();\n    this.listener = listener;\n    this.getConfig();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.sendMessageOnChild(context, message);\n    } else {\n      this.pendingMessage = {\n        context,\n        message\n      };\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    if (this.child && !this.writeFilterPending) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials) {\n    this.credentials = credentials;\n  }\n  addStatusWatcher(watcher) {\n    this.statusWatchers.push(watcher);\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n}\nexports.ResolvingCall = ResolvingCall;","map":{"version":3,"names":["call_credentials_1","require","constants_1","deadline_1","metadata_1","logging","control_plane_status_1","TRACER_NAME","ResolvingCall","constructor","channel","method","options","filterStackFactory","callNumber","child","readPending","pendingMessage","pendingHalfClose","ended","readFilterPending","writeFilterPending","pendingChildStatus","metadata","listener","statusWatchers","deadlineTimer","setTimeout","filterStack","deadlineStartTime","configReceivedTime","childStartTime","credentials","CallCredentials","createEmpty","deadline","host","parentCall","flags","Propagate","CANCELLATION","on","cancelWithStatus","Status","CANCELLED","DEADLINE","trace","getDeadline","minDeadline","runDeadlineTimer","text","LogVerbosity","DEBUG","clearTimeout","Date","deadlineToString","timeout","getRelativeTimeout","Infinity","handleDeadline","DEADLINE_EXCEEDED","deadlineInfo","deadlineEndTime","push","formatDateDifference","getDeadlineInfo","join","process","nextTick","outputStatus","status","createFilter","filteredStatus","receiveTrailers","code","details","forEach","watcher","_a","onReceiveStatus","sendMessageOnChild","context","message","Error","sendMessage","Promise","resolve","then","filteredMessage","sendMessageWithContext","halfClose","getConfig","configResult","type","queueCallForConfig","getOptions","waitForReady","error","config","OK","restrictControlPlaneStatusCode","Metadata","methodConfig","configDeadline","setSeconds","getSeconds","seconds","setMilliseconds","getMilliseconds","nanos","dynamicFilterFactories","sendMetadata","filteredMetadata","createRetryingCall","getCallNumber","start","onReceiveMetadata","receiveMetadata","onReceiveMessage","receiveMessage","filteredMesssage","startRead","reportResolverError","getPeer","_b","getTarget","clone","length","setCredentials","addStatusWatcher","exports"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\resolving-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from './call-credentials';\nimport {\n  Call,\n  CallStreamOptions,\n  DeadlineInfoProvider,\n  InterceptingListener,\n  MessageContext,\n  StatusObject,\n} from './call-interface';\nimport { LogVerbosity, Propagate, Status } from './constants';\nimport {\n  Deadline,\n  deadlineToString,\n  formatDateDifference,\n  getRelativeTimeout,\n  minDeadline,\n} from './deadline';\nimport { FilterStack, FilterStackFactory } from './filter-stack';\nimport { InternalChannel } from './internal-channel';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { restrictControlPlaneStatusCode } from './control-plane-status';\n\nconst TRACER_NAME = 'resolving_call';\n\nexport class ResolvingCall implements Call {\n  private child: (Call & DeadlineInfoProvider) | null = null;\n  private readPending = false;\n  private pendingMessage: { context: MessageContext; message: Buffer } | null =\n    null;\n  private pendingHalfClose = false;\n  private ended = false;\n  private readFilterPending = false;\n  private writeFilterPending = false;\n  private pendingChildStatus: StatusObject | null = null;\n  private metadata: Metadata | null = null;\n  private listener: InterceptingListener | null = null;\n  private deadline: Deadline;\n  private host: string;\n  private statusWatchers: ((status: StatusObject) => void)[] = [];\n  private deadlineTimer: NodeJS.Timeout = setTimeout(() => {}, 0);\n  private filterStack: FilterStack | null = null;\n\n  private deadlineStartTime: Date | null = null;\n  private configReceivedTime: Date | null = null;\n  private childStartTime: Date | null = null;\n\n  /**\n   * Credentials configured for this specific call. Does not include\n   * call credentials associated with the channel credentials used to create\n   * the channel.\n   */\n  private credentials: CallCredentials = CallCredentials.createEmpty();\n\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly method: string,\n    options: CallStreamOptions,\n    private readonly filterStackFactory: FilterStackFactory,\n    private callNumber: number\n  ) {\n    this.deadline = options.deadline;\n    this.host = options.host;\n    if (options.parentCall) {\n      if (options.flags & Propagate.CANCELLATION) {\n        options.parentCall.on('cancelled', () => {\n          this.cancelWithStatus(Status.CANCELLED, 'Cancelled by parent call');\n        });\n      }\n      if (options.flags & Propagate.DEADLINE) {\n        this.trace(\n          'Propagating deadline from parent: ' +\n            options.parentCall.getDeadline()\n        );\n        this.deadline = minDeadline(\n          this.deadline,\n          options.parentCall.getDeadline()\n        );\n      }\n    }\n    this.trace('Created');\n    this.runDeadlineTimer();\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private runDeadlineTimer() {\n    clearTimeout(this.deadlineTimer);\n    this.deadlineStartTime = new Date();\n    this.trace('Deadline: ' + deadlineToString(this.deadline));\n    const timeout = getRelativeTimeout(this.deadline);\n    if (timeout !== Infinity) {\n      this.trace('Deadline will be reached in ' + timeout + 'ms');\n      const handleDeadline = () => {\n        if (!this.deadlineStartTime) {\n          this.cancelWithStatus(Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n          return;\n        }\n        const deadlineInfo: string[] = [];\n        const deadlineEndTime = new Date();\n        deadlineInfo.push(`Deadline exceeded after ${formatDateDifference(this.deadlineStartTime, deadlineEndTime)}`);\n        if (this.configReceivedTime) {\n          if (this.configReceivedTime > this.deadlineStartTime) {\n            deadlineInfo.push(`name resolution: ${formatDateDifference(this.deadlineStartTime, this.configReceivedTime)}`);\n          }\n          if (this.childStartTime) {\n            if (this.childStartTime > this.configReceivedTime) {\n              deadlineInfo.push(`metadata filters: ${formatDateDifference(this.configReceivedTime, this.childStartTime)}`);\n            }\n          } else {\n            deadlineInfo.push('waiting for metadata filters');\n          }\n        } else {\n          deadlineInfo.push('waiting for name resolution');\n        }\n        if (this.child) {\n          deadlineInfo.push(...this.child.getDeadlineInfo());\n        }\n        this.cancelWithStatus(Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));\n      };\n      if (timeout <= 0) {\n        process.nextTick(handleDeadline);\n      } else {\n        this.deadlineTimer = setTimeout(handleDeadline, timeout);\n      }\n    }\n  }\n\n  private outputStatus(status: StatusObject) {\n    if (!this.ended) {\n      this.ended = true;\n      if (!this.filterStack) {\n        this.filterStack = this.filterStackFactory.createFilter();\n      }\n      clearTimeout(this.deadlineTimer);\n      const filteredStatus = this.filterStack.receiveTrailers(status);\n      this.trace(\n        'ended with status: code=' +\n          filteredStatus.code +\n          ' details=\"' +\n          filteredStatus.details +\n          '\"'\n      );\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      process.nextTick(() => {\n        this.listener?.onReceiveStatus(filteredStatus);\n      });\n    }\n  }\n\n  private sendMessageOnChild(context: MessageContext, message: Buffer): void {\n    if (!this.child) {\n      throw new Error('sendMessageonChild called with child not populated');\n    }\n    const child = this.child;\n    this.writeFilterPending = true;\n    this.filterStack!.sendMessage(\n      Promise.resolve({ message: message, flags: context.flags })\n    ).then(\n      filteredMessage => {\n        this.writeFilterPending = false;\n        child.sendMessageWithContext(context, filteredMessage.message);\n        if (this.pendingHalfClose) {\n          child.halfClose();\n        }\n      },\n      (status: StatusObject) => {\n        this.cancelWithStatus(status.code, status.details);\n      }\n    );\n  }\n\n  getConfig(): void {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata || !this.listener) {\n      throw new Error('getConfig called before start');\n    }\n    const configResult = this.channel.getConfig(this.method, this.metadata);\n    if (configResult.type === 'NONE') {\n      this.channel.queueCallForConfig(this);\n      return;\n    } else if (configResult.type === 'ERROR') {\n      if (this.metadata.getOptions().waitForReady) {\n        this.channel.queueCallForConfig(this);\n      } else {\n        this.outputStatus(configResult.error);\n      }\n      return;\n    }\n    // configResult.type === 'SUCCESS'\n    this.configReceivedTime = new Date();\n    const config = configResult.config;\n    if (config.status !== Status.OK) {\n      const { code, details } = restrictControlPlaneStatusCode(\n        config.status,\n        'Failed to route call to method ' + this.method\n      );\n      this.outputStatus({\n        code: code,\n        details: details,\n        metadata: new Metadata(),\n      });\n      return;\n    }\n\n    if (config.methodConfig.timeout) {\n      const configDeadline = new Date();\n      configDeadline.setSeconds(\n        configDeadline.getSeconds() + config.methodConfig.timeout.seconds\n      );\n      configDeadline.setMilliseconds(\n        configDeadline.getMilliseconds() +\n          config.methodConfig.timeout.nanos / 1_000_000\n      );\n      this.deadline = minDeadline(this.deadline, configDeadline);\n      this.runDeadlineTimer();\n    }\n\n    this.filterStackFactory.push(config.dynamicFilterFactories);\n    this.filterStack = this.filterStackFactory.createFilter();\n    this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(\n      filteredMetadata => {\n        this.child = this.channel.createRetryingCall(\n          config,\n          this.method,\n          this.host,\n          this.credentials,\n          this.deadline\n        );\n        this.trace('Created child [' + this.child.getCallNumber() + ']');\n        this.childStartTime = new Date();\n        this.child.start(filteredMetadata, {\n          onReceiveMetadata: metadata => {\n            this.trace('Received metadata');\n            this.listener!.onReceiveMetadata(\n              this.filterStack!.receiveMetadata(metadata)\n            );\n          },\n          onReceiveMessage: message => {\n            this.trace('Received message');\n            this.readFilterPending = true;\n            this.filterStack!.receiveMessage(message).then(\n              filteredMesssage => {\n                this.trace('Finished filtering received message');\n                this.readFilterPending = false;\n                this.listener!.onReceiveMessage(filteredMesssage);\n                if (this.pendingChildStatus) {\n                  this.outputStatus(this.pendingChildStatus);\n                }\n              },\n              (status: StatusObject) => {\n                this.cancelWithStatus(status.code, status.details);\n              }\n            );\n          },\n          onReceiveStatus: status => {\n            this.trace('Received status');\n            if (this.readFilterPending) {\n              this.pendingChildStatus = status;\n            } else {\n              this.outputStatus(status);\n            }\n          },\n        });\n        if (this.readPending) {\n          this.child.startRead();\n        }\n        if (this.pendingMessage) {\n          this.sendMessageOnChild(\n            this.pendingMessage.context,\n            this.pendingMessage.message\n          );\n        } else if (this.pendingHalfClose) {\n          this.child.halfClose();\n        }\n      },\n      (status: StatusObject) => {\n        this.outputStatus(status);\n      }\n    );\n  }\n\n  reportResolverError(status: StatusObject) {\n    if (this.metadata?.getOptions().waitForReady) {\n      this.channel.queueCallForConfig(this);\n    } else {\n      this.outputStatus(status);\n    }\n  }\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.child?.cancelWithStatus(status, details);\n    this.outputStatus({\n      code: status,\n      details: details,\n      metadata: new Metadata(),\n    });\n  }\n  getPeer(): string {\n    return this.child?.getPeer() ?? this.channel.getTarget();\n  }\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.metadata = metadata.clone();\n    this.listener = listener;\n    this.getConfig();\n  }\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.sendMessageOnChild(context, message);\n    } else {\n      this.pendingMessage = { context, message };\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    if (this.child && !this.writeFilterPending) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.credentials = credentials;\n  }\n\n  addStatusWatcher(watcher: (status: StatusObject) => void) {\n    this.statusWatchers.push(watcher);\n  }\n\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}