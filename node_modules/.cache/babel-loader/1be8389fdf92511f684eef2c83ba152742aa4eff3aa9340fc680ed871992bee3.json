{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PageDescriptor = void 0;\nconst stream_1 = require(\"stream\");\nconst normalApiCaller_1 = require(\"../normalCalls/normalApiCaller\");\nconst warnings_1 = require(\".././warnings\");\nconst pagedApiCaller_1 = require(\"./pagedApiCaller\");\nconst maxAttemptsEmptyResponse = 10;\n/**\n * A descriptor for methods that support pagination.\n */\nclass PageDescriptor {\n  requestPageTokenField;\n  responsePageTokenField;\n  requestPageSizeField;\n  resourceField;\n  constructor(requestPageTokenField, responsePageTokenField, resourceField) {\n    this.requestPageTokenField = requestPageTokenField;\n    this.responsePageTokenField = responsePageTokenField;\n    this.resourceField = resourceField;\n  }\n  /**\n   * Creates a new object Stream which emits the resource on 'data' event.\n   */\n  createStream(apiCall, request, options) {\n    if (options?.autoPaginate) {\n      (0, warnings_1.warn)('autoPaginate true', 'Autopaginate will always be set to false in stream paging methods. See more info at https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination for more information on how to configure paging calls', 'AutopaginateTrueWarning');\n    }\n    const stream = new stream_1.PassThrough({\n      objectMode: true\n    });\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const maxResults = 'maxResults' in options ? options.maxResults : -1;\n    let pushCount = 0;\n    let started = false;\n    function callback(err, resources, next, apiResp) {\n      if (err) {\n        stream.emit('error', err);\n        return;\n      }\n      // emit full api response with every page.\n      stream.emit('response', apiResp);\n      for (let i = 0; i < resources.length; ++i) {\n        // TODO: rewrite without accessing stream internals\n        if (stream._readableState.ended) {\n          return;\n        }\n        if (resources[i] === null) {\n          continue;\n        }\n        stream.push(resources[i]);\n        pushCount++;\n        if (pushCount === maxResults) {\n          stream.end();\n        }\n      }\n      // TODO: rewrite without accessing stream internals\n      if (stream._readableState.ended) {\n        return;\n      }\n      if (!next) {\n        stream.end();\n        return;\n      }\n      // When pageToken is specified in the original options, it will overwrite\n      // the page token field in the next request. Therefore it must be cleared.\n      if ('pageToken' in options) {\n        delete options.pageToken;\n      }\n      if (stream.isPaused()) {\n        request = next;\n        started = false;\n      } else {\n        setImmediate(apiCall, next, options, callback);\n      }\n    }\n    stream.on('resume', async () => {\n      if (!started) {\n        started = true;\n        await apiCall(request, options, callback);\n      }\n    });\n    return stream;\n  }\n  /**\n   * Create an async iterable which can be recursively called for data on-demand.\n   */\n  asyncIterate(apiCall, request, options) {\n    if (options?.autoPaginate) {\n      (0, warnings_1.warn)('autoPaginate true', 'Autopaginate will always be set to false in Async paging methods. See more info at https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination for more information on how to configure paging calls', 'AutopaginateTrueWarning');\n    }\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const iterable = this.createIterator(apiCall, request, options);\n    return iterable;\n  }\n  createIterator(apiCall, request, options) {\n    const asyncIterable = {\n      [Symbol.asyncIterator]() {\n        let nextPageRequest = request;\n        const cache = [];\n        return {\n          async next() {\n            if (cache.length > 0) {\n              return Promise.resolve({\n                done: false,\n                value: cache.shift()\n              });\n            }\n            let attempts = 0;\n            while (cache.length === 0 && nextPageRequest) {\n              let result;\n              [result, nextPageRequest] = await apiCall(nextPageRequest, options);\n              // For pagination response with protobuf map type, use tuple as representation.\n              if (result && !Array.isArray(result)) {\n                for (const [key, value] of Object.entries(result)) {\n                  cache.push([key, value]);\n                }\n              } else {\n                cache.push(...result);\n              }\n              if (cache.length === 0) {\n                ++attempts;\n                if (attempts > maxAttemptsEmptyResponse) {\n                  break;\n                }\n              }\n            }\n            if (cache.length === 0) {\n              return Promise.resolve({\n                done: true,\n                value: undefined\n              });\n            }\n            return Promise.resolve({\n              done: false,\n              value: cache.shift()\n            });\n          }\n        };\n      }\n    };\n    return asyncIterable;\n  }\n  getApiCaller(settings) {\n    if (!settings.autoPaginate) {\n      return new normalApiCaller_1.NormalApiCaller();\n    }\n    return new pagedApiCaller_1.PagedApiCaller(this);\n  }\n}\nexports.PageDescriptor = PageDescriptor;","map":{"version":3,"names":["Object","defineProperty","exports","value","PageDescriptor","stream_1","require","normalApiCaller_1","warnings_1","pagedApiCaller_1","maxAttemptsEmptyResponse","requestPageTokenField","responsePageTokenField","requestPageSizeField","resourceField","constructor","createStream","apiCall","request","options","autoPaginate","warn","stream","PassThrough","objectMode","assign","maxResults","pushCount","started","callback","err","resources","next","apiResp","emit","i","length","_readableState","ended","push","end","pageToken","isPaused","setImmediate","on","asyncIterate","iterable","createIterator","asyncIterable","Symbol","asyncIterator","nextPageRequest","cache","Promise","resolve","done","shift","attempts","result","Array","isArray","key","entries","undefined","getApiCaller","settings","NormalApiCaller","PagedApiCaller"],"sources":["C:/Users/BIT/chatboot/node_modules/google-gax/build/src/paginationCalls/pageDescriptor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PageDescriptor = void 0;\nconst stream_1 = require(\"stream\");\nconst normalApiCaller_1 = require(\"../normalCalls/normalApiCaller\");\nconst warnings_1 = require(\".././warnings\");\nconst pagedApiCaller_1 = require(\"./pagedApiCaller\");\nconst maxAttemptsEmptyResponse = 10;\n/**\n * A descriptor for methods that support pagination.\n */\nclass PageDescriptor {\n    requestPageTokenField;\n    responsePageTokenField;\n    requestPageSizeField;\n    resourceField;\n    constructor(requestPageTokenField, responsePageTokenField, resourceField) {\n        this.requestPageTokenField = requestPageTokenField;\n        this.responsePageTokenField = responsePageTokenField;\n        this.resourceField = resourceField;\n    }\n    /**\n     * Creates a new object Stream which emits the resource on 'data' event.\n     */\n    createStream(apiCall, request, options) {\n        if (options?.autoPaginate) {\n            (0, warnings_1.warn)('autoPaginate true', 'Autopaginate will always be set to false in stream paging methods. See more info at https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination for more information on how to configure paging calls', 'AutopaginateTrueWarning');\n        }\n        const stream = new stream_1.PassThrough({ objectMode: true });\n        options = Object.assign({}, options, { autoPaginate: false });\n        const maxResults = 'maxResults' in options ? options.maxResults : -1;\n        let pushCount = 0;\n        let started = false;\n        function callback(err, resources, next, apiResp) {\n            if (err) {\n                stream.emit('error', err);\n                return;\n            }\n            // emit full api response with every page.\n            stream.emit('response', apiResp);\n            for (let i = 0; i < resources.length; ++i) {\n                // TODO: rewrite without accessing stream internals\n                if (stream\n                    ._readableState.ended) {\n                    return;\n                }\n                if (resources[i] === null) {\n                    continue;\n                }\n                stream.push(resources[i]);\n                pushCount++;\n                if (pushCount === maxResults) {\n                    stream.end();\n                }\n            }\n            // TODO: rewrite without accessing stream internals\n            if (stream._readableState\n                .ended) {\n                return;\n            }\n            if (!next) {\n                stream.end();\n                return;\n            }\n            // When pageToken is specified in the original options, it will overwrite\n            // the page token field in the next request. Therefore it must be cleared.\n            if ('pageToken' in options) {\n                delete options.pageToken;\n            }\n            if (stream.isPaused()) {\n                request = next;\n                started = false;\n            }\n            else {\n                setImmediate(apiCall, next, options, callback);\n            }\n        }\n        stream.on('resume', async () => {\n            if (!started) {\n                started = true;\n                await apiCall(request, options, callback);\n            }\n        });\n        return stream;\n    }\n    /**\n     * Create an async iterable which can be recursively called for data on-demand.\n     */\n    asyncIterate(apiCall, request, options) {\n        if (options?.autoPaginate) {\n            (0, warnings_1.warn)('autoPaginate true', 'Autopaginate will always be set to false in Async paging methods. See more info at https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination for more information on how to configure paging calls', 'AutopaginateTrueWarning');\n        }\n        options = Object.assign({}, options, { autoPaginate: false });\n        const iterable = this.createIterator(apiCall, request, options);\n        return iterable;\n    }\n    createIterator(apiCall, request, options) {\n        const asyncIterable = {\n            [Symbol.asyncIterator]() {\n                let nextPageRequest = request;\n                const cache = [];\n                return {\n                    async next() {\n                        if (cache.length > 0) {\n                            return Promise.resolve({\n                                done: false,\n                                value: cache.shift(),\n                            });\n                        }\n                        let attempts = 0;\n                        while (cache.length === 0 && nextPageRequest) {\n                            let result;\n                            [result, nextPageRequest] = (await apiCall(nextPageRequest, options));\n                            // For pagination response with protobuf map type, use tuple as representation.\n                            if (result && !Array.isArray(result)) {\n                                for (const [key, value] of Object.entries(result)) {\n                                    cache.push([key, value]);\n                                }\n                            }\n                            else {\n                                cache.push(...result);\n                            }\n                            if (cache.length === 0) {\n                                ++attempts;\n                                if (attempts > maxAttemptsEmptyResponse) {\n                                    break;\n                                }\n                            }\n                        }\n                        if (cache.length === 0) {\n                            return Promise.resolve({ done: true, value: undefined });\n                        }\n                        return Promise.resolve({ done: false, value: cache.shift() });\n                    },\n                };\n            },\n        };\n        return asyncIterable;\n    }\n    getApiCaller(settings) {\n        if (!settings.autoPaginate) {\n            return new normalApiCaller_1.NormalApiCaller();\n        }\n        return new pagedApiCaller_1.PagedApiCaller(this);\n    }\n}\nexports.PageDescriptor = PageDescriptor;\n//# sourceMappingURL=pageDescriptor.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}