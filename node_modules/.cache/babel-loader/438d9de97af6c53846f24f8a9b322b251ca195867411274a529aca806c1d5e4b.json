{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\nconst http2 = require(\"http2\");\nconst util = require(\"util\");\nconst constants_1 = require(\"./constants\");\nconst server_call_1 = require(\"./server-call\");\nconst server_credentials_1 = require(\"./server-credentials\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst channelz_1 = require(\"./channelz\");\nconst server_interceptors_1 = require(\"./server-interceptors\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst MAX_CONNECTION_IDLE_MS = ~(1 << 31);\nconst {\n  HTTP2_HEADER_PATH\n} = http2.constants;\nconst TRACER_NAME = 'server';\nconst kMaxAge = Buffer.from('max_age');\nfunction serverCallTrace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, 'server_call', text);\n}\nfunction noop() {}\n/**\n * Decorator to wrap a class method with util.deprecate\n * @param message The message to output if the deprecated method is called\n * @returns\n */\nfunction deprecate(message) {\n  return function (target, context) {\n    return util.deprecate(target, message);\n  };\n}\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`\n  };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\nlet Server = (() => {\n  var _a;\n  let _instanceExtraInitializers = [];\n  let _start_decorators;\n  return _a = class Server {\n    constructor(options) {\n      var _b, _c, _d, _e, _f, _g;\n      this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());\n      this.http2Servers = new Map();\n      this.sessionIdleTimeouts = new Map();\n      this.handlers = new Map();\n      this.sessions = new Map();\n      /**\n       * This field only exists to ensure that the start method throws an error if\n       * it is called twice, as it did previously.\n       */\n      this.started = false;\n      this.shutdown = false;\n      this.serverAddressString = 'null';\n      // Channelz Info\n      this.channelzEnabled = true;\n      this.options = options !== null && options !== void 0 ? options : {};\n      if (this.options['grpc.enable_channelz'] === 0) {\n        this.channelzEnabled = false;\n        this.channelzTrace = new channelz_1.ChannelzTraceStub();\n        this.callTracker = new channelz_1.ChannelzCallTrackerStub();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\n      } else {\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n      }\n      this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n      this.maxConnectionAgeMs = (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n      this.maxConnectionAgeGraceMs = (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;\n      this.keepaliveTimeMs = (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;\n      this.keepaliveTimeoutMs = (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;\n      this.sessionIdleTimeout = (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;\n      this.commonServerOptions = {\n        maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n      };\n      if ('grpc-node.max_session_memory' in this.options) {\n        this.commonServerOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      if ('grpc.max_concurrent_streams' in this.options) {\n        this.commonServerOptions.settings = {\n          maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n        };\n      }\n      this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];\n      this.trace('Server constructed');\n    }\n    getChannelzInfo() {\n      return {\n        trace: this.channelzTrace,\n        callTracker: this.callTracker,\n        listenerChildren: this.listenerChildrenTracker.getChildLists(),\n        sessionChildren: this.sessionChildrenTracker.getChildLists()\n      };\n    }\n    getChannelzSessionInfo(session) {\n      var _b, _c, _d;\n      const sessionInfo = this.sessions.get(session);\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n      let tlsInfo;\n      if (session.encrypted) {\n        const tlsSocket = sessionSocket;\n        const cipherInfo = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== void 0 ? _b : null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n          remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: sessionInfo.keepAlivesSent,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== void 0 ? _c : null,\n        remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null\n      };\n      return socketInfo;\n    }\n    trace(text) {\n      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n    }\n    keepaliveTrace(text) {\n      logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);\n    }\n    addProtoService() {\n      throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n      if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n        throw new Error('addService() requires two objects as arguments');\n      }\n      const serviceKeys = Object.keys(service);\n      if (serviceKeys.length === 0) {\n        throw new Error('Cannot add an empty service to a server');\n      }\n      serviceKeys.forEach(name => {\n        const attrs = service[name];\n        let methodType;\n        if (attrs.requestStream) {\n          if (attrs.responseStream) {\n            methodType = 'bidi';\n          } else {\n            methodType = 'clientStream';\n          }\n        } else {\n          if (attrs.responseStream) {\n            methodType = 'serverStream';\n          } else {\n            methodType = 'unary';\n          }\n        }\n        let implFn = implementation[name];\n        let impl;\n        if (implFn === undefined && typeof attrs.originalName === 'string') {\n          implFn = implementation[attrs.originalName];\n        }\n        if (implFn !== undefined) {\n          impl = implFn.bind(implementation);\n        } else {\n          impl = getDefaultHandler(methodType, name);\n        }\n        const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n        if (success === false) {\n          throw new Error(`Method handler for ${attrs.path} already provided.`);\n        }\n      });\n    }\n    removeService(service) {\n      if (service === null || typeof service !== 'object') {\n        throw new Error('removeService() requires object as argument');\n      }\n      const serviceKeys = Object.keys(service);\n      serviceKeys.forEach(name => {\n        const attrs = service[name];\n        this.unregister(attrs.path);\n      });\n    }\n    bind(port, creds) {\n      throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    /**\n     * This API is experimental, so API stability is not guaranteed across minor versions.\n     * @param boundAddress\n     * @returns\n     */\n    experimentalRegisterListenerToChannelz(boundAddress) {\n      return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {\n        return {\n          localAddress: boundAddress,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null\n        };\n      }, this.channelzEnabled);\n    }\n    experimentalUnregisterListenerFromChannelz(channelzRef) {\n      (0, channelz_1.unregisterChannelzRef)(channelzRef);\n    }\n    createHttp2Server(credentials) {\n      let http2Server;\n      if (credentials._isSecure()) {\n        const constructorOptions = credentials._getConstructorOptions();\n        const contextOptions = credentials._getSecureContextOptions();\n        const secureServerOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), constructorOptions), contextOptions), {\n          enableTrace: this.options['grpc-node.tls_enable_trace'] === 1\n        });\n        let areCredentialsValid = contextOptions !== null;\n        this.trace('Initial credentials valid: ' + areCredentialsValid);\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.prependListener('connection', socket => {\n          if (!areCredentialsValid) {\n            this.trace('Dropped connection from ' + JSON.stringify(socket.address()) + ' due to unloaded credentials');\n            socket.destroy();\n          }\n        });\n        http2Server.on('secureConnection', socket => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', e => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n        const credsWatcher = options => {\n          if (options) {\n            const secureServer = http2Server;\n            try {\n              secureServer.setSecureContext(options);\n            } catch (e) {\n              logging.log(constants_1.LogVerbosity.ERROR, 'Failed to set secure context with error ' + e.message);\n              options = null;\n            }\n          }\n          areCredentialsValid = options !== null;\n          this.trace('Post-update credentials valid: ' + areCredentialsValid);\n        };\n        credentials._addWatcher(credsWatcher);\n        http2Server.on('close', () => {\n          credentials._removeWatcher(credsWatcher);\n        });\n      } else {\n        http2Server = http2.createServer(this.commonServerOptions);\n      }\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server, credentials._getInterceptors());\n      return http2Server;\n    }\n    bindOneAddress(address, boundPortObject) {\n      this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n      const http2Server = this.createHttp2Server(boundPortObject.credentials);\n      return new Promise((resolve, reject) => {\n        const onError = err => {\n          this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n          resolve({\n            port: 'port' in address ? address.port : 1,\n            error: err.message\n          });\n        };\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address();\n          let boundSubchannelAddress;\n          if (typeof boundAddress === 'string') {\n            boundSubchannelAddress = {\n              path: boundAddress\n            };\n          } else {\n            boundSubchannelAddress = {\n              host: boundAddress.address,\n              port: boundAddress.port\n            };\n          }\n          const channelzRef = this.experimentalRegisterListenerToChannelz(boundSubchannelAddress);\n          this.listenerChildrenTracker.refChild(channelzRef);\n          this.http2Servers.set(http2Server, {\n            channelzRef: channelzRef,\n            sessions: new Set(),\n            ownsChannelzRef: true\n          });\n          boundPortObject.listeningServers.add(http2Server);\n          this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n          resolve({\n            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1\n          });\n          http2Server.removeListener('error', onError);\n        });\n      });\n    }\n    async bindManyPorts(addressList, boundPortObject) {\n      if (addressList.length === 0) {\n        return {\n          count: 0,\n          port: 0,\n          errors: []\n        };\n      }\n      if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {\n        /* If binding to port 0, first try to bind the first address, then bind\n         * the rest of the address list to the specific port that it binds. */\n        const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);\n        if (firstAddressResult.error) {\n          /* If the first address fails to bind, try the same operation starting\n           * from the second item in the list. */\n          const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);\n          return Object.assign(Object.assign({}, restAddressResult), {\n            errors: [firstAddressResult.error, ...restAddressResult.errors]\n          });\n        } else {\n          const restAddresses = addressList.slice(1).map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address) ? {\n            host: address.host,\n            port: firstAddressResult.port\n          } : address);\n          const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));\n          const allResults = [firstAddressResult, ...restAddressResult];\n          return {\n            count: allResults.filter(result => result.error === undefined).length,\n            port: firstAddressResult.port,\n            errors: allResults.filter(result => result.error).map(result => result.error)\n          };\n        }\n      } else {\n        const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));\n        return {\n          count: allResults.filter(result => result.error === undefined).length,\n          port: allResults[0].port,\n          errors: allResults.filter(result => result.error).map(result => result.error)\n        };\n      }\n    }\n    async bindAddressList(addressList, boundPortObject) {\n      const bindResult = await this.bindManyPorts(addressList, boundPortObject);\n      if (bindResult.count > 0) {\n        if (bindResult.count < addressList.length) {\n          logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n        }\n        return bindResult.port;\n      } else {\n        const errorString = `No address added out of total ${addressList.length} resolved`;\n        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n        throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);\n      }\n    }\n    resolvePort(port) {\n      return new Promise((resolve, reject) => {\n        const resolverListener = {\n          onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {\n            // We only want one resolution result. Discard all future results\n            resolverListener.onSuccessfulResolution = () => {};\n            const addressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\n            if (addressList.length === 0) {\n              reject(new Error(`No addresses resolved for port ${port}`));\n              return;\n            }\n            resolve(addressList);\n          },\n          onError: error => {\n            reject(new Error(error.details));\n          }\n        };\n        const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);\n        resolver.updateResolution();\n      });\n    }\n    async bindPort(port, boundPortObject) {\n      const addressList = await this.resolvePort(port);\n      if (boundPortObject.cancelled) {\n        this.completeUnbind(boundPortObject);\n        throw new Error('bindAsync operation cancelled by unbind call');\n      }\n      const portNumber = await this.bindAddressList(addressList, boundPortObject);\n      if (boundPortObject.cancelled) {\n        this.completeUnbind(boundPortObject);\n        throw new Error('bindAsync operation cancelled by unbind call');\n      }\n      return portNumber;\n    }\n    normalizePort(port) {\n      const initialPortUri = (0, uri_parser_1.parseUri)(port);\n      if (initialPortUri === null) {\n        throw new Error(`Could not parse port \"${port}\"`);\n      }\n      const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n      if (portUri === null) {\n        throw new Error(`Could not get a default scheme for port \"${port}\"`);\n      }\n      return portUri;\n    }\n    bindAsync(port, creds, callback) {\n      if (this.shutdown) {\n        throw new Error('bindAsync called after shutdown');\n      }\n      if (typeof port !== 'string') {\n        throw new TypeError('port must be a string');\n      }\n      if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n        throw new TypeError('creds must be a ServerCredentials object');\n      }\n      if (typeof callback !== 'function') {\n        throw new TypeError('callback must be a function');\n      }\n      this.trace('bindAsync port=' + port);\n      const portUri = this.normalizePort(port);\n      const deferredCallback = (error, port) => {\n        process.nextTick(() => callback(error, port));\n      };\n      /* First, if this port is already bound or that bind operation is in\n       * progress, use that result. */\n      let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n      if (boundPortObject) {\n        if (!creds._equals(boundPortObject.credentials)) {\n          deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);\n          return;\n        }\n        /* If that operation has previously been cancelled by an unbind call,\n         * uncancel it. */\n        boundPortObject.cancelled = false;\n        if (boundPortObject.completionPromise) {\n          boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));\n        } else {\n          deferredCallback(null, boundPortObject.portNumber);\n        }\n        return;\n      }\n      boundPortObject = {\n        mapKey: (0, uri_parser_1.uriToString)(portUri),\n        originalUri: portUri,\n        completionPromise: null,\n        cancelled: false,\n        portNumber: 0,\n        credentials: creds,\n        listeningServers: new Set()\n      };\n      const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n      const completionPromise = this.bindPort(portUri, boundPortObject);\n      boundPortObject.completionPromise = completionPromise;\n      /* If the port number is 0, defer populating the map entry until after the\n       * bind operation completes and we have a specific port number. Otherwise,\n       * populate it immediately. */\n      if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n        completionPromise.then(portNum => {\n          const finalUri = {\n            scheme: portUri.scheme,\n            authority: portUri.authority,\n            path: (0, uri_parser_1.combineHostPort)({\n              host: splitPort.host,\n              port: portNum\n            })\n          };\n          boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);\n          boundPortObject.completionPromise = null;\n          boundPortObject.portNumber = portNum;\n          this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n          callback(null, portNum);\n        }, error => {\n          callback(error, 0);\n        });\n      } else {\n        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n        completionPromise.then(portNum => {\n          boundPortObject.completionPromise = null;\n          boundPortObject.portNumber = portNum;\n          callback(null, portNum);\n        }, error => {\n          callback(error, 0);\n        });\n      }\n    }\n    registerInjectorToChannelz() {\n      return (0, channelz_1.registerChannelzSocket)('injector', () => {\n        return {\n          localAddress: null,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null\n        };\n      }, this.channelzEnabled);\n    }\n    /**\n     * This API is experimental, so API stability is not guaranteed across minor versions.\n     * @param credentials\n     * @param channelzRef\n     * @returns\n     */\n    experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, ownsChannelzRef = false) {\n      if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\n        throw new TypeError('creds must be a ServerCredentials object');\n      }\n      if (this.channelzEnabled) {\n        this.listenerChildrenTracker.refChild(channelzRef);\n      }\n      const server = this.createHttp2Server(credentials);\n      const sessionsSet = new Set();\n      this.http2Servers.set(server, {\n        channelzRef: channelzRef,\n        sessions: sessionsSet,\n        ownsChannelzRef\n      });\n      return {\n        injectConnection: connection => {\n          server.emit('connection', connection);\n        },\n        drain: graceTimeMs => {\n          var _b, _c;\n          for (const session of sessionsSet) {\n            this.closeSession(session);\n          }\n          (_c = (_b = setTimeout(() => {\n            for (const session of sessionsSet) {\n              session.destroy(http2.constants.NGHTTP2_CANCEL);\n            }\n          }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n        },\n        destroy: () => {\n          this.closeServer(server);\n          for (const session of sessionsSet) {\n            this.closeSession(session);\n          }\n        }\n      };\n    }\n    createConnectionInjector(credentials) {\n      if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\n        throw new TypeError('creds must be a ServerCredentials object');\n      }\n      const channelzRef = this.registerInjectorToChannelz();\n      return this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, true);\n    }\n    closeServer(server, callback) {\n      this.trace('Closing server with address ' + JSON.stringify(server.address()));\n      const serverInfo = this.http2Servers.get(server);\n      server.close(() => {\n        if (serverInfo && serverInfo.ownsChannelzRef) {\n          this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\n          (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);\n        }\n        this.http2Servers.delete(server);\n        callback === null || callback === void 0 ? void 0 : callback();\n      });\n    }\n    closeSession(session, callback) {\n      var _b;\n      this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n      const sessionInfo = this.sessions.get(session);\n      const closeCallback = () => {\n        if (sessionInfo) {\n          this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\n          (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);\n        }\n        callback === null || callback === void 0 ? void 0 : callback();\n      };\n      if (session.closed) {\n        queueMicrotask(closeCallback);\n      } else {\n        session.close(closeCallback);\n      }\n    }\n    completeUnbind(boundPortObject) {\n      for (const server of boundPortObject.listeningServers) {\n        const serverInfo = this.http2Servers.get(server);\n        this.closeServer(server, () => {\n          boundPortObject.listeningServers.delete(server);\n        });\n        if (serverInfo) {\n          for (const session of serverInfo.sessions) {\n            this.closeSession(session);\n          }\n        }\n      }\n      this.boundPorts.delete(boundPortObject.mapKey);\n    }\n    /**\n     * Unbind a previously bound port, or cancel an in-progress bindAsync\n     * operation. If port 0 was bound, only the actual bound port can be\n     * unbound. For example, if bindAsync was called with \"localhost:0\" and the\n     * bound port result was 54321, it can be unbound as \"localhost:54321\".\n     * @param port\n     */\n    unbind(port) {\n      this.trace('unbind port=' + port);\n      const portUri = this.normalizePort(port);\n      const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n      if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n        throw new Error('Cannot unbind port 0');\n      }\n      const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n      if (boundPortObject) {\n        this.trace('unbinding ' + boundPortObject.mapKey + ' originally bound as ' + (0, uri_parser_1.uriToString)(boundPortObject.originalUri));\n        /* If the bind operation is pending, the cancelled flag will trigger\n         * the unbind operation later. */\n        if (boundPortObject.completionPromise) {\n          boundPortObject.cancelled = true;\n        } else {\n          this.completeUnbind(boundPortObject);\n        }\n      }\n    }\n    /**\n     * Gracefully close all connections associated with a previously bound port.\n     * After the grace time, forcefully close all remaining open connections.\n     *\n     * If port 0 was bound, only the actual bound port can be\n     * drained. For example, if bindAsync was called with \"localhost:0\" and the\n     * bound port result was 54321, it can be drained as \"localhost:54321\".\n     * @param port\n     * @param graceTimeMs\n     * @returns\n     */\n    drain(port, graceTimeMs) {\n      var _b, _c;\n      this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);\n      const portUri = this.normalizePort(port);\n      const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\n      if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\n        throw new Error('Cannot drain port 0');\n      }\n      const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\n      if (!boundPortObject) {\n        return;\n      }\n      const allSessions = new Set();\n      for (const http2Server of boundPortObject.listeningServers) {\n        const serverEntry = this.http2Servers.get(http2Server);\n        if (serverEntry) {\n          for (const session of serverEntry.sessions) {\n            allSessions.add(session);\n            this.closeSession(session, () => {\n              allSessions.delete(session);\n            });\n          }\n        }\n      }\n      /* After the grace time ends, send another goaway to all remaining sessions\n       * with the CANCEL code. */\n      (_c = (_b = setTimeout(() => {\n        for (const session of allSessions) {\n          session.destroy(http2.constants.NGHTTP2_CANCEL);\n        }\n      }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    forceShutdown() {\n      for (const boundPortObject of this.boundPorts.values()) {\n        boundPortObject.cancelled = true;\n      }\n      this.boundPorts.clear();\n      // Close the server if it is still running.\n      for (const server of this.http2Servers.keys()) {\n        this.closeServer(server);\n      }\n      // Always destroy any available sessions. It's possible that one or more\n      // tryShutdown() calls are in progress. Don't wait on them to finish.\n      this.sessions.forEach((channelzInfo, session) => {\n        this.closeSession(session);\n        // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n        // recognize destroy(code) as a valid signature.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        session.destroy(http2.constants.NGHTTP2_CANCEL);\n      });\n      this.sessions.clear();\n      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      this.shutdown = true;\n    }\n    register(name, handler, serialize, deserialize, type) {\n      if (this.handlers.has(name)) {\n        return false;\n      }\n      this.handlers.set(name, {\n        func: handler,\n        serialize,\n        deserialize,\n        type,\n        path: name\n      });\n      return true;\n    }\n    unregister(name) {\n      return this.handlers.delete(name);\n    }\n    /**\n     * @deprecated No longer needed as of version 1.10.x\n     */\n    start() {\n      if (this.http2Servers.size === 0 || [...this.http2Servers.keys()].every(server => !server.listening)) {\n        throw new Error('server must be bound in order to start');\n      }\n      if (this.started === true) {\n        throw new Error('server is already started');\n      }\n      this.started = true;\n    }\n    tryShutdown(callback) {\n      var _b;\n      const wrappedCallback = error => {\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        callback(error);\n      };\n      let pendingChecks = 0;\n      function maybeCallback() {\n        pendingChecks--;\n        if (pendingChecks === 0) {\n          wrappedCallback();\n        }\n      }\n      this.shutdown = true;\n      for (const [serverKey, server] of this.http2Servers.entries()) {\n        pendingChecks++;\n        const serverString = server.channelzRef.name;\n        this.trace('Waiting for server ' + serverString + ' to close');\n        this.closeServer(serverKey, () => {\n          this.trace('Server ' + serverString + ' finished closing');\n          maybeCallback();\n        });\n        for (const session of server.sessions.keys()) {\n          pendingChecks++;\n          const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;\n          this.trace('Waiting for session ' + sessionString + ' to close');\n          this.closeSession(session, () => {\n            this.trace('Session ' + sessionString + ' finished closing');\n            maybeCallback();\n          });\n        }\n      }\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n    addHttp2Port() {\n      throw new Error('Not yet implemented');\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */\n    getChannelzRef() {\n      return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n      const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n      if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n        stream.respond({\n          [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n        }, {\n          endStream: true\n        });\n        return false;\n      }\n      return true;\n    }\n    _retrieveHandler(path) {\n      serverCallTrace('Received call to method ' + path + ' at address ' + this.serverAddressString);\n      const handler = this.handlers.get(path);\n      if (handler === undefined) {\n        serverCallTrace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n        return null;\n      }\n      return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n      var _b, _c;\n      const trailersToSend = Object.assign({\n        'grpc-status': (_b = err.code) !== null && _b !== void 0 ? _b : constants_1.Status.INTERNAL,\n        'grpc-message': err.details,\n        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n        [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n      }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());\n      stream.respond(trailersToSend, {\n        endStream: true\n      });\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n    }\n    _channelzHandler(extraInterceptors, stream, headers) {\n      // for handling idle timeout\n      this.onStreamOpened(stream);\n      const channelzSessionInfo = this.sessions.get(stream.session);\n      this.callTracker.addCallStarted();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n      if (!this._verifyContentType(stream, headers)) {\n        this.callTracker.addCallFailed();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        return;\n      }\n      const path = headers[HTTP2_HEADER_PATH];\n      const handler = this._retrieveHandler(path);\n      if (!handler) {\n        this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n        return;\n      }\n      const callEventTracker = {\n        addMessageSent: () => {\n          if (channelzSessionInfo) {\n            channelzSessionInfo.messagesSent += 1;\n            channelzSessionInfo.lastMessageSentTimestamp = new Date();\n          }\n        },\n        addMessageReceived: () => {\n          if (channelzSessionInfo) {\n            channelzSessionInfo.messagesReceived += 1;\n            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n          }\n        },\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        },\n        onStreamEnd: success => {\n          if (channelzSessionInfo) {\n            if (success) {\n              channelzSessionInfo.streamTracker.addCallSucceeded();\n            } else {\n              channelzSessionInfo.streamTracker.addCallFailed();\n            }\n          }\n        }\n      };\n      const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);\n      if (!this._runHandlerForCall(call, handler)) {\n        this.callTracker.addCallFailed();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        call.sendStatus({\n          code: constants_1.Status.INTERNAL,\n          details: `Unknown handler type: ${handler.type}`\n        });\n      }\n    }\n    _streamHandler(extraInterceptors, stream, headers) {\n      // for handling idle timeout\n      this.onStreamOpened(stream);\n      if (this._verifyContentType(stream, headers) !== true) {\n        return;\n      }\n      const path = headers[HTTP2_HEADER_PATH];\n      const handler = this._retrieveHandler(path);\n      if (!handler) {\n        this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n        return;\n      }\n      const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);\n      if (!this._runHandlerForCall(call, handler)) {\n        call.sendStatus({\n          code: constants_1.Status.INTERNAL,\n          details: `Unknown handler type: ${handler.type}`\n        });\n      }\n    }\n    _runHandlerForCall(call, handler) {\n      const {\n        type\n      } = handler;\n      if (type === 'unary') {\n        handleUnary(call, handler);\n      } else if (type === 'clientStream') {\n        handleClientStreaming(call, handler);\n      } else if (type === 'serverStream') {\n        handleServerStreaming(call, handler);\n      } else if (type === 'bidi') {\n        handleBidiStreaming(call, handler);\n      } else {\n        return false;\n      }\n      return true;\n    }\n    _setupHandlers(http2Server, extraInterceptors) {\n      if (http2Server === null) {\n        return;\n      }\n      const serverAddress = http2Server.address();\n      let serverAddressString = 'null';\n      if (serverAddress) {\n        if (typeof serverAddress === 'string') {\n          serverAddressString = serverAddress;\n        } else {\n          serverAddressString = serverAddress.address + ':' + serverAddress.port;\n        }\n      }\n      this.serverAddressString = serverAddressString;\n      const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n      const sessionHandler = this.channelzEnabled ? this._channelzSessionHandler(http2Server) : this._sessionHandler(http2Server);\n      http2Server.on('stream', handler.bind(this, extraInterceptors));\n      http2Server.on('session', sessionHandler);\n    }\n    _sessionHandler(http2Server) {\n      return session => {\n        var _b, _c;\n        (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);\n        let connectionAgeTimer = null;\n        let connectionAgeGraceTimer = null;\n        let keepaliveTimer = null;\n        let sessionClosedByServer = false;\n        const idleTimeoutObj = this.enableIdleTimeout(session);\n        if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n          // Apply a random jitter within a +/-10% range\n          const jitterMagnitude = this.maxConnectionAgeMs / 10;\n          const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n          connectionAgeTimer = setTimeout(() => {\n            var _b, _c;\n            sessionClosedByServer = true;\n            this.trace('Connection dropped by max connection age: ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\n            try {\n              session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n            } catch (e) {\n              // The goaway can't be sent because the session is already closed\n              session.destroy();\n              return;\n            }\n            session.close();\n            /* Allow a grace period after sending the GOAWAY before forcibly\n             * closing the connection. */\n            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n              connectionAgeGraceTimer = setTimeout(() => {\n                session.destroy();\n              }, this.maxConnectionAgeGraceMs);\n              (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);\n            }\n          }, this.maxConnectionAgeMs + jitter);\n          (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);\n        }\n        const clearKeepaliveTimeout = () => {\n          if (keepaliveTimer) {\n            clearTimeout(keepaliveTimer);\n            keepaliveTimer = null;\n          }\n        };\n        const canSendPing = () => {\n          return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;\n        };\n        /* eslint-disable-next-line prefer-const */\n        let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n        const maybeStartKeepalivePingTimer = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n          keepaliveTimer = setTimeout(() => {\n            clearKeepaliveTimeout();\n            sendPing();\n          }, this.keepaliveTimeMs);\n          (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n        };\n        sendPing = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n          let pingSendError = '';\n          try {\n            const pingSentSuccessfully = session.ping((err, duration, payload) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            });\n            if (!pingSentSuccessfully) {\n              pingSendError = 'Ping returned false';\n            }\n          } catch (e) {\n            // grpc/grpc-node#2139\n            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n          }\n          if (pingSendError) {\n            this.keepaliveTrace('Ping send failed: ' + pingSendError);\n            this.trace('Connection dropped due to ping send error: ' + pingSendError);\n            sessionClosedByServer = true;\n            session.close();\n            return;\n          }\n          keepaliveTimer = setTimeout(() => {\n            clearKeepaliveTimeout();\n            this.keepaliveTrace('Ping timeout passed without response');\n            this.trace('Connection dropped by keepalive timeout');\n            sessionClosedByServer = true;\n            session.close();\n          }, this.keepaliveTimeoutMs);\n          (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\n        };\n        maybeStartKeepalivePingTimer();\n        session.on('close', () => {\n          var _b, _c;\n          if (!sessionClosedByServer) {\n            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);\n          }\n          if (connectionAgeTimer) {\n            clearTimeout(connectionAgeTimer);\n          }\n          if (connectionAgeGraceTimer) {\n            clearTimeout(connectionAgeGraceTimer);\n          }\n          clearKeepaliveTimeout();\n          if (idleTimeoutObj !== null) {\n            clearTimeout(idleTimeoutObj.timeout);\n            this.sessionIdleTimeouts.delete(session);\n          }\n          (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);\n        });\n      };\n    }\n    _channelzSessionHandler(http2Server) {\n      return session => {\n        var _b, _c, _d, _e;\n        const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null && _c !== void 0 ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);\n        const channelzSessionInfo = {\n          ref: channelzRef,\n          streamTracker: new channelz_1.ChannelzCallTracker(),\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null\n        };\n        (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);\n        this.sessions.set(session, channelzSessionInfo);\n        const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.trace('Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n        let connectionAgeTimer = null;\n        let connectionAgeGraceTimer = null;\n        let keepaliveTimeout = null;\n        let sessionClosedByServer = false;\n        const idleTimeoutObj = this.enableIdleTimeout(session);\n        if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n          // Apply a random jitter within a +/-10% range\n          const jitterMagnitude = this.maxConnectionAgeMs / 10;\n          const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n          connectionAgeTimer = setTimeout(() => {\n            var _b;\n            sessionClosedByServer = true;\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\n            try {\n              session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\n            } catch (e) {\n              // The goaway can't be sent because the session is already closed\n              session.destroy();\n              return;\n            }\n            session.close();\n            /* Allow a grace period after sending the GOAWAY before forcibly\n             * closing the connection. */\n            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n              connectionAgeGraceTimer = setTimeout(() => {\n                session.destroy();\n              }, this.maxConnectionAgeGraceMs);\n              (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);\n            }\n          }, this.maxConnectionAgeMs + jitter);\n          (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);\n        }\n        const clearKeepaliveTimeout = () => {\n          if (keepaliveTimeout) {\n            clearTimeout(keepaliveTimeout);\n            keepaliveTimeout = null;\n          }\n        };\n        const canSendPing = () => {\n          return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;\n        };\n        /* eslint-disable-next-line prefer-const */\n        let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\n        const maybeStartKeepalivePingTimer = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n          keepaliveTimeout = setTimeout(() => {\n            clearKeepaliveTimeout();\n            sendPing();\n          }, this.keepaliveTimeMs);\n          (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n        };\n        sendPing = () => {\n          var _b;\n          if (!canSendPing()) {\n            return;\n          }\n          this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n          let pingSendError = '';\n          try {\n            const pingSentSuccessfully = session.ping((err, duration, payload) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' + err.message + ' return in ' + duration);\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            });\n            if (!pingSentSuccessfully) {\n              pingSendError = 'Ping returned false';\n            }\n          } catch (e) {\n            // grpc/grpc-node#2139\n            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n          }\n          if (pingSendError) {\n            this.keepaliveTrace('Ping send failed: ' + pingSendError);\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);\n            sessionClosedByServer = true;\n            session.close();\n            return;\n          }\n          channelzSessionInfo.keepAlivesSent += 1;\n          keepaliveTimeout = setTimeout(() => {\n            clearKeepaliveTimeout();\n            this.keepaliveTrace('Ping timeout passed without response');\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\n            sessionClosedByServer = true;\n            session.close();\n          }, this.keepaliveTimeoutMs);\n          (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\n        };\n        maybeStartKeepalivePingTimer();\n        session.on('close', () => {\n          var _b;\n          if (!sessionClosedByServer) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          }\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          (0, channelz_1.unregisterChannelzRef)(channelzRef);\n          if (connectionAgeTimer) {\n            clearTimeout(connectionAgeTimer);\n          }\n          if (connectionAgeGraceTimer) {\n            clearTimeout(connectionAgeGraceTimer);\n          }\n          clearKeepaliveTimeout();\n          if (idleTimeoutObj !== null) {\n            clearTimeout(idleTimeoutObj.timeout);\n            this.sessionIdleTimeouts.delete(session);\n          }\n          (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);\n          this.sessions.delete(session);\n        });\n      };\n    }\n    enableIdleTimeout(session) {\n      var _b, _c;\n      if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {\n        return null;\n      }\n      const idleTimeoutObj = {\n        activeStreams: 0,\n        lastIdle: Date.now(),\n        onClose: this.onStreamClose.bind(this, session),\n        timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session)\n      };\n      (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n      this.sessionIdleTimeouts.set(session, idleTimeoutObj);\n      const {\n        socket\n      } = session;\n      this.trace('Enable idle timeout for ' + socket.remoteAddress + ':' + socket.remotePort);\n      return idleTimeoutObj;\n    }\n    onIdleTimeout(ctx, session) {\n      const {\n        socket\n      } = session;\n      const sessionInfo = ctx.sessionIdleTimeouts.get(session);\n      // if it is called while we have activeStreams - timer will not be rescheduled\n      // until last active stream is closed, then it will call .refresh() on the timer\n      // important part is to not clearTimeout(timer) or it becomes unusable\n      // for future refreshes\n      if (sessionInfo !== undefined && sessionInfo.activeStreams === 0) {\n        if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {\n          ctx.trace('Session idle timeout triggered for ' + (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) + ':' + (socket === null || socket === void 0 ? void 0 : socket.remotePort) + ' last idle at ' + sessionInfo.lastIdle);\n          ctx.closeSession(session);\n        } else {\n          sessionInfo.timeout.refresh();\n        }\n      }\n    }\n    onStreamOpened(stream) {\n      const session = stream.session;\n      const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n      if (idleTimeoutObj) {\n        idleTimeoutObj.activeStreams += 1;\n        stream.once('close', idleTimeoutObj.onClose);\n      }\n    }\n    onStreamClose(session) {\n      var _b, _c;\n      const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n      if (idleTimeoutObj) {\n        idleTimeoutObj.activeStreams -= 1;\n        if (idleTimeoutObj.activeStreams === 0) {\n          idleTimeoutObj.lastIdle = Date.now();\n          idleTimeoutObj.timeout.refresh();\n          this.trace('Session onStreamClose' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) + ':' + ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) + ' at ' + idleTimeoutObj.lastIdle);\n        }\n      }\n    }\n  }, (() => {\n    const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n    _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];\n    __esDecorate(_a, null, _start_decorators, {\n      kind: \"method\",\n      name: \"start\",\n      static: false,\n      private: false,\n      access: {\n        has: obj => \"start\" in obj,\n        get: obj => obj.start\n      },\n      metadata: _metadata\n    }, null, _instanceExtraInitializers);\n    if (_metadata) Object.defineProperty(_a, Symbol.metadata, {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _metadata\n    });\n  })(), _a;\n})();\nexports.Server = Server;\nasync function handleUnary(call, handler) {\n  let stream;\n  function respond(err, value, trailer, flags) {\n    if (err) {\n      call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata: trailer !== null && trailer !== void 0 ? trailer : null\n      });\n    });\n  }\n  let requestMetadata;\n  let requestMessage = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n      }\n    }\n  });\n}\nfunction handleClientStreaming(call, handler) {\n  let stream;\n  function respond(err, value, trailer, flags) {\n    if (err) {\n      call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata: trailer !== null && trailer !== void 0 ? trailer : null\n      });\n    });\n  }\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    }\n  });\n}\nfunction handleServerStreaming(call, handler) {\n  let stream;\n  let requestMetadata;\n  let requestMessage = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: constants_1.Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null\n        });\n        return;\n      }\n      stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    }\n  });\n}\nfunction handleBidiStreaming(call, handler) {\n  let stream;\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: constants_1.Status.UNKNOWN,\n          details: `Server method handler threw error ${err.message}`,\n          metadata: null\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    }\n  });\n}","map":{"version":3,"names":["http2","require","util","constants_1","server_call_1","server_credentials_1","resolver_1","logging","subchannel_address_1","uri_parser_1","channelz_1","server_interceptors_1","UNLIMITED_CONNECTION_AGE_MS","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","MAX_CONNECTION_IDLE_MS","HTTP2_HEADER_PATH","constants","TRACER_NAME","kMaxAge","Buffer","from","serverCallTrace","text","trace","LogVerbosity","DEBUG","noop","deprecate","message","target","context","getUnimplementedStatusResponse","methodName","code","Status","UNIMPLEMENTED","details","getDefaultHandler","handlerType","unimplementedStatusResponse","call","callback","emit","Error","Server","constructor","options","boundPorts","__runInitializers","_instanceExtraInitializers","Map","http2Servers","sessionIdleTimeouts","handlers","sessions","started","shutdown","serverAddressString","channelzEnabled","channelzTrace","ChannelzTraceStub","callTracker","ChannelzCallTrackerStub","listenerChildrenTracker","ChannelzChildrenTrackerStub","sessionChildrenTracker","ChannelzTrace","ChannelzCallTracker","ChannelzChildrenTracker","channelzRef","registerChannelzServer","getChannelzInfo","addTrace","maxConnectionAgeMs","_b","maxConnectionAgeGraceMs","_c","keepaliveTimeMs","_d","keepaliveTimeoutMs","_e","sessionIdleTimeout","_f","commonServerOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","settings","maxConcurrentStreams","interceptors","_g","listenerChildren","getChildLists","sessionChildren","getChannelzSessionInfo","session","sessionInfo","get","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastRemoteStreamCreatedTimestamp","lastCallStartedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","state","localWindowSize","remoteFlowControlWindow","remoteWindowSize","id","keepaliveTrace","addProtoService","addService","service","implementation","serviceKeys","Object","keys","length","forEach","attrs","methodType","requestStream","responseStream","implFn","impl","undefined","originalName","bind","success","register","path","responseSerialize","requestDeserialize","removeService","unregister","port","creds","experimentalRegisterListenerToChannelz","boundAddress","registerChannelzSocket","subchannelAddressToString","experimentalUnregisterListenerFromChannelz","unregisterChannelzRef","createHttp2Server","credentials","http2Server","_isSecure","constructorOptions","_getConstructorOptions","contextOptions","_getSecureContextOptions","secureServerOptions","assign","enableTrace","areCredentialsValid","createSecureServer","prependListener","JSON","stringify","address","destroy","on","e","credsWatcher","secureServer","setSecureContext","log","ERROR","_addWatcher","_removeWatcher","createServer","setTimeout","_setupHandlers","_getInterceptors","bindOneAddress","boundPortObject","Promise","resolve","reject","onError","err","error","once","listen","boundSubchannelAddress","host","refChild","set","Set","ownsChannelzRef","listeningServers","add","removeListener","bindManyPorts","addressList","count","errors","isTcpSubchannelAddress","firstAddressResult","restAddressResult","slice","restAddresses","map","all","allResults","filter","result","bindAddressList","bindResult","INFO","errorString","join","resolvePort","resolverListener","onSuccessfulResolution","endpointList","serviceConfig","serviceConfigError","concat","endpoint","addresses","resolver","createResolver","updateResolution","bindPort","cancelled","completeUnbind","portNumber","normalizePort","initialPortUri","parseUri","portUri","mapUriDefaultScheme","bindAsync","TypeError","ServerCredentials","deferredCallback","process","nextTick","uriToString","_equals","completionPromise","then","portNum","mapKey","originalUri","splitPort","splitHostPort","finalUri","scheme","authority","combineHostPort","registerInjectorToChannelz","experimentalCreateConnectionInjectorWithChannelzRef","server","sessionsSet","injectConnection","connection","drain","graceTimeMs","closeSession","NGHTTP2_CANCEL","unref","closeServer","createConnectionInjector","serverInfo","close","unrefChild","delete","closeCallback","ref","closed","queueMicrotask","unbind","allSessions","serverEntry","forceShutdown","values","clear","channelzInfo","handler","serialize","deserialize","type","has","func","start","size","every","listening","tryShutdown","wrappedCallback","pendingChecks","maybeCallback","serverKey","entries","serverString","sessionString","addHttp2Port","getChannelzRef","_verifyContentType","stream","headers","contentType","HTTP2_HEADER_CONTENT_TYPE","startsWith","respond","HTTP2_HEADER_STATUS","HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE","endStream","_retrieveHandler","_respondWithError","channelzSessionInfo","trailersToSend","INTERNAL","HTTP_STATUS_OK","metadata","toHttp2Headers","addCallFailed","_channelzHandler","extraInterceptors","onStreamOpened","addCallStarted","callEventTracker","addMessageSent","Date","addMessageReceived","onCallEnd","status","OK","addCallSucceeded","onStreamEnd","getServerInterceptingCall","_runHandlerForCall","sendStatus","_streamHandler","handleUnary","handleClientStreaming","handleServerStreaming","handleBidiStreaming","serverAddress","sessionHandler","_channelzSessionHandler","_sessionHandler","connectionAgeTimer","connectionAgeGraceTimer","keepaliveTimer","sessionClosedByServer","idleTimeoutObj","enableIdleTimeout","jitterMagnitude","jitter","Math","random","goaway","NGHTTP2_NO_ERROR","clearKeepaliveTimeout","clearTimeout","canSendPing","destroyed","sendPing","maybeStartKeepalivePingTimer","pingSendError","pingSentSuccessfully","ping","duration","payload","timeout","clientAddress","keepaliveTimeout","activeStreams","lastIdle","now","onClose","onStreamClose","onIdleTimeout","ctx","refresh","__esDecorate","_a","_start_decorators","kind","static","private","access","obj","_metadata","exports","value","trailer","flags","serverErrorToStatus","sendMessage","requestMetadata","requestMessage","onReceiveMetadata","startRead","onReceiveMessage","onReceiveHalfClose","ServerWritableStreamImpl","UNKNOWN","onCancel","ServerDuplexStreamImpl","push"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\server.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as util from 'util';\n\nimport { ServiceError } from './call';\nimport { Status, LogVerbosity } from './constants';\nimport { Deserialize, Serialize, ServiceDefinition } from './make-client';\nimport { Metadata } from './metadata';\nimport {\n  BidiStreamingHandler,\n  ClientStreamingHandler,\n  HandleCall,\n  Handler,\n  HandlerType,\n  sendUnaryData,\n  ServerDuplexStream,\n  ServerDuplexStreamImpl,\n  ServerReadableStream,\n  ServerStreamingHandler,\n  ServerUnaryCall,\n  ServerWritableStream,\n  ServerWritableStreamImpl,\n  UnaryHandler,\n  ServerErrorResponse,\n  ServerStatusResponse,\n  serverErrorToStatus,\n} from './server-call';\nimport { SecureContextWatcher, ServerCredentials } from './server-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  createResolver,\n  ResolverListener,\n  mapUriDefaultScheme,\n} from './resolver';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n  stringToSubchannelAddress,\n} from './subchannel-address';\nimport {\n  GrpcUri,\n  combineHostPort,\n  parseUri,\n  splitHostPort,\n  uriToString,\n} from './uri-parser';\nimport {\n  ChannelzCallTracker,\n  ChannelzCallTrackerStub,\n  ChannelzChildrenTracker,\n  ChannelzChildrenTrackerStub,\n  ChannelzTrace,\n  ChannelzTraceStub,\n  registerChannelzServer,\n  registerChannelzSocket,\n  ServerInfo,\n  ServerRef,\n  SocketInfo,\n  SocketRef,\n  TlsInfo,\n  unregisterChannelzRef,\n} from './channelz';\nimport { CipherNameAndProtocol, TLSSocket } from 'tls';\nimport {\n  ServerInterceptingCallInterface,\n  ServerInterceptor,\n  getServerInterceptingCall,\n} from './server-interceptors';\nimport { PartialStatusObject } from './call-interface';\nimport { CallEventTracker } from './transport';\nimport { Socket } from 'net';\nimport { Duplex } from 'stream';\n\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst MAX_CONNECTION_IDLE_MS = ~(1 << 31);\n\nconst { HTTP2_HEADER_PATH } = http2.constants;\n\nconst TRACER_NAME = 'server';\nconst kMaxAge = Buffer.from('max_age');\n\nfunction serverCallTrace(text: string) {\n  logging.trace(LogVerbosity.DEBUG, 'server_call', text);\n}\n\ntype AnyHttp2Server = http2.Http2Server | http2.Http2SecureServer;\n\ninterface BindResult {\n  port: number;\n  count: number;\n  errors: string[];\n}\n\ninterface SingleAddressBindResult {\n  port: number;\n  error?: string;\n}\n\nfunction noop(): void {}\n\n/**\n * Decorator to wrap a class method with util.deprecate\n * @param message The message to output if the deprecated method is called\n * @returns\n */\nfunction deprecate(message: string) {\n  return function <This, Args extends any[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext<\n      This,\n      (this: This, ...args: Args) => Return\n    >\n  ) {\n    return util.deprecate(target, message);\n  };\n}\n\nfunction getUnimplementedStatusResponse(\n  methodName: string\n): PartialStatusObject {\n  return {\n    code: Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedUnaryHandler = UnaryHandler<any, any>;\ntype UntypedClientStreamingHandler = ClientStreamingHandler<any, any>;\ntype UntypedServerStreamingHandler = ServerStreamingHandler<any, any>;\ntype UntypedBidiStreamingHandler = BidiStreamingHandler<any, any>;\nexport type UntypedHandleCall = HandleCall<any, any>;\ntype UntypedHandler = Handler<any, any>;\nexport interface UntypedServiceImplementation {\n  [name: string]: UntypedHandleCall;\n}\n\nfunction getDefaultHandler(handlerType: HandlerType, methodName: string) {\n  const unimplementedStatusResponse =\n    getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (\n        call: ServerUnaryCall<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'clientStream':\n      return (\n        call: ServerReadableStream<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'serverStream':\n      return (call: ServerWritableStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return (call: ServerDuplexStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\ninterface ChannelzSessionInfo {\n  ref: SocketRef;\n  streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  messagesSent: number;\n  messagesReceived: number;\n  keepAlivesSent: number;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n}\n\n/**\n * Information related to a single invocation of bindAsync. This should be\n * tracked in a map keyed by target string, normalized with a pass through\n * parseUri -> mapUriDefaultScheme -> uriToString. If the target has a port\n * number and the port number is 0, the target string is modified with the\n * concrete bound port.\n */\ninterface BoundPort {\n  /**\n   * The key used to refer to this object in the boundPorts map.\n   */\n  mapKey: string;\n  /**\n   * The target string, passed through parseUri -> mapUriDefaultScheme. Used\n   * to determine the final key when the port number is 0.\n   */\n  originalUri: GrpcUri;\n  /**\n   * If there is a pending bindAsync operation, this is a promise that resolves\n   * with the port number when that operation succeeds. If there is no such\n   * operation pending, this is null.\n   */\n  completionPromise: Promise<number> | null;\n  /**\n   * The port number that was actually bound. Populated only after\n   * completionPromise resolves.\n   */\n  portNumber: number;\n  /**\n   * Set by unbind if called while pending is true.\n   */\n  cancelled: boolean;\n  /**\n   * The credentials object passed to the original bindAsync call.\n   */\n  credentials: ServerCredentials;\n  /**\n   * The set of servers associated with this listening port. A target string\n   * that expands to multiple addresses will result in multiple listening\n   * servers.\n   */\n  listeningServers: Set<AnyHttp2Server>;\n}\n\n/**\n * Should be in a map keyed by AnyHttp2Server.\n */\ninterface Http2ServerInfo {\n  channelzRef: SocketRef;\n  sessions: Set<http2.ServerHttp2Session>;\n  ownsChannelzRef: boolean;\n}\n\ninterface SessionIdleTimeoutTracker {\n  activeStreams: number;\n  lastIdle: number;\n  timeout: NodeJS.Timeout;\n  onClose: (session: http2.ServerHttp2Session) => void | null;\n}\n\nexport interface ServerOptions extends ChannelOptions {\n  interceptors?: ServerInterceptor[];\n}\n\nexport interface ConnectionInjector {\n  injectConnection(connection: Duplex): void;\n  drain(graceTimeMs: number): void;\n  destroy(): void;\n}\n\nexport class Server {\n  private boundPorts: Map<string, BoundPort> = new Map();\n  private http2Servers: Map<AnyHttp2Server, Http2ServerInfo> = new Map();\n  private sessionIdleTimeouts = new Map<\n    http2.ServerHttp2Session,\n    SessionIdleTimeoutTracker\n  >();\n\n  private handlers: Map<string, UntypedHandler> = new Map<\n    string,\n    UntypedHandler\n  >();\n  private sessions = new Map<http2.ServerHttp2Session, ChannelzSessionInfo>();\n  /**\n   * This field only exists to ensure that the start method throws an error if\n   * it is called twice, as it did previously.\n   */\n  private started = false;\n  private shutdown = false;\n  private options: ServerOptions;\n  private serverAddressString = 'null';\n\n  // Channelz Info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: ServerRef;\n  private channelzTrace: ChannelzTrace | ChannelzTraceStub;\n  private callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  private listenerChildrenTracker:\n    | ChannelzChildrenTracker\n    | ChannelzChildrenTrackerStub;\n  private sessionChildrenTracker:\n    | ChannelzChildrenTracker\n    | ChannelzChildrenTrackerStub;\n\n  private readonly maxConnectionAgeMs: number;\n  private readonly maxConnectionAgeGraceMs: number;\n\n  private readonly keepaliveTimeMs: number;\n  private readonly keepaliveTimeoutMs: number;\n\n  private readonly sessionIdleTimeout: number;\n\n  private readonly interceptors: ServerInterceptor[];\n\n  /**\n   * Options that will be used to construct all Http2Server instances for this\n   * Server.\n   */\n  private commonServerOptions: http2.ServerOptions;\n\n  constructor(options?: ServerOptions) {\n    this.options = options ?? {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.channelzTrace = new ChannelzTraceStub();\n      this.callTracker = new ChannelzCallTrackerStub();\n      this.listenerChildrenTracker = new ChannelzChildrenTrackerStub();\n      this.sessionChildrenTracker = new ChannelzChildrenTrackerStub();\n    } else {\n      this.channelzTrace = new ChannelzTrace();\n      this.callTracker = new ChannelzCallTracker();\n      this.listenerChildrenTracker = new ChannelzChildrenTracker();\n      this.sessionChildrenTracker = new ChannelzChildrenTracker();\n    }\n\n    this.channelzRef = registerChannelzServer(\n      'server',\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n\n    this.channelzTrace.addTrace('CT_INFO', 'Server created');\n    this.maxConnectionAgeMs =\n      this.options['grpc.max_connection_age_ms'] ?? UNLIMITED_CONNECTION_AGE_MS;\n    this.maxConnectionAgeGraceMs =\n      this.options['grpc.max_connection_age_grace_ms'] ??\n      UNLIMITED_CONNECTION_AGE_MS;\n    this.keepaliveTimeMs =\n      this.options['grpc.keepalive_time_ms'] ?? KEEPALIVE_MAX_TIME_MS;\n    this.keepaliveTimeoutMs =\n      this.options['grpc.keepalive_timeout_ms'] ?? KEEPALIVE_TIMEOUT_MS;\n    this.sessionIdleTimeout =\n      this.options['grpc.max_connection_idle_ms'] ?? MAX_CONNECTION_IDLE_MS;\n\n    this.commonServerOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      this.commonServerOptions.maxSessionMemory =\n        this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      this.commonServerOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n      };\n    }\n    this.interceptors = this.options.interceptors ?? [];\n    this.trace('Server constructed');\n  }\n\n  private getChannelzInfo(): ServerInfo {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists(),\n    };\n  }\n\n  private getChannelzSessionInfo(\n    session: http2.ServerHttp2Session\n  ): SocketInfo {\n    const sessionInfo = this.sessions.get(session)!;\n    const sessionSocket = session.socket;\n    const remoteAddress = sessionSocket.remoteAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.remoteAddress,\n          sessionSocket.remotePort\n        )\n      : null;\n    const localAddress = sessionSocket.localAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.localAddress!,\n          sessionSocket.localPort\n        )\n      : null;\n    let tlsInfo: TlsInfo | null;\n    if (session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =\n        tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate:\n          certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate:\n          peerCertificate && 'raw' in peerCertificate\n            ? peerCertificate.raw\n            : null,\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: null,\n      streamsStarted: sessionInfo.streamTracker.callsStarted,\n      streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n      streamsFailed: sessionInfo.streamTracker.callsFailed,\n      messagesSent: sessionInfo.messagesSent,\n      messagesReceived: sessionInfo.messagesReceived,\n      keepAlivesSent: sessionInfo.keepAlivesSent,\n      lastLocalStreamCreatedTimestamp: null,\n      lastRemoteStreamCreatedTimestamp:\n        sessionInfo.streamTracker.lastCallStartedTimestamp,\n      lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n      localFlowControlWindow: session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: session.state.remoteWindowSize ?? null,\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' + this.channelzRef.id + ') ' + text\n    );\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' + this.channelzRef.id + ') ' + text\n    );\n  }\n\n  addProtoService(): never {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(\n    service: ServiceDefinition,\n    implementation: UntypedServiceImplementation\n  ): void {\n    if (\n      service === null ||\n      typeof service !== 'object' ||\n      implementation === null ||\n      typeof implementation !== 'object'\n    ) {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType: HandlerType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(\n        attrs.path,\n        impl as UntypedHandleCall,\n        attrs.responseSerialize,\n        attrs.requestDeserialize,\n        methodType\n      );\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service: ServiceDefinition): void {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port: string, creds: ServerCredentials): never {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  /**\n   * This API is experimental, so API stability is not guaranteed across minor versions.\n   * @param boundAddress\n   * @returns\n   */\n  protected experimentalRegisterListenerToChannelz(boundAddress: SubchannelAddress) {\n    return registerChannelzSocket(\n      subchannelAddressToString(boundAddress),\n      () => {\n        return {\n          localAddress: boundAddress,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null,\n        };\n      },\n      this.channelzEnabled\n    );\n  }\n\n  protected experimentalUnregisterListenerFromChannelz(channelzRef: SocketRef) {\n    unregisterChannelzRef(channelzRef);\n  }\n\n  private createHttp2Server(credentials: ServerCredentials) {\n    let http2Server: http2.Http2Server | http2.Http2SecureServer;\n    if (credentials._isSecure()) {\n      const constructorOptions = credentials._getConstructorOptions();\n      const contextOptions = credentials._getSecureContextOptions();\n      const secureServerOptions: http2.SecureServerOptions = {\n        ...this.commonServerOptions,\n        ...constructorOptions,\n        ...contextOptions,\n        enableTrace: this.options['grpc-node.tls_enable_trace'] === 1\n      };\n      let areCredentialsValid = contextOptions !== null;\n      this.trace('Initial credentials valid: ' + areCredentialsValid);\n      http2Server = http2.createSecureServer(secureServerOptions);\n      http2Server.prependListener('connection', (socket: Socket) => {\n        if (!areCredentialsValid) {\n          this.trace('Dropped connection from ' + JSON.stringify(socket.address()) + ' due to unloaded credentials');\n          socket.destroy();\n        }\n      });\n      http2Server.on('secureConnection', (socket: TLSSocket) => {\n        /* These errors need to be handled by the user of Http2SecureServer,\n         * according to https://github.com/nodejs/node/issues/35824 */\n        socket.on('error', (e: Error) => {\n          this.trace(\n            'An incoming TLS connection closed with error: ' + e.message\n          );\n        });\n      });\n      const credsWatcher: SecureContextWatcher = options => {\n        if (options) {\n          const secureServer = http2Server as http2.Http2SecureServer;\n          try {\n            secureServer.setSecureContext(options);\n          } catch (e) {\n            logging.log(LogVerbosity.ERROR, 'Failed to set secure context with error ' + (e as Error).message);\n            options = null;\n          }\n        }\n        areCredentialsValid = options !== null;\n        this.trace('Post-update credentials valid: ' + areCredentialsValid);\n      }\n      credentials._addWatcher(credsWatcher);\n      http2Server.on('close', () => {\n        credentials._removeWatcher(credsWatcher);\n      });\n    } else {\n      http2Server = http2.createServer(this.commonServerOptions);\n    }\n\n    http2Server.setTimeout(0, noop);\n    this._setupHandlers(http2Server, credentials._getInterceptors());\n    return http2Server;\n  }\n\n  private bindOneAddress(\n    address: SubchannelAddress,\n    boundPortObject: BoundPort\n  ): Promise<SingleAddressBindResult> {\n    this.trace('Attempting to bind ' + subchannelAddressToString(address));\n    const http2Server = this.createHttp2Server(boundPortObject.credentials);\n    return new Promise<SingleAddressBindResult>((resolve, reject) => {\n      const onError = (err: Error) => {\n        this.trace(\n          'Failed to bind ' +\n            subchannelAddressToString(address) +\n            ' with error ' +\n            err.message\n        );\n        resolve({\n          port: 'port' in address ? address.port : 1,\n          error: err.message,\n        });\n      };\n\n      http2Server.once('error', onError);\n\n      http2Server.listen(address, () => {\n        const boundAddress = http2Server.address()!;\n        let boundSubchannelAddress: SubchannelAddress;\n        if (typeof boundAddress === 'string') {\n          boundSubchannelAddress = {\n            path: boundAddress,\n          };\n        } else {\n          boundSubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port,\n          };\n        }\n\n        const channelzRef = this.experimentalRegisterListenerToChannelz(\n          boundSubchannelAddress\n        );\n        this.listenerChildrenTracker.refChild(channelzRef);\n\n        this.http2Servers.set(http2Server, {\n          channelzRef: channelzRef,\n          sessions: new Set(),\n          ownsChannelzRef: true\n        });\n        boundPortObject.listeningServers.add(http2Server);\n        this.trace(\n          'Successfully bound ' +\n            subchannelAddressToString(boundSubchannelAddress)\n        );\n        resolve({\n          port:\n            'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,\n        });\n        http2Server.removeListener('error', onError);\n      });\n    });\n  }\n\n  private async bindManyPorts(\n    addressList: SubchannelAddress[],\n    boundPortObject: BoundPort\n  ): Promise<BindResult> {\n    if (addressList.length === 0) {\n      return {\n        count: 0,\n        port: 0,\n        errors: [],\n      };\n    }\n    if (isTcpSubchannelAddress(addressList[0]) && addressList[0].port === 0) {\n      /* If binding to port 0, first try to bind the first address, then bind\n       * the rest of the address list to the specific port that it binds. */\n      const firstAddressResult = await this.bindOneAddress(\n        addressList[0],\n        boundPortObject\n      );\n      if (firstAddressResult.error) {\n        /* If the first address fails to bind, try the same operation starting\n         * from the second item in the list. */\n        const restAddressResult = await this.bindManyPorts(\n          addressList.slice(1),\n          boundPortObject\n        );\n        return {\n          ...restAddressResult,\n          errors: [firstAddressResult.error, ...restAddressResult.errors],\n        };\n      } else {\n        const restAddresses = addressList\n          .slice(1)\n          .map(address =>\n            isTcpSubchannelAddress(address)\n              ? { host: address.host, port: firstAddressResult.port }\n              : address\n          );\n        const restAddressResult = await Promise.all(\n          restAddresses.map(address =>\n            this.bindOneAddress(address, boundPortObject)\n          )\n        );\n        const allResults = [firstAddressResult, ...restAddressResult];\n        return {\n          count: allResults.filter(result => result.error === undefined).length,\n          port: firstAddressResult.port,\n          errors: allResults\n            .filter(result => result.error)\n            .map(result => result.error!),\n        };\n      }\n    } else {\n      const allResults = await Promise.all(\n        addressList.map(address =>\n          this.bindOneAddress(address, boundPortObject)\n        )\n      );\n      return {\n        count: allResults.filter(result => result.error === undefined).length,\n        port: allResults[0].port,\n        errors: allResults\n          .filter(result => result.error)\n          .map(result => result.error!),\n      };\n    }\n  }\n\n  private async bindAddressList(\n    addressList: SubchannelAddress[],\n    boundPortObject: BoundPort\n  ): Promise<number> {\n    const bindResult = await this.bindManyPorts(addressList, boundPortObject);\n    if (bindResult.count > 0) {\n      if (bindResult.count < addressList.length) {\n        logging.log(\n          LogVerbosity.INFO,\n          `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`\n        );\n      }\n      return bindResult.port;\n    } else {\n      const errorString = `No address added out of total ${addressList.length} resolved`;\n      logging.log(LogVerbosity.ERROR, errorString);\n      throw new Error(\n        `${errorString} errors: [${bindResult.errors.join(',')}]`\n      );\n    }\n  }\n\n  private resolvePort(port: GrpcUri): Promise<SubchannelAddress[]> {\n    return new Promise<SubchannelAddress[]>((resolve, reject) => {\n      const resolverListener: ResolverListener = {\n        onSuccessfulResolution: (\n          endpointList,\n          serviceConfig,\n          serviceConfigError\n        ) => {\n          // We only want one resolution result. Discard all future results\n          resolverListener.onSuccessfulResolution = () => {};\n          const addressList = ([] as SubchannelAddress[]).concat(\n            ...endpointList.map(endpoint => endpoint.addresses)\n          );\n          if (addressList.length === 0) {\n            reject(new Error(`No addresses resolved for port ${port}`));\n            return;\n          }\n          resolve(addressList);\n        },\n        onError: error => {\n          reject(new Error(error.details));\n        },\n      };\n      const resolver = createResolver(port, resolverListener, this.options);\n      resolver.updateResolution();\n    });\n  }\n\n  private async bindPort(\n    port: GrpcUri,\n    boundPortObject: BoundPort\n  ): Promise<number> {\n    const addressList = await this.resolvePort(port);\n    if (boundPortObject.cancelled) {\n      this.completeUnbind(boundPortObject);\n      throw new Error('bindAsync operation cancelled by unbind call');\n    }\n    const portNumber = await this.bindAddressList(addressList, boundPortObject);\n    if (boundPortObject.cancelled) {\n      this.completeUnbind(boundPortObject);\n      throw new Error('bindAsync operation cancelled by unbind call');\n    }\n    return portNumber;\n  }\n\n  private normalizePort(port: string): GrpcUri {\n    const initialPortUri = parseUri(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = mapUriDefaultScheme(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n    return portUri;\n  }\n\n  bindAsync(\n    port: string,\n    creds: ServerCredentials,\n    callback: (error: Error | null, port: number) => void\n  ): void {\n    if (this.shutdown) {\n      throw new Error('bindAsync called after shutdown');\n    }\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || !(creds instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    this.trace('bindAsync port=' + port);\n\n    const portUri = this.normalizePort(port);\n\n    const deferredCallback = (error: Error | null, port: number) => {\n      process.nextTick(() => callback(error, port));\n    };\n\n    /* First, if this port is already bound or that bind operation is in\n     * progress, use that result. */\n    let boundPortObject = this.boundPorts.get(uriToString(portUri));\n    if (boundPortObject) {\n      if (!creds._equals(boundPortObject.credentials)) {\n        deferredCallback(\n          new Error(`${port} already bound with incompatible credentials`),\n          0\n        );\n        return;\n      }\n      /* If that operation has previously been cancelled by an unbind call,\n       * uncancel it. */\n      boundPortObject.cancelled = false;\n      if (boundPortObject.completionPromise) {\n        boundPortObject.completionPromise.then(\n          portNum => callback(null, portNum),\n          error => callback(error as Error, 0)\n        );\n      } else {\n        deferredCallback(null, boundPortObject.portNumber);\n      }\n      return;\n    }\n    boundPortObject = {\n      mapKey: uriToString(portUri),\n      originalUri: portUri,\n      completionPromise: null,\n      cancelled: false,\n      portNumber: 0,\n      credentials: creds,\n      listeningServers: new Set(),\n    };\n    const splitPort = splitHostPort(portUri.path);\n    const completionPromise = this.bindPort(portUri, boundPortObject);\n    boundPortObject.completionPromise = completionPromise;\n    /* If the port number is 0, defer populating the map entry until after the\n     * bind operation completes and we have a specific port number. Otherwise,\n     * populate it immediately. */\n    if (splitPort?.port === 0) {\n      completionPromise.then(\n        portNum => {\n          const finalUri: GrpcUri = {\n            scheme: portUri.scheme,\n            authority: portUri.authority,\n            path: combineHostPort({ host: splitPort.host, port: portNum }),\n          };\n          boundPortObject!.mapKey = uriToString(finalUri);\n          boundPortObject!.completionPromise = null;\n          boundPortObject!.portNumber = portNum;\n          this.boundPorts.set(boundPortObject!.mapKey, boundPortObject!);\n          callback(null, portNum);\n        },\n        error => {\n          callback(error, 0);\n        }\n      );\n    } else {\n      this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\n      completionPromise.then(\n        portNum => {\n          boundPortObject!.completionPromise = null;\n          boundPortObject!.portNumber = portNum;\n          callback(null, portNum);\n        },\n        error => {\n          callback(error, 0);\n        }\n      );\n    }\n  }\n\n  private registerInjectorToChannelz() {\n    return registerChannelzSocket(\n      'injector',\n      () => {\n        return {\n          localAddress: null,\n          remoteAddress: null,\n          security: null,\n          remoteName: null,\n          streamsStarted: 0,\n          streamsSucceeded: 0,\n          streamsFailed: 0,\n          messagesSent: 0,\n          messagesReceived: 0,\n          keepAlivesSent: 0,\n          lastLocalStreamCreatedTimestamp: null,\n          lastRemoteStreamCreatedTimestamp: null,\n          lastMessageSentTimestamp: null,\n          lastMessageReceivedTimestamp: null,\n          localFlowControlWindow: null,\n          remoteFlowControlWindow: null,\n        };\n      },\n      this.channelzEnabled\n    );\n  }\n\n  /**\n   * This API is experimental, so API stability is not guaranteed across minor versions.\n   * @param credentials\n   * @param channelzRef\n   * @returns\n   */\n  protected experimentalCreateConnectionInjectorWithChannelzRef(credentials: ServerCredentials, channelzRef: SocketRef, ownsChannelzRef=false) {\n    if (credentials === null || !(credentials instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n    if (this.channelzEnabled) {\n      this.listenerChildrenTracker.refChild(channelzRef);\n    }\n    const server = this.createHttp2Server(credentials);\n    const sessionsSet: Set<http2.ServerHttp2Session> = new Set();\n    this.http2Servers.set(server, {\n      channelzRef: channelzRef,\n      sessions: sessionsSet,\n      ownsChannelzRef\n    });\n    return {\n      injectConnection: (connection: Duplex) => {\n        server.emit('connection', connection);\n      },\n      drain: (graceTimeMs: number) => {\n        for (const session of sessionsSet) {\n          this.closeSession(session);\n        }\n        setTimeout(() => {\n          for (const session of sessionsSet) {\n            session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n          }\n        }, graceTimeMs).unref?.();\n      },\n      destroy: () => {\n        this.closeServer(server)\n        for (const session of sessionsSet) {\n          this.closeSession(session);\n        }\n      }\n    };\n  }\n\n  createConnectionInjector(credentials: ServerCredentials): ConnectionInjector {\n    if (credentials === null || !(credentials instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n    const channelzRef = this.registerInjectorToChannelz();\n    return this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, true);\n  }\n\n  private closeServer(server: AnyHttp2Server, callback?: () => void) {\n    this.trace(\n      'Closing server with address ' + JSON.stringify(server.address())\n    );\n    const serverInfo = this.http2Servers.get(server);\n    server.close(() => {\n      if (serverInfo && serverInfo.ownsChannelzRef) {\n        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\n        unregisterChannelzRef(serverInfo.channelzRef);\n      }\n      this.http2Servers.delete(server);\n      callback?.();\n    });\n  }\n\n  private closeSession(\n    session: http2.ServerHttp2Session,\n    callback?: () => void\n  ) {\n    this.trace('Closing session initiated by ' + session.socket?.remoteAddress);\n    const sessionInfo = this.sessions.get(session);\n    const closeCallback = () => {\n      if (sessionInfo) {\n        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\n        unregisterChannelzRef(sessionInfo.ref);\n      }\n      callback?.();\n    };\n    if (session.closed) {\n      queueMicrotask(closeCallback);\n    } else {\n      session.close(closeCallback);\n    }\n  }\n\n  private completeUnbind(boundPortObject: BoundPort) {\n    for (const server of boundPortObject.listeningServers) {\n      const serverInfo = this.http2Servers.get(server);\n      this.closeServer(server, () => {\n        boundPortObject.listeningServers.delete(server);\n      });\n      if (serverInfo) {\n        for (const session of serverInfo.sessions) {\n          this.closeSession(session);\n        }\n      }\n    }\n    this.boundPorts.delete(boundPortObject.mapKey);\n  }\n\n  /**\n   * Unbind a previously bound port, or cancel an in-progress bindAsync\n   * operation. If port 0 was bound, only the actual bound port can be\n   * unbound. For example, if bindAsync was called with \"localhost:0\" and the\n   * bound port result was 54321, it can be unbound as \"localhost:54321\".\n   * @param port\n   */\n  unbind(port: string): void {\n    this.trace('unbind port=' + port);\n    const portUri = this.normalizePort(port);\n    const splitPort = splitHostPort(portUri.path);\n    if (splitPort?.port === 0) {\n      throw new Error('Cannot unbind port 0');\n    }\n    const boundPortObject = this.boundPorts.get(uriToString(portUri));\n    if (boundPortObject) {\n      this.trace(\n        'unbinding ' +\n          boundPortObject.mapKey +\n          ' originally bound as ' +\n          uriToString(boundPortObject.originalUri)\n      );\n      /* If the bind operation is pending, the cancelled flag will trigger\n       * the unbind operation later. */\n      if (boundPortObject.completionPromise) {\n        boundPortObject.cancelled = true;\n      } else {\n        this.completeUnbind(boundPortObject);\n      }\n    }\n  }\n\n  /**\n   * Gracefully close all connections associated with a previously bound port.\n   * After the grace time, forcefully close all remaining open connections.\n   *\n   * If port 0 was bound, only the actual bound port can be\n   * drained. For example, if bindAsync was called with \"localhost:0\" and the\n   * bound port result was 54321, it can be drained as \"localhost:54321\".\n   * @param port\n   * @param graceTimeMs\n   * @returns\n   */\n  drain(port: string, graceTimeMs: number): void {\n    this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);\n    const portUri = this.normalizePort(port);\n    const splitPort = splitHostPort(portUri.path);\n    if (splitPort?.port === 0) {\n      throw new Error('Cannot drain port 0');\n    }\n    const boundPortObject = this.boundPorts.get(uriToString(portUri));\n    if (!boundPortObject) {\n      return;\n    }\n    const allSessions: Set<http2.Http2Session> = new Set();\n    for (const http2Server of boundPortObject.listeningServers) {\n      const serverEntry = this.http2Servers.get(http2Server);\n      if (serverEntry) {\n        for (const session of serverEntry.sessions) {\n          allSessions.add(session);\n          this.closeSession(session, () => {\n            allSessions.delete(session);\n          });\n        }\n      }\n    }\n    /* After the grace time ends, send another goaway to all remaining sessions\n     * with the CANCEL code. */\n    setTimeout(() => {\n      for (const session of allSessions) {\n        session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n      }\n    }, graceTimeMs).unref?.();\n  }\n\n  forceShutdown(): void {\n    for (const boundPortObject of this.boundPorts.values()) {\n      boundPortObject.cancelled = true;\n    }\n    this.boundPorts.clear();\n    // Close the server if it is still running.\n    for (const server of this.http2Servers.keys()) {\n      this.closeServer(server);\n    }\n\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      this.closeSession(session);\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n    });\n    this.sessions.clear();\n    unregisterChannelzRef(this.channelzRef);\n\n    this.shutdown = true;\n  }\n\n  register<RequestType, ResponseType>(\n    name: string,\n    handler: HandleCall<RequestType, ResponseType>,\n    serialize: Serialize<ResponseType>,\n    deserialize: Deserialize<RequestType>,\n    type: string\n  ): boolean {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name,\n    } as UntypedHandler);\n    return true;\n  }\n\n  unregister(name: string): boolean {\n    return this.handlers.delete(name);\n  }\n\n  /**\n   * @deprecated No longer needed as of version 1.10.x\n   */\n  @deprecate(\n    'Calling start() is no longer necessary. It can be safely omitted.'\n  )\n  start(): void {\n    if (\n      this.http2Servers.size === 0 ||\n      [...this.http2Servers.keys()].every(server => !server.listening)\n    ) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    this.started = true;\n  }\n\n  tryShutdown(callback: (error?: Error) => void): void {\n    const wrappedCallback = (error?: Error) => {\n      unregisterChannelzRef(this.channelzRef);\n      callback(error);\n    };\n    let pendingChecks = 0;\n\n    function maybeCallback(): void {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n    this.shutdown = true;\n\n    for (const [serverKey, server] of this.http2Servers.entries()) {\n      pendingChecks++;\n      const serverString = server.channelzRef.name;\n      this.trace('Waiting for server ' + serverString + ' to close');\n      this.closeServer(serverKey, () => {\n        this.trace('Server ' + serverString + ' finished closing');\n        maybeCallback();\n      });\n\n      for (const session of server.sessions.keys()) {\n        pendingChecks++;\n        const sessionString = session.socket?.remoteAddress;\n        this.trace('Waiting for session ' + sessionString + ' to close');\n        this.closeSession(session, () => {\n          this.trace('Session ' + sessionString + ' finished closing');\n          maybeCallback();\n        });\n      }\n    }\n\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n\n  addHttp2Port(): never {\n    throw new Error('Not yet implemented');\n  }\n\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  private _verifyContentType(\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ): boolean {\n    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n    if (\n      typeof contentType !== 'string' ||\n      !contentType.startsWith('application/grpc')\n    ) {\n      stream.respond(\n        {\n          [http2.constants.HTTP2_HEADER_STATUS]:\n            http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n        },\n        { endStream: true }\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  private _retrieveHandler(path: string): Handler<any, any> | null {\n    serverCallTrace(\n      'Received call to method ' +\n        path +\n        ' at address ' +\n        this.serverAddressString\n    );\n\n    const handler = this.handlers.get(path);\n\n    if (handler === undefined) {\n      serverCallTrace(\n        'No handler registered for method ' +\n          path +\n          '. Sending UNIMPLEMENTED status.'\n      );\n      return null;\n    }\n\n    return handler;\n  }\n\n  private _respondWithError(\n    err: PartialStatusObject,\n    stream: http2.ServerHttp2Stream,\n    channelzSessionInfo: ChannelzSessionInfo | null = null\n  ) {\n    const trailersToSend = {\n      'grpc-status': err.code ?? Status.INTERNAL,\n      'grpc-message': err.details,\n      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n      ...err.metadata?.toHttp2Headers(),\n    };\n    stream.respond(trailersToSend, { endStream: true });\n\n    this.callTracker.addCallFailed();\n    channelzSessionInfo?.streamTracker.addCallFailed();\n  }\n\n  private _channelzHandler(\n    extraInterceptors: ServerInterceptor[],\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ) {\n    // for handling idle timeout\n    this.onStreamOpened(stream);\n\n    const channelzSessionInfo = this.sessions.get(\n      stream.session as http2.ServerHttp2Session\n    );\n\n    this.callTracker.addCallStarted();\n    channelzSessionInfo?.streamTracker.addCallStarted();\n\n    if (!this._verifyContentType(stream, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n      return;\n    }\n\n    const path = headers[HTTP2_HEADER_PATH] as string;\n\n    const handler = this._retrieveHandler(path);\n    if (!handler) {\n      this._respondWithError(\n        getUnimplementedStatusResponse(path),\n        stream,\n        channelzSessionInfo\n      );\n      return;\n    }\n\n    const callEventTracker: CallEventTracker = {\n      addMessageSent: () => {\n        if (channelzSessionInfo) {\n          channelzSessionInfo.messagesSent += 1;\n          channelzSessionInfo.lastMessageSentTimestamp = new Date();\n        }\n      },\n      addMessageReceived: () => {\n        if (channelzSessionInfo) {\n          channelzSessionInfo.messagesReceived += 1;\n          channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n        }\n      },\n      onCallEnd: status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      },\n      onStreamEnd: success => {\n        if (channelzSessionInfo) {\n          if (success) {\n            channelzSessionInfo.streamTracker.addCallSucceeded();\n          } else {\n            channelzSessionInfo.streamTracker.addCallFailed();\n          }\n        }\n      },\n    };\n\n    const call = getServerInterceptingCall(\n      [...extraInterceptors, ...this.interceptors],\n      stream,\n      headers,\n      callEventTracker,\n      handler,\n      this.options\n    );\n\n    if (!this._runHandlerForCall(call, handler)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n\n      call.sendStatus({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`,\n      });\n    }\n  }\n\n  private _streamHandler(\n    extraInterceptors: ServerInterceptor[],\n    stream: http2.ServerHttp2Stream,\n    headers: http2.IncomingHttpHeaders\n  ) {\n    // for handling idle timeout\n    this.onStreamOpened(stream);\n\n    if (this._verifyContentType(stream, headers) !== true) {\n      return;\n    }\n\n    const path = headers[HTTP2_HEADER_PATH] as string;\n\n    const handler = this._retrieveHandler(path);\n    if (!handler) {\n      this._respondWithError(\n        getUnimplementedStatusResponse(path),\n        stream,\n        null\n      );\n      return;\n    }\n\n    const call = getServerInterceptingCall(\n      [...extraInterceptors, ...this.interceptors],\n      stream,\n      headers,\n      null,\n      handler,\n      this.options\n    );\n\n    if (!this._runHandlerForCall(call, handler)) {\n      call.sendStatus({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`,\n      });\n    }\n  }\n\n  private _runHandlerForCall(\n    call: ServerInterceptingCallInterface,\n    handler:\n      | UntypedUnaryHandler\n      | UntypedClientStreamingHandler\n      | UntypedServerStreamingHandler\n      | UntypedBidiStreamingHandler\n  ): boolean {\n    const { type } = handler;\n    if (type === 'unary') {\n      handleUnary(call, handler);\n    } else if (type === 'clientStream') {\n      handleClientStreaming(call, handler);\n    } else if (type === 'serverStream') {\n      handleServerStreaming(call, handler);\n    } else if (type === 'bidi') {\n      handleBidiStreaming(call, handler);\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _setupHandlers(\n    http2Server: http2.Http2Server | http2.Http2SecureServer,\n    extraInterceptors: ServerInterceptor[]\n  ): void {\n    if (http2Server === null) {\n      return;\n    }\n\n    const serverAddress = http2Server.address();\n    let serverAddressString = 'null';\n    if (serverAddress) {\n      if (typeof serverAddress === 'string') {\n        serverAddressString = serverAddress;\n      } else {\n        serverAddressString = serverAddress.address + ':' + serverAddress.port;\n      }\n    }\n    this.serverAddressString = serverAddressString;\n\n    const handler = this.channelzEnabled\n      ? this._channelzHandler\n      : this._streamHandler;\n\n    const sessionHandler = this.channelzEnabled\n      ? this._channelzSessionHandler(http2Server)\n      : this._sessionHandler(http2Server);\n\n    http2Server.on('stream', handler.bind(this, extraInterceptors));\n    http2Server.on('session', sessionHandler);\n  }\n\n  private _sessionHandler(\n    http2Server: http2.Http2Server | http2.Http2SecureServer\n  ) {\n    return (session: http2.ServerHttp2Session) => {\n      this.http2Servers.get(http2Server)?.sessions.add(session);\n\n      let connectionAgeTimer: NodeJS.Timeout | null = null;\n      let connectionAgeGraceTimer: NodeJS.Timeout | null = null;\n      let keepaliveTimer: NodeJS.Timeout | null = null;\n      let sessionClosedByServer = false;\n\n      const idleTimeoutObj = this.enableIdleTimeout(session);\n\n      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n        // Apply a random jitter within a +/-10% range\n        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n\n        connectionAgeTimer = setTimeout(() => {\n          sessionClosedByServer = true;\n\n          this.trace(\n            'Connection dropped by max connection age: ' +\n              session.socket?.remoteAddress\n          );\n\n          try {\n            session.goaway(\n              http2.constants.NGHTTP2_NO_ERROR,\n              ~(1 << 31),\n              kMaxAge\n            );\n          } catch (e) {\n            // The goaway can't be sent because the session is already closed\n            session.destroy();\n            return;\n          }\n          session.close();\n\n          /* Allow a grace period after sending the GOAWAY before forcibly\n           * closing the connection. */\n          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n            connectionAgeGraceTimer = setTimeout(() => {\n              session.destroy();\n            }, this.maxConnectionAgeGraceMs);\n            connectionAgeGraceTimer.unref?.();\n          }\n        }, this.maxConnectionAgeMs + jitter);\n        connectionAgeTimer.unref?.();\n      }\n\n      const clearKeepaliveTimeout = () => {\n        if (keepaliveTimer) {\n          clearTimeout(keepaliveTimer);\n          keepaliveTimer = null;\n        }\n      };\n\n      const canSendPing = () => {\n        return (\n          !session.destroyed &&\n          this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\n          this.keepaliveTimeMs > 0\n        );\n      };\n\n      /* eslint-disable-next-line prefer-const */\n      let sendPing: () => void; // hoisted for use in maybeStartKeepalivePingTimer\n\n      const maybeStartKeepalivePingTimer = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n        );\n        keepaliveTimer = setTimeout(() => {\n          clearKeepaliveTimeout();\n          sendPing();\n        }, this.keepaliveTimeMs);\n        keepaliveTimer.unref?.();\n      };\n\n      sendPing = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n        );\n        let pingSendError = '';\n        try {\n          const pingSentSuccessfully = session.ping(\n            (err: Error | null, duration: number, payload: Buffer) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            }\n          );\n          if (!pingSentSuccessfully) {\n            pingSendError = 'Ping returned false';\n          }\n        } catch (e) {\n          // grpc/grpc-node#2139\n          pingSendError =\n            (e instanceof Error ? e.message : '') || 'Unknown error';\n        }\n\n        if (pingSendError) {\n          this.keepaliveTrace('Ping send failed: ' + pingSendError);\n          this.trace(\n            'Connection dropped due to ping send error: ' + pingSendError\n          );\n          sessionClosedByServer = true;\n          session.close();\n          return;\n        }\n\n        keepaliveTimer = setTimeout(() => {\n          clearKeepaliveTimeout();\n          this.keepaliveTrace('Ping timeout passed without response');\n          this.trace('Connection dropped by keepalive timeout');\n          sessionClosedByServer = true;\n          session.close();\n        }, this.keepaliveTimeoutMs);\n        keepaliveTimer.unref?.();\n      };\n\n      maybeStartKeepalivePingTimer();\n\n      session.on('close', () => {\n        if (!sessionClosedByServer) {\n          this.trace(\n            `Connection dropped by client ${session.socket?.remoteAddress}`\n          );\n        }\n\n        if (connectionAgeTimer) {\n          clearTimeout(connectionAgeTimer);\n        }\n\n        if (connectionAgeGraceTimer) {\n          clearTimeout(connectionAgeGraceTimer);\n        }\n\n        clearKeepaliveTimeout();\n\n        if (idleTimeoutObj !== null) {\n          clearTimeout(idleTimeoutObj.timeout);\n          this.sessionIdleTimeouts.delete(session);\n        }\n\n        this.http2Servers.get(http2Server)?.sessions.delete(session);\n      });\n    };\n  }\n\n  private _channelzSessionHandler(\n    http2Server: http2.Http2Server | http2.Http2SecureServer\n  ) {\n    return (session: http2.ServerHttp2Session) => {\n      const channelzRef = registerChannelzSocket(\n        session.socket?.remoteAddress ?? 'unknown',\n        this.getChannelzSessionInfo.bind(this, session),\n        this.channelzEnabled\n      );\n\n      const channelzSessionInfo: ChannelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        keepAlivesSent: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null,\n      };\n\n      this.http2Servers.get(http2Server)?.sessions.add(session);\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\n\n      this.channelzTrace.addTrace(\n        'CT_INFO',\n        'Connection established by client ' + clientAddress\n      );\n      this.trace('Connection established by client ' + clientAddress);\n      this.sessionChildrenTracker.refChild(channelzRef);\n\n      let connectionAgeTimer: NodeJS.Timeout | null = null;\n      let connectionAgeGraceTimer: NodeJS.Timeout | null = null;\n      let keepaliveTimeout: NodeJS.Timeout | null = null;\n      let sessionClosedByServer = false;\n\n      const idleTimeoutObj = this.enableIdleTimeout(session);\n\n      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n        // Apply a random jitter within a +/-10% range\n        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n\n        connectionAgeTimer = setTimeout(() => {\n          sessionClosedByServer = true;\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped by max connection age from ' + clientAddress\n          );\n\n          try {\n            session.goaway(\n              http2.constants.NGHTTP2_NO_ERROR,\n              ~(1 << 31),\n              kMaxAge\n            );\n          } catch (e) {\n            // The goaway can't be sent because the session is already closed\n            session.destroy();\n            return;\n          }\n          session.close();\n\n          /* Allow a grace period after sending the GOAWAY before forcibly\n           * closing the connection. */\n          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n            connectionAgeGraceTimer = setTimeout(() => {\n              session.destroy();\n            }, this.maxConnectionAgeGraceMs);\n            connectionAgeGraceTimer.unref?.();\n          }\n        }, this.maxConnectionAgeMs + jitter);\n        connectionAgeTimer.unref?.();\n      }\n\n      const clearKeepaliveTimeout = () => {\n        if (keepaliveTimeout) {\n          clearTimeout(keepaliveTimeout);\n          keepaliveTimeout = null;\n        }\n      };\n\n      const canSendPing = () => {\n        return (\n          !session.destroyed &&\n          this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\n          this.keepaliveTimeMs > 0\n        );\n      };\n\n      /* eslint-disable-next-line prefer-const */\n      let sendPing: () => void; // hoisted for use in maybeStartKeepalivePingTimer\n\n      const maybeStartKeepalivePingTimer = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n        );\n        keepaliveTimeout = setTimeout(() => {\n          clearKeepaliveTimeout();\n          sendPing();\n        }, this.keepaliveTimeMs);\n        keepaliveTimeout.unref?.();\n      };\n\n      sendPing = () => {\n        if (!canSendPing()) {\n          return;\n        }\n        this.keepaliveTrace(\n          'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n        );\n        let pingSendError = '';\n        try {\n          const pingSentSuccessfully = session.ping(\n            (err: Error | null, duration: number, payload: Buffer) => {\n              clearKeepaliveTimeout();\n              if (err) {\n                this.keepaliveTrace('Ping failed with error: ' + err.message);\n                this.channelzTrace.addTrace(\n                  'CT_INFO',\n                  'Connection dropped due to error of a ping frame ' +\n                    err.message +\n                    ' return in ' +\n                    duration\n                );\n                sessionClosedByServer = true;\n                session.close();\n              } else {\n                this.keepaliveTrace('Received ping response');\n                maybeStartKeepalivePingTimer();\n              }\n            }\n          );\n          if (!pingSentSuccessfully) {\n            pingSendError = 'Ping returned false';\n          }\n        } catch (e) {\n          // grpc/grpc-node#2139\n          pingSendError =\n            (e instanceof Error ? e.message : '') || 'Unknown error';\n        }\n\n        if (pingSendError) {\n          this.keepaliveTrace('Ping send failed: ' + pingSendError);\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped due to ping send error: ' + pingSendError\n          );\n          sessionClosedByServer = true;\n          session.close();\n          return;\n        }\n\n        channelzSessionInfo.keepAlivesSent += 1;\n\n        keepaliveTimeout = setTimeout(() => {\n          clearKeepaliveTimeout();\n          this.keepaliveTrace('Ping timeout passed without response');\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped by keepalive timeout from ' + clientAddress\n          );\n          sessionClosedByServer = true;\n          session.close();\n        }, this.keepaliveTimeoutMs);\n        keepaliveTimeout.unref?.();\n      };\n\n      maybeStartKeepalivePingTimer();\n\n      session.on('close', () => {\n        if (!sessionClosedByServer) {\n          this.channelzTrace.addTrace(\n            'CT_INFO',\n            'Connection dropped by client ' + clientAddress\n          );\n        }\n\n        this.sessionChildrenTracker.unrefChild(channelzRef);\n        unregisterChannelzRef(channelzRef);\n\n        if (connectionAgeTimer) {\n          clearTimeout(connectionAgeTimer);\n        }\n\n        if (connectionAgeGraceTimer) {\n          clearTimeout(connectionAgeGraceTimer);\n        }\n\n        clearKeepaliveTimeout();\n\n        if (idleTimeoutObj !== null) {\n          clearTimeout(idleTimeoutObj.timeout);\n          this.sessionIdleTimeouts.delete(session);\n        }\n\n        this.http2Servers.get(http2Server)?.sessions.delete(session);\n        this.sessions.delete(session);\n      });\n    };\n  }\n\n  private enableIdleTimeout(\n    session: http2.ServerHttp2Session\n  ): SessionIdleTimeoutTracker | null {\n    if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {\n      return null;\n    }\n\n    const idleTimeoutObj: SessionIdleTimeoutTracker = {\n      activeStreams: 0,\n      lastIdle: Date.now(),\n      onClose: this.onStreamClose.bind(this, session),\n      timeout: setTimeout(\n        this.onIdleTimeout,\n        this.sessionIdleTimeout,\n        this,\n        session\n      ),\n    };\n    idleTimeoutObj.timeout.unref?.();\n    this.sessionIdleTimeouts.set(session, idleTimeoutObj);\n\n    const { socket } = session;\n    this.trace(\n      'Enable idle timeout for ' +\n        socket.remoteAddress +\n        ':' +\n        socket.remotePort\n    );\n\n    return idleTimeoutObj;\n  }\n\n  private onIdleTimeout(\n    this: undefined,\n    ctx: Server,\n    session: http2.ServerHttp2Session\n  ) {\n    const { socket } = session;\n    const sessionInfo = ctx.sessionIdleTimeouts.get(session);\n\n    // if it is called while we have activeStreams - timer will not be rescheduled\n    // until last active stream is closed, then it will call .refresh() on the timer\n    // important part is to not clearTimeout(timer) or it becomes unusable\n    // for future refreshes\n    if (\n      sessionInfo !== undefined &&\n      sessionInfo.activeStreams === 0\n    ) {\n      if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {\n        ctx.trace(\n          'Session idle timeout triggered for ' +\n            socket?.remoteAddress +\n            ':' +\n            socket?.remotePort +\n            ' last idle at ' +\n            sessionInfo.lastIdle\n        );\n\n        ctx.closeSession(session);\n      } else {\n        sessionInfo.timeout.refresh();\n      }\n    }\n  }\n\n  private onStreamOpened(stream: http2.ServerHttp2Stream) {\n    const session = stream.session as http2.ServerHttp2Session;\n\n    const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n    if (idleTimeoutObj) {\n      idleTimeoutObj.activeStreams += 1;\n      stream.once('close', idleTimeoutObj.onClose);\n    }\n  }\n\n  private onStreamClose(session: http2.ServerHttp2Session) {\n    const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\n\n    if (idleTimeoutObj) {\n      idleTimeoutObj.activeStreams -= 1;\n      if (idleTimeoutObj.activeStreams === 0) {\n        idleTimeoutObj.lastIdle = Date.now();\n        idleTimeoutObj.timeout.refresh();\n\n        this.trace(\n          'Session onStreamClose' +\n            session.socket?.remoteAddress +\n            ':' +\n            session.socket?.remotePort +\n            ' at ' +\n            idleTimeoutObj.lastIdle\n        );\n      }\n    }\n  }\n}\n\nasync function handleUnary<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: UnaryHandler<RequestType, ResponseType>\n): Promise<void> {\n  let stream: ServerUnaryCall<RequestType, ResponseType>;\n\n  function respond(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    trailer?: Metadata,\n    flags?: number\n  ) {\n    if (err) {\n      call.sendStatus(serverErrorToStatus(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: Status.OK,\n        details: 'OK',\n        metadata: trailer ?? null,\n      });\n    });\n  }\n\n  let requestMetadata: Metadata;\n  let requestMessage: RequestType | null = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      stream = new ServerWritableStreamImpl(\n        handler.path,\n        call,\n        requestMetadata,\n        requestMessage\n      );\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n      }\n    },\n  });\n}\n\nfunction handleClientStreaming<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: ClientStreamingHandler<RequestType, ResponseType>\n): void {\n  let stream: ServerReadableStream<RequestType, ResponseType>;\n\n  function respond(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    trailer?: Metadata,\n    flags?: number\n  ) {\n    if (err) {\n      call.sendStatus(serverErrorToStatus(err, trailer));\n      return;\n    }\n    call.sendMessage(value, () => {\n      call.sendStatus({\n        code: Status.OK,\n        details: 'OK',\n        metadata: trailer ?? null,\n      });\n    });\n  }\n\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream, respond);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    },\n  });\n}\n\nfunction handleServerStreaming<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: ServerStreamingHandler<RequestType, ResponseType>\n): void {\n  let stream: ServerWritableStream<RequestType, ResponseType>;\n\n  let requestMetadata: Metadata;\n  let requestMessage: RequestType | null = null;\n  call.start({\n    onReceiveMetadata(metadata) {\n      requestMetadata = metadata;\n      call.startRead();\n    },\n    onReceiveMessage(message) {\n      if (requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received a second request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      requestMessage = message;\n      call.startRead();\n    },\n    onReceiveHalfClose() {\n      if (!requestMessage) {\n        call.sendStatus({\n          code: Status.UNIMPLEMENTED,\n          details: `Received no request message for server streaming method ${handler.path}`,\n          metadata: null,\n        });\n        return;\n      }\n      stream = new ServerWritableStreamImpl(\n        handler.path,\n        call,\n        requestMetadata,\n        requestMessage\n      );\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    },\n  });\n}\n\nfunction handleBidiStreaming<RequestType, ResponseType>(\n  call: ServerInterceptingCallInterface,\n  handler: BidiStreamingHandler<RequestType, ResponseType>\n): void {\n  let stream: ServerDuplexStream<RequestType, ResponseType>;\n\n  call.start({\n    onReceiveMetadata(metadata) {\n      stream = new ServerDuplexStreamImpl(handler.path, call, metadata);\n      try {\n        handler.func(stream);\n      } catch (err) {\n        call.sendStatus({\n          code: Status.UNKNOWN,\n          details: `Server method handler threw error ${\n            (err as Error).message\n          }`,\n          metadata: null,\n        });\n      }\n    },\n    onReceiveMessage(message) {\n      stream.push(message);\n    },\n    onReceiveHalfClose() {\n      stream.push(null);\n    },\n    onCancel() {\n      if (stream) {\n        stream.cancelled = true;\n        stream.emit('cancelled', 'cancelled');\n        stream.destroy();\n      }\n    },\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}