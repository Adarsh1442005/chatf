{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst constants_1 = require(\"./constants\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'backoff';\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    /**\n     * The delay time at the start, and after each reset.\n     */\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    /**\n     * The exponential backoff multiplier.\n     */\n    this.multiplier = BACKOFF_MULTIPLIER;\n    /**\n     * The maximum delay time\n     */\n    this.maxDelay = MAX_BACKOFF_MS;\n    /**\n     * The maximum fraction by which the delay time can randomly vary after\n     * applying the multiplier.\n     */\n    this.jitter = BACKOFF_JITTER;\n    /**\n     * Indicates whether the timer is currently running.\n     */\n    this.running = false;\n    /**\n     * Indicates whether the timer should keep the Node process running if no\n     * other async operation is doing so.\n     */\n    this.hasRef = true;\n    /**\n     * The time that the currently running timer was started. Only valid if\n     * running is true.\n     */\n    this.startTime = new Date();\n    /**\n     * The approximate time that the currently running timer will end. Only valid\n     * if running is true.\n     */\n    this.endTime = new Date();\n    this.id = BackoffTimeout.getNextId();\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.trace('constructed initialDelay=' + this.initialDelay + ' multiplier=' + this.multiplier + ' jitter=' + this.jitter + ' maxDelay=' + this.maxDelay);\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n  static getNextId() {\n    return this.nextId++;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '{' + this.id + '} ' + text);\n  }\n  runTimer(delay) {\n    var _a, _b;\n    this.trace('runTimer(delay=' + delay + ')');\n    this.endTime = this.startTime;\n    this.endTime.setMilliseconds(this.endTime.getMilliseconds() + delay);\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.trace('timer fired');\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.trace('runOnce()');\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    this.trace('stop()');\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.trace('reset() running=' + this.running);\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    var _a, _b;\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    var _a, _b;\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Get the approximate timestamp of when the timer will fire. Only valid if\n   * this.isRunning() is true.\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n}\nexports.BackoffTimeout = BackoffTimeout;\nBackoffTimeout.nextId = 0;","map":{"version":3,"names":["constants_1","require","logging","TRACER_NAME","INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","uniformRandom","min","max","Math","random","BackoffTimeout","constructor","callback","options","initialDelay","multiplier","maxDelay","jitter","running","hasRef","startTime","Date","endTime","id","getNextId","trace","nextDelay","timerId","setTimeout","clearTimeout","nextId","text","LogVerbosity","DEBUG","runTimer","delay","setMilliseconds","getMilliseconds","_b","_a","unref","call","runOnce","nextBackoff","jitterMagnitude","stop","reset","now","newEndTime","getTime","isRunning","ref","getEndTime","exports"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\backoff-timeout.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { LogVerbosity } from './constants';\nimport * as logging from './logging';\n\nconst TRACER_NAME = 'backoff';\n\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nexport interface BackoffOptions {\n  initialDelay?: number;\n  multiplier?: number;\n  jitter?: number;\n  maxDelay?: number;\n}\n\nexport class BackoffTimeout {\n  /**\n   * The delay time at the start, and after each reset.\n   */\n  private readonly initialDelay: number = INITIAL_BACKOFF_MS;\n  /**\n   * The exponential backoff multiplier.\n   */\n  private readonly multiplier: number = BACKOFF_MULTIPLIER;\n  /**\n   * The maximum delay time\n   */\n  private readonly maxDelay: number = MAX_BACKOFF_MS;\n  /**\n   * The maximum fraction by which the delay time can randomly vary after\n   * applying the multiplier.\n   */\n  private readonly jitter: number = BACKOFF_JITTER;\n  /**\n   * The delay time for the next time the timer runs.\n   */\n  private nextDelay: number;\n  /**\n   * The handle of the underlying timer. If running is false, this value refers\n   * to an object representing a timer that has ended, but it can still be\n   * interacted with without error.\n   */\n  private timerId: NodeJS.Timeout;\n  /**\n   * Indicates whether the timer is currently running.\n   */\n  private running = false;\n  /**\n   * Indicates whether the timer should keep the Node process running if no\n   * other async operation is doing so.\n   */\n  private hasRef = true;\n  /**\n   * The time that the currently running timer was started. Only valid if\n   * running is true.\n   */\n  private startTime: Date = new Date();\n  /**\n   * The approximate time that the currently running timer will end. Only valid\n   * if running is true.\n   */\n  private endTime: Date = new Date();\n\n  private id: number;\n\n  private static nextId = 0;\n\n  constructor(private callback: () => void, options?: BackoffOptions) {\n    this.id = BackoffTimeout.getNextId();\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.trace('constructed initialDelay=' + this.initialDelay + ' multiplier=' + this.multiplier + ' jitter=' + this.jitter + ' maxDelay=' + this.maxDelay);\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  private static getNextId() {\n    return this.nextId++;\n  }\n\n  private trace(text: string) {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '{' + this.id + '} ' + text);\n  }\n\n  private runTimer(delay: number) {\n    this.trace('runTimer(delay=' + delay + ')');\n    this.endTime = this.startTime;\n    this.endTime.setMilliseconds(\n      this.endTime.getMilliseconds() + delay\n    );\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.trace('timer fired');\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      this.timerId.unref?.();\n    }\n  }\n\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.trace('runOnce()');\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(\n      this.nextDelay * this.multiplier,\n      this.maxDelay\n    );\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay =\n      nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    this.trace('stop()');\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.trace('reset() running=' + this.running);\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    this.hasRef = true;\n    this.timerId.ref?.();\n  }\n\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    this.hasRef = false;\n    this.timerId.unref?.();\n  }\n\n  /**\n   * Get the approximate timestamp of when the timer will fire. Only valid if\n   * this.isRunning() is true.\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}