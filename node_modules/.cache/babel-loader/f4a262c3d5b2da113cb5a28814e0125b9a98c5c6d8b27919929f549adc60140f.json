{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamProxy = exports.StreamType = void 0;\nconst gax_1 = require(\"../gax\");\nconst googleError_1 = require(\"../googleError\");\nconst status_1 = require(\"../status\");\nconst stream_1 = require(\"stream\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst retryRequest = require('retry-request');\n/**\n * The type of gRPC streaming.\n * @enum {number}\n */\nvar StreamType;\n(function (StreamType) {\n  /** Client sends a single request, server streams responses. */\n  StreamType[StreamType[\"SERVER_STREAMING\"] = 1] = \"SERVER_STREAMING\";\n  /** Client streams requests, server returns a single response. */\n  StreamType[StreamType[\"CLIENT_STREAMING\"] = 2] = \"CLIENT_STREAMING\";\n  /** Both client and server stream objects. */\n  StreamType[StreamType[\"BIDI_STREAMING\"] = 3] = \"BIDI_STREAMING\";\n})(StreamType || (exports.StreamType = StreamType = {}));\n// In retry-request, you could pass parameters to request using the requestOpts parameter\n// when we called retry-request from gax, we always passed null\n// passing null here removes an unnecessary parameter from this implementation\nconst requestOps = null;\nclass StreamProxy extends duplexify {\n  type;\n  _callback;\n  _isCancelCalled;\n  stream;\n  _responseHasSent;\n  rest;\n  gaxServerStreamingRetries;\n  apiCall;\n  argument;\n  /**\n   * StreamProxy is a proxy to gRPC-streaming method.\n   *\n   * @private\n   * @constructor\n   * @param {StreamType} type - the type of gRPC stream.\n   * @param {ApiCallback} callback - the callback for further API call.\n   */\n  constructor(type, callback, rest, gaxServerStreamingRetries) {\n    super(undefined, undefined, {\n      objectMode: true,\n      readable: type !== StreamType.CLIENT_STREAMING,\n      writable: type !== StreamType.SERVER_STREAMING\n    });\n    this.type = type;\n    this._callback = callback;\n    this._isCancelCalled = false;\n    this._responseHasSent = false;\n    this.rest = rest;\n    this.gaxServerStreamingRetries = gaxServerStreamingRetries;\n  }\n  shouldRetryRequest(error, retry) {\n    const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    let shouldRetry = this.defaultShouldRetry(e, retry);\n    if (retry.shouldRetryFn) {\n      shouldRetry = retry.shouldRetryFn(e);\n    }\n    return shouldRetry;\n  }\n  cancel() {\n    if (this.stream) {\n      this.stream.cancel();\n    } else {\n      this._isCancelCalled = true;\n    }\n  }\n  /**\n   * Helper function to handle total timeout + max retry check for server streaming retries\n   * @param {number} deadline - the current retry deadline\n   * @param {number} maxRetries - maximum total number of retries\n   * @param {number} totalTimeoutMillis - total timeout in milliseconds used in timeout calculation\n   * @param {GoogleError} originalError - underlying error received by the stream\n   * @param {originalTimeout} originalTimeout - the original Timeout set in backoff settings\n   * @param {retries} retries - the number of retries the call has made so far\n   */\n  throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis, originalError, originalTimeout, retries) {\n    const now = new Date();\n    const nowTime = now.getTime();\n    if (originalTimeout && (totalTimeoutMillis === 0 || totalTimeoutMillis < 0 || deadline && nowTime >= deadline)) {\n      const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${originalTimeout} milliseconds ${originalError ? `retrying error ${originalError} ` : ''} before any response was received.`);\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      throw error;\n    }\n    if (maxRetries === 0) {\n      const error = originalError;\n      error.note = 'Max retries is set to zero.';\n      throw error;\n    }\n    if (retries && retries >= maxRetries) {\n      const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' + (originalError ? `retrying error ${originalError} ` : '') + 'before any response was received');\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      throw error;\n    }\n  }\n  /**\n   * Forwards events from an API request stream to the user's stream.\n   * @param {Stream} stream - The API request stream.\n   */\n  eventForwardHelper(stream) {\n    const eventsToForward = ['metadata', 'response', 'status'];\n    eventsToForward.forEach(event => {\n      stream.on(event, this.emit.bind(this, event));\n    });\n  }\n  /**\n   * Helper function that emits a response on the stream after either a 'metadata'\n   * or a 'status' event - this helps streams to behave more like http consumers expect\n   * @param {Stream} stream - The API request stream.\n   */\n  statusMetadataHelper(stream) {\n    // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n    // Emit the 'response' event if stream has no 'metadata' event.\n    // This avoids the stream swallowing the other events, such as 'end'.\n    stream.on('status', () => {\n      if (!this._responseHasSent) {\n        stream.emit('response', {\n          code: 200,\n          details: '',\n          message: 'OK'\n        });\n      }\n    });\n    // We also want to supply the status data as 'response' event to support\n    // the behavior of google-cloud-node expects.\n    // see:\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n    stream.on('metadata', metadata => {\n      // Create a response object with succeeds.\n      // TODO: unify this logic with the decoration of gRPC response when it's\n      // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n      stream.emit('response', {\n        code: 200,\n        details: '',\n        message: 'OK',\n        metadata\n      });\n      this._responseHasSent = true;\n    });\n  }\n  /**\n   * Forward events from an API request stream to the user's stream.\n   *  gRPC is guaranteed emit the 'status' event but not 'metadata'\n   * 'status' is the last event to emit; if 'metadata' emits, it will\n   * be the first event to emit. It should only emit once; if it emits\n   * more than once, unexpected side effects will occur.\n   *\n   * @param {Stream} stream - The API request stream.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  forwardEvents(stream) {\n    this.eventForwardHelper(stream);\n    this.statusMetadataHelper(stream);\n    stream.on('error', error => {\n      googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    });\n  }\n  /**\n   * Default mechanism for determining whether a streaming call should retry\n   * If a user passes in a \"shouldRetryFn\", this will not be used\n   * @param {GoogleError} errpr - The error we need to determine is retryable or not\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  defaultShouldRetry(error, retry) {\n    if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(error.code) < 0 || retry.retryCodes.length === 0) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Specifies the target stream.\n   * @param {ApiCall} apiCall - the API function to be called.\n   * @param {Object} argument - the argument to be passed to the apiCall.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  setStream(apiCall, argument, retryRequestOptions = {}, retry) {\n    this.apiCall = apiCall;\n    this.argument = argument;\n    if (this.type === StreamType.SERVER_STREAMING) {\n      if (this.rest) {\n        const stream = apiCall(argument, this._callback);\n        this.stream = stream;\n        this.setReadable(stream);\n      } else if (this.gaxServerStreamingRetries) {\n        const request = () => {\n          if (this._isCancelCalled) {\n            if (this.stream) {\n              this.stream.cancel();\n            }\n            return;\n          }\n          const stream = apiCall(argument, this._callback);\n          return stream;\n        };\n        const retryStream = this.newStreamingRetryRequest({\n          request,\n          retry\n        });\n        this.stream = retryStream;\n        this.eventForwardHelper(retryStream);\n        this.setReadable(retryStream);\n      } else {\n        const retryStream = retryRequest(null, {\n          objectMode: true,\n          request: () => {\n            if (this._isCancelCalled) {\n              if (this.stream) {\n                this.stream.cancel();\n              }\n              return;\n            }\n            const stream = apiCall(argument, this._callback);\n            this.stream = stream;\n            this.forwardEvents(stream);\n            return stream;\n          },\n          retries: retryRequestOptions.retries,\n          currentRetryAttempt: retryRequestOptions.currentRetryAttempt,\n          noResponseRetries: retryRequestOptions.noResponseRetries,\n          shouldRetryFn: retryRequestOptions.shouldRetryFn\n        });\n        this.setReadable(retryStream);\n      }\n      return;\n    }\n    const stream = apiCall(argument, this._callback);\n    this.stream = stream;\n    this.forwardEvents(stream);\n    if (this.type === StreamType.CLIENT_STREAMING) {\n      this.setWritable(stream);\n    }\n    if (this.type === StreamType.BIDI_STREAMING) {\n      this.setReadable(stream);\n      this.setWritable(stream);\n    }\n    if (this._isCancelCalled && this.stream) {\n      this.stream.cancel();\n    }\n  }\n  /**\n   * Creates a new retry request stream -\n   *inner arrow function \"newMakeRequest\" handles retrying and resumption\n   * @param {streamingRetryRequestOptions} opts\n   *   {request} - the request to be made if the stream errors\n   *   {retry} - the retry options associated with the call\n   * @returns {CancellableStream} - the stream that handles retry logic\n   */\n  newStreamingRetryRequest(opts) {\n    // at this point, it would be unexpected if retry were undefined\n    // but if it is, provide a logical default so we don't run into trouble\n    const retry = opts.retry ?? {\n      retryCodes: [],\n      backoffSettings: (0, gax_1.createDefaultBackoffSettings)()\n    };\n    let retries = 0;\n    const retryStream = new stream_1.PassThrough({\n      objectMode: true\n    });\n    const totalTimeout = retry.backoffSettings.totalTimeoutMillis ?? undefined;\n    const maxRetries = retry.backoffSettings.maxRetries ?? undefined;\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis ?? undefined;\n    let now = new Date();\n    let deadline = 0;\n    if (totalTimeout) {\n      deadline = now.getTime() + totalTimeout;\n    }\n    const transientErrorHelper = (error, requestStream) => {\n      const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n      e.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n      // clean up the request stream and retryStreams, silently destroy it on the request stream\n      // but do raise it on destructin of the retryStream so the consumer can see it\n      requestStream.destroy();\n      retryStream.destroy(e);\n      return retryStream;\n    };\n    const newMakeRequest = newopts => {\n      let dataEnd = false;\n      let statusReceived = false;\n      let enteredError = false;\n      // make the request\n      const requestStream = newopts.request(requestOps);\n      retryStream.cancel = requestStream.cancel; // make sure the retryStream is also cancellable by the user\n      const eventsToForward = ['metadata', 'response', 'status'];\n      eventsToForward.forEach(event => {\n        requestStream.on(event, retryStream.emit.bind(retryStream, event));\n      });\n      this.statusMetadataHelper(requestStream);\n      // TODO - b/353262542 address buffer stuff\n      requestStream.on('data', data => {\n        retries = 0;\n        this.emit.bind(this, 'data')(data);\n      });\n      /* in retry-request, which previously handled retries,\n       * \"end\" could be emitted on a request stream before other gRPC events.\n       * To ensure it doesn't reach the consumer stream prematurely, retry-request piped\n       * two streams together (delayStream and retryStream)\n       * to ensure that \"end\" only emitted after a \"response\" event\n       *\n       * We are consciously NOT using pipeline or .pipe as part of similar logic here\n       * because we want more control over what happens during event handoff and we want to\n       * avoid the undesired behavior that can happen with error events\n       * if consumers in client libraries are also using pipes\n       *\n       * Since \"status\" is guaranteed to be the last event emitted by gRPC.\n       * If we have seen an \"end\" event, the dataEnd boolean will be true and we can safely\n       * end the stream.\n       *\n       * The \"statusReceived\" boolean covers the opposite case - that we receive the \"status\" event before\n       * a successful stream end event - this signals the .on('end') event handler that it's okay to end the stream\n       *\n       *\n       */\n      requestStream.on('status', () => {\n        statusReceived = true;\n        if (dataEnd) {\n          retryStream.end();\n        }\n        return retryStream;\n      });\n      requestStream.on('end', () => {\n        if (!enteredError) {\n          dataEnd = true;\n          // in this case, we've already received \"status\"\n          // which is the last event from gRPC, so it's cool to end the stream\n          if (statusReceived) {\n            retryStream.end();\n          }\n        }\n        return retryStream;\n        // there is no else case because if enteredError\n        // is true, we will handle stream destruction as part of\n        // either retrying (where we don't want to end the stream)\n        // or as part of error handling, which will take care of stream destruction\n      });\n      requestStream.on('error', error => {\n        enteredError = true;\n        // type check for undefined instead of for truthiness in case maxRetries or timeout is equal to zero\n        if (typeof maxRetries !== undefined || typeof totalTimeout !== undefined) {\n          if (this.shouldRetryRequest(error, retry)) {\n            if (maxRetries && totalTimeout) {\n              const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n              newError.code = status_1.Status.INVALID_ARGUMENT;\n              // clean up the request stream and retryStreams, silently destroy it on the request stream\n              // but do raise it on destructin of the retryStream so the consumer can see it\n              requestStream.destroy();\n              retryStream.destroy(newError);\n              return retryStream;\n            } else {\n              // check for exceeding timeout or max retries\n              try {\n                this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, timeout, error, totalTimeout, retries);\n              } catch (error) {\n                const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n                // clean up the request stream and retryStreams, silently destroy it on the request stream\n                // but do raise it on destruction of the retryStream so the consumer can see it\n                requestStream.destroy();\n                retryStream.destroy(e);\n                return retryStream;\n              }\n              const delayMult = retry.backoffSettings.retryDelayMultiplier;\n              const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n              const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n              const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n              let delay = retry.backoffSettings.initialRetryDelayMillis;\n              // calculate new deadlines\n              const toSleep = Math.random() * delay;\n              const calculateTimeoutAndResumptionFunction = () => {\n                setTimeout(() => {\n                  // only do timeout calculations if not using maxRetries\n                  if (timeout) {\n                    now = new Date();\n                    delay = Math.min(delay * delayMult, maxDelay);\n                    const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                    const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                    const newDeadline = deadline ? deadline - now.getTime() : 0;\n                    timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n                  }\n                  retries++;\n                  let retryArgument = this.argument;\n                  // if resumption logic is passed, use it to determined the\n                  // new argument for the new request made to the server\n                  // otherwise, the original argument will be passed\n                  if (retry.getResumptionRequestFn !== undefined) {\n                    retryArgument = retry.getResumptionRequestFn(retryArgument);\n                  }\n                  const newRequest = () => {\n                    if (this._isCancelCalled) {\n                      if (this.stream) {\n                        this.stream.cancel();\n                      }\n                      return;\n                    }\n                    const newStream = this.apiCall(retryArgument, this._callback);\n                    return newStream;\n                  };\n                  opts.request = newRequest;\n                  // make a request with the updated parameters\n                  // based on the resumption strategy\n                  return newMakeRequest(opts);\n                }, toSleep);\n              };\n              return calculateTimeoutAndResumptionFunction();\n            }\n          } else {\n            // non retryable error\n            return transientErrorHelper(error, requestStream);\n          }\n        } else {\n          // neither timeout nor maxRetries are defined, surface the error to the caller\n          return transientErrorHelper(error, requestStream);\n        }\n      });\n      // return the stream if we didn't return it as\n      // part of an error state\n      return retryStream;\n    };\n    // this is the first make request call with the options the user passed in\n    return newMakeRequest(opts);\n  }\n}\nexports.StreamProxy = StreamProxy;","map":{"version":3,"names":["Object","defineProperty","exports","value","StreamProxy","StreamType","gax_1","require","googleError_1","status_1","stream_1","duplexify","retryRequest","requestOps","type","_callback","_isCancelCalled","stream","_responseHasSent","rest","gaxServerStreamingRetries","apiCall","argument","constructor","callback","undefined","objectMode","readable","CLIENT_STREAMING","writable","SERVER_STREAMING","shouldRetryRequest","error","retry","e","GoogleError","parseGRPCStatusDetails","shouldRetry","defaultShouldRetry","shouldRetryFn","cancel","throwIfMaxRetriesOrTotalTimeoutExceeded","deadline","maxRetries","totalTimeoutMillis","originalError","originalTimeout","retries","now","Date","nowTime","getTime","code","Status","DEADLINE_EXCEEDED","note","eventForwardHelper","eventsToForward","forEach","event","on","emit","bind","statusMetadataHelper","details","message","metadata","forwardEvents","retryCodes","length","indexOf","setStream","retryRequestOptions","setReadable","request","retryStream","newStreamingRetryRequest","currentRetryAttempt","noResponseRetries","setWritable","BIDI_STREAMING","opts","backoffSettings","createDefaultBackoffSettings","PassThrough","totalTimeout","timeout","initialRpcTimeoutMillis","transientErrorHelper","requestStream","destroy","newMakeRequest","newopts","dataEnd","statusReceived","enteredError","data","end","newError","INVALID_ARGUMENT","delayMult","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","toSleep","Math","random","calculateTimeoutAndResumptionFunction","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","retryArgument","getResumptionRequestFn","newRequest","newStream"],"sources":["C:/Users/BIT/chatboot/node_modules/google-gax/build/src/streamingCalls/streaming.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamProxy = exports.StreamType = void 0;\nconst gax_1 = require(\"../gax\");\nconst googleError_1 = require(\"../googleError\");\nconst status_1 = require(\"../status\");\nconst stream_1 = require(\"stream\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst retryRequest = require('retry-request');\n/**\n * The type of gRPC streaming.\n * @enum {number}\n */\nvar StreamType;\n(function (StreamType) {\n    /** Client sends a single request, server streams responses. */\n    StreamType[StreamType[\"SERVER_STREAMING\"] = 1] = \"SERVER_STREAMING\";\n    /** Client streams requests, server returns a single response. */\n    StreamType[StreamType[\"CLIENT_STREAMING\"] = 2] = \"CLIENT_STREAMING\";\n    /** Both client and server stream objects. */\n    StreamType[StreamType[\"BIDI_STREAMING\"] = 3] = \"BIDI_STREAMING\";\n})(StreamType || (exports.StreamType = StreamType = {}));\n// In retry-request, you could pass parameters to request using the requestOpts parameter\n// when we called retry-request from gax, we always passed null\n// passing null here removes an unnecessary parameter from this implementation\nconst requestOps = null;\nclass StreamProxy extends duplexify {\n    type;\n    _callback;\n    _isCancelCalled;\n    stream;\n    _responseHasSent;\n    rest;\n    gaxServerStreamingRetries;\n    apiCall;\n    argument;\n    /**\n     * StreamProxy is a proxy to gRPC-streaming method.\n     *\n     * @private\n     * @constructor\n     * @param {StreamType} type - the type of gRPC stream.\n     * @param {ApiCallback} callback - the callback for further API call.\n     */\n    constructor(type, callback, rest, gaxServerStreamingRetries) {\n        super(undefined, undefined, {\n            objectMode: true,\n            readable: type !== StreamType.CLIENT_STREAMING,\n            writable: type !== StreamType.SERVER_STREAMING,\n        });\n        this.type = type;\n        this._callback = callback;\n        this._isCancelCalled = false;\n        this._responseHasSent = false;\n        this.rest = rest;\n        this.gaxServerStreamingRetries = gaxServerStreamingRetries;\n    }\n    shouldRetryRequest(error, retry) {\n        const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n        let shouldRetry = this.defaultShouldRetry(e, retry);\n        if (retry.shouldRetryFn) {\n            shouldRetry = retry.shouldRetryFn(e);\n        }\n        return shouldRetry;\n    }\n    cancel() {\n        if (this.stream) {\n            this.stream.cancel();\n        }\n        else {\n            this._isCancelCalled = true;\n        }\n    }\n    /**\n     * Helper function to handle total timeout + max retry check for server streaming retries\n     * @param {number} deadline - the current retry deadline\n     * @param {number} maxRetries - maximum total number of retries\n     * @param {number} totalTimeoutMillis - total timeout in milliseconds used in timeout calculation\n     * @param {GoogleError} originalError - underlying error received by the stream\n     * @param {originalTimeout} originalTimeout - the original Timeout set in backoff settings\n     * @param {retries} retries - the number of retries the call has made so far\n     */\n    throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis, originalError, originalTimeout, retries) {\n        const now = new Date();\n        const nowTime = now.getTime();\n        if (originalTimeout &&\n            (totalTimeoutMillis === 0 ||\n                totalTimeoutMillis < 0 ||\n                (deadline && nowTime >= deadline))) {\n            const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${originalTimeout} milliseconds ${originalError ? `retrying error ${originalError} ` : ''} before any response was received.`);\n            error.code = status_1.Status.DEADLINE_EXCEEDED;\n            throw error;\n        }\n        if (maxRetries === 0) {\n            const error = originalError;\n            error.note = 'Max retries is set to zero.';\n            throw error;\n        }\n        if (retries && retries >= maxRetries) {\n            const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' +\n                (originalError ? `retrying error ${originalError} ` : '') +\n                'before any response was received');\n            error.code = status_1.Status.DEADLINE_EXCEEDED;\n            throw error;\n        }\n    }\n    /**\n     * Forwards events from an API request stream to the user's stream.\n     * @param {Stream} stream - The API request stream.\n     */\n    eventForwardHelper(stream) {\n        const eventsToForward = ['metadata', 'response', 'status'];\n        eventsToForward.forEach(event => {\n            stream.on(event, this.emit.bind(this, event));\n        });\n    }\n    /**\n     * Helper function that emits a response on the stream after either a 'metadata'\n     * or a 'status' event - this helps streams to behave more like http consumers expect\n     * @param {Stream} stream - The API request stream.\n     */\n    statusMetadataHelper(stream) {\n        // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n        // Emit the 'response' event if stream has no 'metadata' event.\n        // This avoids the stream swallowing the other events, such as 'end'.\n        stream.on('status', () => {\n            if (!this._responseHasSent) {\n                stream.emit('response', {\n                    code: 200,\n                    details: '',\n                    message: 'OK',\n                });\n            }\n        });\n        // We also want to supply the status data as 'response' event to support\n        // the behavior of google-cloud-node expects.\n        // see:\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n        stream.on('metadata', metadata => {\n            // Create a response object with succeeds.\n            // TODO: unify this logic with the decoration of gRPC response when it's\n            // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n            stream.emit('response', {\n                code: 200,\n                details: '',\n                message: 'OK',\n                metadata,\n            });\n            this._responseHasSent = true;\n        });\n    }\n    /**\n     * Forward events from an API request stream to the user's stream.\n     *  gRPC is guaranteed emit the 'status' event but not 'metadata'\n     * 'status' is the last event to emit; if 'metadata' emits, it will\n     * be the first event to emit. It should only emit once; if it emits\n     * more than once, unexpected side effects will occur.\n     *\n     * @param {Stream} stream - The API request stream.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    forwardEvents(stream) {\n        this.eventForwardHelper(stream);\n        this.statusMetadataHelper(stream);\n        stream.on('error', error => {\n            googleError_1.GoogleError.parseGRPCStatusDetails(error);\n        });\n    }\n    /**\n     * Default mechanism for determining whether a streaming call should retry\n     * If a user passes in a \"shouldRetryFn\", this will not be used\n     * @param {GoogleError} errpr - The error we need to determine is retryable or not\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    defaultShouldRetry(error, retry) {\n        if ((retry.retryCodes.length > 0 &&\n            retry.retryCodes.indexOf(error.code) < 0) ||\n            retry.retryCodes.length === 0) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Specifies the target stream.\n     * @param {ApiCall} apiCall - the API function to be called.\n     * @param {Object} argument - the argument to be passed to the apiCall.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    setStream(apiCall, argument, retryRequestOptions = {}, retry) {\n        this.apiCall = apiCall;\n        this.argument = argument;\n        if (this.type === StreamType.SERVER_STREAMING) {\n            if (this.rest) {\n                const stream = apiCall(argument, this._callback);\n                this.stream = stream;\n                this.setReadable(stream);\n            }\n            else if (this.gaxServerStreamingRetries) {\n                const request = () => {\n                    if (this._isCancelCalled) {\n                        if (this.stream) {\n                            this.stream.cancel();\n                        }\n                        return;\n                    }\n                    const stream = apiCall(argument, this._callback);\n                    return stream;\n                };\n                const retryStream = this.newStreamingRetryRequest({ request, retry });\n                this.stream = retryStream;\n                this.eventForwardHelper(retryStream);\n                this.setReadable(retryStream);\n            }\n            else {\n                const retryStream = retryRequest(null, {\n                    objectMode: true,\n                    request: () => {\n                        if (this._isCancelCalled) {\n                            if (this.stream) {\n                                this.stream.cancel();\n                            }\n                            return;\n                        }\n                        const stream = apiCall(argument, this._callback);\n                        this.stream = stream;\n                        this.forwardEvents(stream);\n                        return stream;\n                    },\n                    retries: retryRequestOptions.retries,\n                    currentRetryAttempt: retryRequestOptions.currentRetryAttempt,\n                    noResponseRetries: retryRequestOptions.noResponseRetries,\n                    shouldRetryFn: retryRequestOptions.shouldRetryFn,\n                });\n                this.setReadable(retryStream);\n            }\n            return;\n        }\n        const stream = apiCall(argument, this._callback);\n        this.stream = stream;\n        this.forwardEvents(stream);\n        if (this.type === StreamType.CLIENT_STREAMING) {\n            this.setWritable(stream);\n        }\n        if (this.type === StreamType.BIDI_STREAMING) {\n            this.setReadable(stream);\n            this.setWritable(stream);\n        }\n        if (this._isCancelCalled && this.stream) {\n            this.stream.cancel();\n        }\n    }\n    /**\n     * Creates a new retry request stream -\n     *inner arrow function \"newMakeRequest\" handles retrying and resumption\n     * @param {streamingRetryRequestOptions} opts\n     *   {request} - the request to be made if the stream errors\n     *   {retry} - the retry options associated with the call\n     * @returns {CancellableStream} - the stream that handles retry logic\n     */\n    newStreamingRetryRequest(opts) {\n        // at this point, it would be unexpected if retry were undefined\n        // but if it is, provide a logical default so we don't run into trouble\n        const retry = opts.retry ?? {\n            retryCodes: [],\n            backoffSettings: (0, gax_1.createDefaultBackoffSettings)(),\n        };\n        let retries = 0;\n        const retryStream = new stream_1.PassThrough({\n            objectMode: true,\n        });\n        const totalTimeout = retry.backoffSettings.totalTimeoutMillis ?? undefined;\n        const maxRetries = retry.backoffSettings.maxRetries ?? undefined;\n        let timeout = retry.backoffSettings.initialRpcTimeoutMillis ?? undefined;\n        let now = new Date();\n        let deadline = 0;\n        if (totalTimeout) {\n            deadline = now.getTime() + totalTimeout;\n        }\n        const transientErrorHelper = (error, requestStream) => {\n            const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n            e.note =\n                'Exception occurred in retry method that was ' +\n                    'not classified as transient';\n            // clean up the request stream and retryStreams, silently destroy it on the request stream\n            // but do raise it on destructin of the retryStream so the consumer can see it\n            requestStream.destroy();\n            retryStream.destroy(e);\n            return retryStream;\n        };\n        const newMakeRequest = (newopts) => {\n            let dataEnd = false;\n            let statusReceived = false;\n            let enteredError = false;\n            // make the request\n            const requestStream = newopts.request(requestOps);\n            retryStream.cancel = requestStream.cancel; // make sure the retryStream is also cancellable by the user\n            const eventsToForward = ['metadata', 'response', 'status'];\n            eventsToForward.forEach(event => {\n                requestStream.on(event, retryStream.emit.bind(retryStream, event));\n            });\n            this.statusMetadataHelper(requestStream);\n            // TODO - b/353262542 address buffer stuff\n            requestStream.on('data', (data) => {\n                retries = 0;\n                this.emit.bind(this, 'data')(data);\n            });\n            /* in retry-request, which previously handled retries,\n             * \"end\" could be emitted on a request stream before other gRPC events.\n             * To ensure it doesn't reach the consumer stream prematurely, retry-request piped\n             * two streams together (delayStream and retryStream)\n             * to ensure that \"end\" only emitted after a \"response\" event\n             *\n             * We are consciously NOT using pipeline or .pipe as part of similar logic here\n             * because we want more control over what happens during event handoff and we want to\n             * avoid the undesired behavior that can happen with error events\n             * if consumers in client libraries are also using pipes\n             *\n             * Since \"status\" is guaranteed to be the last event emitted by gRPC.\n             * If we have seen an \"end\" event, the dataEnd boolean will be true and we can safely\n             * end the stream.\n             *\n             * The \"statusReceived\" boolean covers the opposite case - that we receive the \"status\" event before\n             * a successful stream end event - this signals the .on('end') event handler that it's okay to end the stream\n             *\n             *\n             */\n            requestStream.on('status', () => {\n                statusReceived = true;\n                if (dataEnd) {\n                    retryStream.end();\n                }\n                return retryStream;\n            });\n            requestStream.on('end', () => {\n                if (!enteredError) {\n                    dataEnd = true;\n                    // in this case, we've already received \"status\"\n                    // which is the last event from gRPC, so it's cool to end the stream\n                    if (statusReceived) {\n                        retryStream.end();\n                    }\n                }\n                return retryStream;\n                // there is no else case because if enteredError\n                // is true, we will handle stream destruction as part of\n                // either retrying (where we don't want to end the stream)\n                // or as part of error handling, which will take care of stream destruction\n            });\n            requestStream.on('error', (error) => {\n                enteredError = true;\n                // type check for undefined instead of for truthiness in case maxRetries or timeout is equal to zero\n                if (typeof maxRetries !== undefined ||\n                    typeof totalTimeout !== undefined) {\n                    if (this.shouldRetryRequest(error, retry)) {\n                        if (maxRetries && totalTimeout) {\n                            const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\n                                'in backoffSettings.');\n                            newError.code = status_1.Status.INVALID_ARGUMENT;\n                            // clean up the request stream and retryStreams, silently destroy it on the request stream\n                            // but do raise it on destructin of the retryStream so the consumer can see it\n                            requestStream.destroy();\n                            retryStream.destroy(newError);\n                            return retryStream;\n                        }\n                        else {\n                            // check for exceeding timeout or max retries\n                            try {\n                                this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, timeout, error, totalTimeout, retries);\n                            }\n                            catch (error) {\n                                const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n                                // clean up the request stream and retryStreams, silently destroy it on the request stream\n                                // but do raise it on destruction of the retryStream so the consumer can see it\n                                requestStream.destroy();\n                                retryStream.destroy(e);\n                                return retryStream;\n                            }\n                            const delayMult = retry.backoffSettings.retryDelayMultiplier;\n                            const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n                            const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n                            const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n                            let delay = retry.backoffSettings.initialRetryDelayMillis;\n                            // calculate new deadlines\n                            const toSleep = Math.random() * delay;\n                            const calculateTimeoutAndResumptionFunction = () => {\n                                setTimeout(() => {\n                                    // only do timeout calculations if not using maxRetries\n                                    if (timeout) {\n                                        now = new Date();\n                                        delay = Math.min(delay * delayMult, maxDelay);\n                                        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                                        const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                                        const newDeadline = deadline ? deadline - now.getTime() : 0;\n                                        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n                                    }\n                                    retries++;\n                                    let retryArgument = this.argument;\n                                    // if resumption logic is passed, use it to determined the\n                                    // new argument for the new request made to the server\n                                    // otherwise, the original argument will be passed\n                                    if (retry.getResumptionRequestFn !== undefined) {\n                                        retryArgument = retry.getResumptionRequestFn(retryArgument);\n                                    }\n                                    const newRequest = () => {\n                                        if (this._isCancelCalled) {\n                                            if (this.stream) {\n                                                this.stream.cancel();\n                                            }\n                                            return;\n                                        }\n                                        const newStream = this.apiCall(retryArgument, this._callback);\n                                        return newStream;\n                                    };\n                                    opts.request = newRequest;\n                                    // make a request with the updated parameters\n                                    // based on the resumption strategy\n                                    return newMakeRequest(opts);\n                                }, toSleep);\n                            };\n                            return calculateTimeoutAndResumptionFunction();\n                        }\n                    }\n                    else {\n                        // non retryable error\n                        return transientErrorHelper(error, requestStream);\n                    }\n                }\n                else {\n                    // neither timeout nor maxRetries are defined, surface the error to the caller\n                    return transientErrorHelper(error, requestStream);\n                }\n            });\n            // return the stream if we didn't return it as\n            // part of an error state\n            return retryStream;\n        };\n        // this is the first make request call with the options the user passed in\n        return newMakeRequest(opts);\n    }\n}\nexports.StreamProxy = StreamProxy;\n//# sourceMappingURL=streaming.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}