{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nexports.shuffled = shuffled;\nexports.setup = setup;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_2 = require(\"./subchannel-address\");\nconst net_1 = require(\"net\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n  constructor(shuffleAddressList) {\n    this.shuffleAddressList = shuffleAddressList;\n  }\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList\n      }\n    };\n  }\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    if ('shuffleAddressList' in obj && !(typeof obj.shuffleAddressList === 'boolean')) {\n      throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nfunction shuffled(list) {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\n/**\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\n * @param addressList\n * @returns\n */\nfunction interleaveAddressFamilies(addressList) {\n  if (addressList.length === 0) {\n    return [];\n  }\n  const result = [];\n  const ipv6Addresses = [];\n  const ipv4Addresses = [];\n  const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);\n  for (const address of addressList) {\n    if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {\n      ipv6Addresses.push(address);\n    } else {\n      ipv4Addresses.push(address);\n    }\n  }\n  const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\n  const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\n  for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {\n    if (i < firstList.length) {\n      result.push(firstList[i]);\n    }\n    if (i < secondList.length) {\n      result.push(secondList[i]);\n    }\n  }\n  return result;\n}\nconst REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n    this.children = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n    this.currentPick = null;\n    /**\n     * Listener callback attached to each subchannel in the `subchannels` list\n     * while establishing a connection.\n     */\n    this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n      this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n    };\n    this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();\n    /**\n     * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n     * subchannels have failed to connect at least once, and it stays in that\n     * mode until a connection attempt is successful. While in sticky TF mode,\n     * the LB policy continuously attempts to connect to all of its subchannels.\n     */\n    this.stickyTransientFailureMode = false;\n    this.reportHealthStatus = false;\n    /**\n     * The most recent error reported by any subchannel as it transitioned to\n     * TRANSIENT_FAILURE.\n     */\n    this.lastError = null;\n    this.latestAddressList = null;\n    this.latestOptions = {};\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n  allChildrenHaveReportedTF() {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n  resetChildrenReportedTF() {\n    this.children.every(child => child.hasReportedTransientFailure = false);\n  }\n  calculateAndReportNewState() {\n    var _a;\n    if (this.currentPick) {\n      if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\n        const errorMessage = `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`;\n        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n          details: errorMessage\n        }), errorMessage);\n      } else {\n        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick), null);\n      }\n    } else if (((_a = this.latestAddressList) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n      const errorMessage = `No connection established. Last error: ${this.lastError}`;\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n        details: errorMessage\n      }), errorMessage);\n    } else if (this.children.length === 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\n    } else {\n      if (this.stickyTransientFailureMode) {\n        const errorMessage = `No connection established. Last error: ${this.lastError}`;\n        this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\n          details: errorMessage\n        }), errorMessage);\n      } else {\n        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\n      }\n    }\n  }\n  requestReresolution() {\n    this.channelControlHelper.requestReresolution();\n  }\n  maybeEnterStickyTransientFailureMode() {\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    this.requestReresolution();\n    this.resetChildrenReportedTF();\n    if (this.stickyTransientFailureMode) {\n      this.calculateAndReportNewState();\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n  removeCurrentPick() {\n    if (this.currentPick !== null) {\n      this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n      this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);\n      // Unref last, to avoid triggering listeners\n      this.currentPick.unref();\n      this.currentPick = null;\n    }\n  }\n  onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n    var _a;\n    if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n      if (newState !== connectivity_state_1.ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          if (errorMessage) {\n            this.lastError = errorMessage;\n          }\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n  startNextSubchannelConnecting(startIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.maybeEnterStickyTransientFailureMode();\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  startConnecting(subchannelIndex) {\n    var _a, _b;\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.children[subchannelIndex].subchannel.getAddress());\n      process.nextTick(() => {\n        var _a;\n        (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS);\n    (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Declare that the specified subchannel should be used to make requests.\n   * This functions the same independent of whether subchannel is a member of\n   * this.children and whether it is equal to this.currentPick.\n   * Prerequisite: subchannel.getConnectivityState() === READY.\n   * @param subchannel\n   */\n  pickSubchannel(subchannel) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    /* Ref before removeCurrentPick and resetSubchannelList to avoid the\n     * refcount dropping to 0 during this process. */\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.removeCurrentPick();\n    this.resetSubchannelList();\n    subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\n    this.currentPick = subchannel;\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n  updateState(newState, picker, errorMessage) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker, errorMessage);\n  }\n  resetSubchannelList() {\n    for (const child of this.children) {\n      /* Always remoev the connectivity state listener. If the subchannel is\n         getting picked, it will be re-added then. */\n      child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n  }\n  connectToAddressList(addressList, options) {\n    trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, options),\n      hasReportedTransientFailure: false\n    }));\n    for (const {\n      subchannel\n    } of newChildrenList) {\n      if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const {\n      subchannel\n    } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const {\n      subchannel\n    } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    for (const child of this.children) {\n      if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n  updateAddressList(endpointList, lbConfig, options) {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      endpointList = shuffled(endpointList);\n    }\n    const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\n    trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\n    if (rawAddressList.length === 0) {\n      this.lastError = 'No addresses resolved';\n    }\n    const addressList = interleaveAddressFamilies(rawAddressList);\n    this.latestAddressList = addressList;\n    this.latestOptions = options;\n    this.connectToAddressList(addressList, options);\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n      this.connectToAddressList(this.latestAddressList, this.latestOptions);\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\n/**\n * This class handles the leaf load balancing operations for a single endpoint.\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\n * that more closely reflects how it will be used as a leaf balancer.\n */\nclass LeafLoadBalancer {\n  constructor(endpoint, channelControlHelper, options) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this.latestState = connectivity_state_1.ConnectivityState.IDLE;\n    const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\n      updateState: (connectivityState, picker, errorMessage) => {\n        this.latestState = connectivityState;\n        this.latestPicker = picker;\n        channelControlHelper.updateState(connectivityState, picker, errorMessage);\n      }\n    });\n    this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper);\n    this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);\n  }\n  startConnecting() {\n    this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG, Object.assign(Object.assign({}, this.options), {\n      [REPORT_HEALTH_STATUS_OPTION_NAME]: true\n    }));\n  }\n  /**\n   * Update the endpoint associated with this LeafLoadBalancer to a new\n   * endpoint. Does not trigger connection establishment if a connection\n   * attempt is not already in progress.\n   * @param newEndpoint\n   */\n  updateEndpoint(newEndpoint, newOptions) {\n    this.options = newOptions;\n    this.endpoint = newEndpoint;\n    if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {\n      this.startConnecting();\n    }\n  }\n  getConnectivityState() {\n    return this.latestState;\n  }\n  getPicker() {\n    return this.latestPicker;\n  }\n  getEndpoint() {\n    return this.endpoint;\n  }\n  exitIdle() {\n    this.pickFirstBalancer.exitIdle();\n  }\n  destroy() {\n    this.pickFirstBalancer.destroy();\n  }\n}\nexports.LeafLoadBalancer = LeafLoadBalancer;\nfunction setup() {\n  (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n  (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}","map":{"version":3,"names":["exports","shuffled","setup","load_balancer_1","require","connectivity_state_1","picker_1","subchannel_address_1","logging","constants_1","subchannel_address_2","net_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","CONNECTION_DELAY_INTERVAL_MS","PickFirstLoadBalancingConfig","constructor","shuffleAddressList","getLoadBalancerName","toJsonObject","getShuffleAddressList","createFromJson","obj","Error","PickFirstPicker","subchannel","pick","pickArgs","pickResultType","PickResultType","COMPLETE","status","onCallStarted","onCallEnded","list","result","slice","i","length","j","Math","floor","random","temp","interleaveAddressFamilies","addressList","ipv6Addresses","ipv4Addresses","ipv6First","isTcpSubchannelAddress","isIPv6","host","address","push","firstList","secondList","max","REPORT_HEALTH_STATUS_OPTION_NAME","PickFirstLoadBalancer","channelControlHelper","children","currentState","ConnectivityState","IDLE","currentSubchannelIndex","currentPick","subchannelStateListener","previousState","newState","keepaliveTime","errorMessage","onSubchannelStateUpdate","pickedSubchannelHealthListener","calculateAndReportNewState","stickyTransientFailureMode","reportHealthStatus","lastError","latestAddressList","latestOptions","connectionDelayTimeout","setTimeout","clearTimeout","allChildrenHaveReportedTF","every","child","hasReportedTransientFailure","resetChildrenReportedTF","isHealthy","getAddress","updateState","TRANSIENT_FAILURE","UnavailablePicker","details","READY","_a","QueuePicker","CONNECTING","requestReresolution","maybeEnterStickyTransientFailureMode","startConnecting","removeCurrentPick","removeConnectivityStateListener","removeChannelzChild","getChannelzRef","removeHealthStateWatcher","unref","realSubchannelEquals","index","entries","pickSubchannel","startNextSubchannelConnecting","startIndex","subchannelState","getConnectivityState","subchannelIndex","process","nextTick","_b","call","ref","addChannelzChild","resetSubchannelList","addConnectivityStateListener","addHealthStateWatcher","picker","connectToAddressList","options","map","subchannelAddressToString","newChildrenList","createSubchannel","updateAddressList","endpointList","lbConfig","rawAddressList","concat","endpoint","addresses","exitIdle","resetBackoff","destroy","getTypeName","LEAF_CONFIG","LeafLoadBalancer","latestState","childChannelControlHelper","createChildChannelControlHelper","connectivityState","latestPicker","pickFirstBalancer","Object","assign","updateEndpoint","newEndpoint","newOptions","getPicker","getEndpoint","registerLoadBalancerType","registerDefaultLoadBalancerType"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\load-balancer-pick-first.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  TypedLoadBalancingConfig,\n  registerDefaultLoadBalancerType,\n  registerLoadBalancerType,\n  createChildChannelControlHelper,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport { Endpoint, SubchannelAddress, subchannelAddressToString } from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport {\n  SubchannelInterface,\n  ConnectivityStateListener,\n  HealthListener,\n} from './subchannel-interface';\nimport { isTcpSubchannelAddress } from './subchannel-address';\nimport { isIPv6 } from 'net';\nimport { ChannelOptions } from './channel-options';\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n\nexport class PickFirstLoadBalancingConfig implements TypedLoadBalancingConfig {\n  constructor(private readonly shuffleAddressList: boolean) {}\n\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {\n        shuffleAddressList: this.shuffleAddressList,\n      },\n    };\n  }\n\n  getShuffleAddressList() {\n    return this.shuffleAddressList;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    if (\n      'shuffleAddressList' in obj &&\n      !(typeof obj.shuffleAddressList === 'boolean')\n    ) {\n      throw new Error(\n        'pick_first config field shuffleAddressList must be a boolean if provided'\n      );\n    }\n    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n  }\n}\n\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker implements Picker {\n  constructor(private subchannel: SubchannelInterface) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null,\n    };\n  }\n}\n\ninterface SubchannelChild {\n  subchannel: SubchannelInterface;\n  hasReportedTransientFailure: boolean;\n}\n\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nexport function shuffled<T>(list: T[]): T[] {\n  const result = list.slice();\n  for (let i = result.length - 1; i > 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = result[i];\n    result[i] = result[j];\n    result[j] = temp;\n  }\n  return result;\n}\n\n/**\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\n * @param addressList\n * @returns\n */\nfunction interleaveAddressFamilies(\n  addressList: SubchannelAddress[]\n): SubchannelAddress[] {\n  if (addressList.length === 0) {\n    return [];\n  }\n  const result: SubchannelAddress[] = [];\n  const ipv6Addresses: SubchannelAddress[] = [];\n  const ipv4Addresses: SubchannelAddress[] = [];\n  const ipv6First =\n    isTcpSubchannelAddress(addressList[0]) && isIPv6(addressList[0].host);\n  for (const address of addressList) {\n    if (isTcpSubchannelAddress(address) && isIPv6(address.host)) {\n      ipv6Addresses.push(address);\n    } else {\n      ipv4Addresses.push(address);\n    }\n  }\n  const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\n  const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\n  for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {\n    if (i < firstList.length) {\n      result.push(firstList[i]);\n    }\n    if (i < secondList.length) {\n      result.push(secondList[i]);\n    }\n  }\n  return result;\n}\n\nconst REPORT_HEALTH_STATUS_OPTION_NAME =\n  'grpc-node.internal.pick-first.report_health_status';\n\nexport class PickFirstLoadBalancer implements LoadBalancer {\n  /**\n   * The list of subchannels this load balancer is currently attempting to\n   * connect to.\n   */\n  private children: SubchannelChild[] = [];\n  /**\n   * The current connectivity state of the load balancer.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The index within the `subchannels` array of the subchannel with the most\n   * recently started connection attempt.\n   */\n  private currentSubchannelIndex = 0;\n  /**\n   * The currently picked subchannel used for making calls. Populated if\n   * and only if the load balancer's current state is READY. In that case,\n   * the subchannel's current state is also READY.\n   */\n  private currentPick: SubchannelInterface | null = null;\n  /**\n   * Listener callback attached to each subchannel in the `subchannels` list\n   * while establishing a connection.\n   */\n  private subchannelStateListener: ConnectivityStateListener = (\n    subchannel,\n    previousState,\n    newState,\n    keepaliveTime,\n    errorMessage\n  ) => {\n    this.onSubchannelStateUpdate(\n      subchannel,\n      previousState,\n      newState,\n      errorMessage\n    );\n  };\n\n  private pickedSubchannelHealthListener: HealthListener = () =>\n    this.calculateAndReportNewState();\n  /**\n   * Timer reference for the timer tracking when to start\n   */\n  private connectionDelayTimeout: NodeJS.Timeout;\n\n  /**\n   * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n   * subchannels have failed to connect at least once, and it stays in that\n   * mode until a connection attempt is successful. While in sticky TF mode,\n   * the LB policy continuously attempts to connect to all of its subchannels.\n   */\n  private stickyTransientFailureMode = false;\n\n  private reportHealthStatus: boolean = false;\n\n  /**\n   * The most recent error reported by any subchannel as it transitioned to\n   * TRANSIENT_FAILURE.\n   */\n  private lastError: string | null = null;\n\n  private latestAddressList: SubchannelAddress[] | null = null;\n\n  private latestOptions: ChannelOptions = {};\n\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(\n    private readonly channelControlHelper: ChannelControlHelper\n  ) {\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  private allChildrenHaveReportedTF(): boolean {\n    return this.children.every(child => child.hasReportedTransientFailure);\n  }\n\n  private resetChildrenReportedTF() {\n    this.children.every(child => child.hasReportedTransientFailure = false);\n  }\n\n  private calculateAndReportNewState() {\n    if (this.currentPick) {\n      if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\n        const errorMessage = `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`;\n        this.updateState(\n          ConnectivityState.TRANSIENT_FAILURE,\n          new UnavailablePicker({\n            details: errorMessage,\n          }),\n          errorMessage\n        );\n      } else {\n        this.updateState(\n          ConnectivityState.READY,\n          new PickFirstPicker(this.currentPick),\n          null\n        );\n      }\n    } else if (this.latestAddressList?.length === 0) {\n      const errorMessage = `No connection established. Last error: ${this.lastError}`;\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker({\n          details: errorMessage,\n        }),\n        errorMessage\n      );\n    } else if (this.children.length === 0) {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this), null);\n    } else {\n      if (this.stickyTransientFailureMode) {\n        const errorMessage = `No connection established. Last error: ${this.lastError}`;\n        this.updateState(\n          ConnectivityState.TRANSIENT_FAILURE,\n          new UnavailablePicker({\n            details: errorMessage,\n          }),\n          errorMessage\n        );\n      } else {\n        this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this), null);\n      }\n    }\n  }\n\n  private requestReresolution() {\n    this.channelControlHelper.requestReresolution();\n  }\n\n  private maybeEnterStickyTransientFailureMode() {\n    if (!this.allChildrenHaveReportedTF()) {\n      return;\n    }\n    this.requestReresolution();\n    this.resetChildrenReportedTF();\n    if (this.stickyTransientFailureMode) {\n      this.calculateAndReportNewState();\n      return;\n    }\n    this.stickyTransientFailureMode = true;\n    for (const { subchannel } of this.children) {\n      subchannel.startConnecting();\n    }\n    this.calculateAndReportNewState();\n  }\n\n  private removeCurrentPick() {\n    if (this.currentPick !== null) {\n      this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(\n        this.currentPick.getChannelzRef()\n      );\n      this.currentPick.removeHealthStateWatcher(\n        this.pickedSubchannelHealthListener\n      );\n      // Unref last, to avoid triggering listeners\n      this.currentPick.unref();\n      this.currentPick = null;\n    }\n  }\n\n  private onSubchannelStateUpdate(\n    subchannel: SubchannelInterface,\n    previousState: ConnectivityState,\n    newState: ConnectivityState,\n    errorMessage?: string\n  ) {\n    if (this.currentPick?.realSubchannelEquals(subchannel)) {\n      if (newState !== ConnectivityState.READY) {\n        this.removeCurrentPick();\n        this.calculateAndReportNewState();\n      }\n      return;\n    }\n    for (const [index, child] of this.children.entries()) {\n      if (subchannel.realSubchannelEquals(child.subchannel)) {\n        if (newState === ConnectivityState.READY) {\n          this.pickSubchannel(child.subchannel);\n        }\n        if (newState === ConnectivityState.TRANSIENT_FAILURE) {\n          child.hasReportedTransientFailure = true;\n          if (errorMessage) {\n            this.lastError = errorMessage;\n          }\n          this.maybeEnterStickyTransientFailureMode();\n          if (index === this.currentSubchannelIndex) {\n            this.startNextSubchannelConnecting(index + 1);\n          }\n        }\n        child.subchannel.startConnecting();\n        return;\n      }\n    }\n  }\n\n  private startNextSubchannelConnecting(startIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    for (const [index, child] of this.children.entries()) {\n      if (index >= startIndex) {\n        const subchannelState = child.subchannel.getConnectivityState();\n        if (\n          subchannelState === ConnectivityState.IDLE ||\n          subchannelState === ConnectivityState.CONNECTING\n        ) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.maybeEnterStickyTransientFailureMode();\n  }\n\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  private startConnecting(subchannelIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (\n      this.children[subchannelIndex].subchannel.getConnectivityState() ===\n      ConnectivityState.IDLE\n    ) {\n      trace(\n        'Start connecting to subchannel with address ' +\n          this.children[subchannelIndex].subchannel.getAddress()\n      );\n      process.nextTick(() => {\n        this.children[subchannelIndex]?.subchannel.startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting(subchannelIndex + 1);\n    }, CONNECTION_DELAY_INTERVAL_MS);\n    this.connectionDelayTimeout.unref?.();\n  }\n\n  /**\n   * Declare that the specified subchannel should be used to make requests.\n   * This functions the same independent of whether subchannel is a member of\n   * this.children and whether it is equal to this.currentPick.\n   * Prerequisite: subchannel.getConnectivityState() === READY.\n   * @param subchannel\n   */\n  private pickSubchannel(subchannel: SubchannelInterface) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    this.stickyTransientFailureMode = false;\n    /* Ref before removeCurrentPick and resetSubchannelList to avoid the\n     * refcount dropping to 0 during this process. */\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.removeCurrentPick();\n    this.resetSubchannelList();\n    subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\n    this.currentPick = subchannel;\n    clearTimeout(this.connectionDelayTimeout);\n    this.calculateAndReportNewState();\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker, errorMessage: string | null) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker, errorMessage);\n  }\n\n  private resetSubchannelList() {\n    for (const child of this.children) {\n      /* Always remoev the connectivity state listener. If the subchannel is\n         getting picked, it will be re-added then. */\n      child.subchannel.removeConnectivityStateListener(\n        this.subchannelStateListener\n      );\n      /* Refs are counted independently for the children list and the\n       * currentPick, so we call unref whether or not the child is the\n       * currentPick. Channelz child references are also refcounted, so\n       * removeChannelzChild can be handled the same way. */\n      child.subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(\n        child.subchannel.getChannelzRef()\n      );\n    }\n    this.currentSubchannelIndex = 0;\n    this.children = [];\n  }\n\n  private connectToAddressList(addressList: SubchannelAddress[], options: ChannelOptions) {\n    trace('connectToAddressList([' + addressList.map(address => subchannelAddressToString(address)) + '])');\n    const newChildrenList = addressList.map(address => ({\n      subchannel: this.channelControlHelper.createSubchannel(address, options),\n      hasReportedTransientFailure: false,\n    }));\n    for (const { subchannel } of newChildrenList) {\n      if (subchannel.getConnectivityState() === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      }\n    }\n    /* Ref each subchannel before resetting the list, to ensure that\n     * subchannels shared between the list don't drop to 0 refs during the\n     * transition. */\n    for (const { subchannel } of newChildrenList) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    this.resetSubchannelList();\n    this.children = newChildrenList;\n    for (const { subchannel } of this.children) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    for (const child of this.children) {\n      if (\n        child.subchannel.getConnectivityState() ===\n        ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        child.hasReportedTransientFailure = true;\n      }\n    }\n    this.startNextSubchannelConnecting(0);\n    this.calculateAndReportNewState();\n  }\n\n  updateAddressList(\n    endpointList: Endpoint[],\n    lbConfig: TypedLoadBalancingConfig,\n    options: ChannelOptions\n  ): void {\n    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n      return;\n    }\n    this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\n    /* Previously, an update would be discarded if it was identical to the\n     * previous update, to minimize churn. Now the DNS resolver is\n     * rate-limited, so that is less of a concern. */\n    if (lbConfig.getShuffleAddressList()) {\n      endpointList = shuffled(endpointList);\n    }\n    const rawAddressList = ([] as SubchannelAddress[]).concat(\n      ...endpointList.map(endpoint => endpoint.addresses)\n    );\n    trace('updateAddressList([' + rawAddressList.map(address => subchannelAddressToString(address)) + '])');\n    if (rawAddressList.length === 0) {\n      this.lastError = 'No addresses resolved';\n    }\n    const addressList = interleaveAddressFamilies(rawAddressList);\n    this.latestAddressList = addressList;\n    this.latestOptions = options;\n    this.connectToAddressList(addressList, options);\n  }\n\n  exitIdle() {\n    if (\n      this.currentState === ConnectivityState.IDLE &&\n      this.latestAddressList\n    ) {\n      this.connectToAddressList(this.latestAddressList, this.latestOptions);\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n    this.removeCurrentPick();\n  }\n\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\n\n/**\n * This class handles the leaf load balancing operations for a single endpoint.\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\n * that more closely reflects how it will be used as a leaf balancer.\n */\nexport class LeafLoadBalancer {\n  private pickFirstBalancer: PickFirstLoadBalancer;\n  private latestState: ConnectivityState = ConnectivityState.IDLE;\n  private latestPicker: Picker;\n  constructor(\n    private endpoint: Endpoint,\n    channelControlHelper: ChannelControlHelper,\n    private options: ChannelOptions\n  ) {\n    const childChannelControlHelper = createChildChannelControlHelper(\n      channelControlHelper,\n      {\n        updateState: (connectivityState, picker, errorMessage) => {\n          this.latestState = connectivityState;\n          this.latestPicker = picker;\n          channelControlHelper.updateState(connectivityState, picker, errorMessage);\n        },\n      }\n    );\n    this.pickFirstBalancer = new PickFirstLoadBalancer(\n      childChannelControlHelper\n    );\n    this.latestPicker = new QueuePicker(this.pickFirstBalancer);\n  }\n\n  startConnecting() {\n    this.pickFirstBalancer.updateAddressList(\n      [this.endpoint],\n      LEAF_CONFIG,\n      { ...this.options, [REPORT_HEALTH_STATUS_OPTION_NAME]: true }\n    );\n  }\n\n  /**\n   * Update the endpoint associated with this LeafLoadBalancer to a new\n   * endpoint. Does not trigger connection establishment if a connection\n   * attempt is not already in progress.\n   * @param newEndpoint\n   */\n  updateEndpoint(newEndpoint: Endpoint, newOptions: ChannelOptions) {\n    this.options = newOptions;\n    this.endpoint = newEndpoint;\n    if (this.latestState !== ConnectivityState.IDLE) {\n      this.startConnecting();\n    }\n  }\n\n  getConnectivityState() {\n    return this.latestState;\n  }\n\n  getPicker() {\n    return this.latestPicker;\n  }\n\n  getEndpoint() {\n    return this.endpoint;\n  }\n\n  exitIdle() {\n    this.pickFirstBalancer.exitIdle();\n  }\n\n  destroy() {\n    this.pickFirstBalancer.destroy();\n  }\n}\n\nexport function setup(): void {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    PickFirstLoadBalancer,\n    PickFirstLoadBalancingConfig\n  );\n  registerDefaultLoadBalancerType(TYPE_NAME);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}