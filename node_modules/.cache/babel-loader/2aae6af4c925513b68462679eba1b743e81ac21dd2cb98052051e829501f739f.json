{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileWatcherCertificateProvider = void 0;\nconst fs = require(\"fs\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst util_1 = require(\"util\");\nconst TRACER_NAME = 'certificate_provider';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst readFilePromise = (0, util_1.promisify)(fs.readFile);\nclass FileWatcherCertificateProvider {\n  constructor(config) {\n    this.config = config;\n    this.refreshTimer = null;\n    this.fileResultPromise = null;\n    this.latestCaUpdate = undefined;\n    this.caListeners = new Set();\n    this.latestIdentityUpdate = undefined;\n    this.identityListeners = new Set();\n    this.lastUpdateTime = null;\n    if (config.certificateFile === undefined !== (config.privateKeyFile === undefined)) {\n      throw new Error('certificateFile and privateKeyFile must be set or unset together');\n    }\n    if (config.certificateFile === undefined && config.caCertificateFile === undefined) {\n      throw new Error('At least one of certificateFile and caCertificateFile must be set');\n    }\n    trace('File watcher constructed with config ' + JSON.stringify(config));\n  }\n  updateCertificates() {\n    if (this.fileResultPromise) {\n      return;\n    }\n    this.fileResultPromise = Promise.allSettled([this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(), this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(), this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()]);\n    this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {\n      if (!this.refreshTimer) {\n        return;\n      }\n      trace('File watcher read certificates certificate ' + certificateResult.status + ', privateKey ' + privateKeyResult.status + ', CA certificate ' + caCertificateResult.status);\n      this.lastUpdateTime = new Date();\n      this.fileResultPromise = null;\n      if (certificateResult.status === 'fulfilled' && privateKeyResult.status === 'fulfilled') {\n        this.latestIdentityUpdate = {\n          certificate: certificateResult.value,\n          privateKey: privateKeyResult.value\n        };\n      } else {\n        this.latestIdentityUpdate = null;\n      }\n      if (caCertificateResult.status === 'fulfilled') {\n        this.latestCaUpdate = {\n          caCertificate: caCertificateResult.value\n        };\n      } else {\n        this.latestCaUpdate = null;\n      }\n      for (const listener of this.identityListeners) {\n        listener(this.latestIdentityUpdate);\n      }\n      for (const listener of this.caListeners) {\n        listener(this.latestCaUpdate);\n      }\n    });\n    trace('File watcher initiated certificate update');\n  }\n  maybeStartWatchingFiles() {\n    if (!this.refreshTimer) {\n      /* Perform the first read immediately, but only if there was not already\n       * a recent read, to avoid reading from the filesystem significantly more\n       * frequently than configured if the provider quickly switches between\n       * used and unused. */\n      const timeSinceLastUpdate = this.lastUpdateTime ? new Date().getTime() - this.lastUpdateTime.getTime() : Infinity;\n      if (timeSinceLastUpdate > this.config.refreshIntervalMs) {\n        this.updateCertificates();\n      }\n      if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {\n        // Clear out old updates if they are definitely stale\n        this.latestCaUpdate = undefined;\n        this.latestIdentityUpdate = undefined;\n      }\n      this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);\n      trace('File watcher started watching');\n    }\n  }\n  maybeStopWatchingFiles() {\n    if (this.caListeners.size === 0 && this.identityListeners.size === 0) {\n      this.fileResultPromise = null;\n      if (this.refreshTimer) {\n        clearInterval(this.refreshTimer);\n        this.refreshTimer = null;\n      }\n    }\n  }\n  addCaCertificateListener(listener) {\n    this.caListeners.add(listener);\n    this.maybeStartWatchingFiles();\n    if (this.latestCaUpdate !== undefined) {\n      process.nextTick(listener, this.latestCaUpdate);\n    }\n  }\n  removeCaCertificateListener(listener) {\n    this.caListeners.delete(listener);\n    this.maybeStopWatchingFiles();\n  }\n  addIdentityCertificateListener(listener) {\n    this.identityListeners.add(listener);\n    this.maybeStartWatchingFiles();\n    if (this.latestIdentityUpdate !== undefined) {\n      process.nextTick(listener, this.latestIdentityUpdate);\n    }\n  }\n  removeIdentityCertificateListener(listener) {\n    this.identityListeners.delete(listener);\n    this.maybeStopWatchingFiles();\n  }\n}\nexports.FileWatcherCertificateProvider = FileWatcherCertificateProvider;","map":{"version":3,"names":["fs","require","logging","constants_1","util_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","readFilePromise","promisify","readFile","FileWatcherCertificateProvider","constructor","config","refreshTimer","fileResultPromise","latestCaUpdate","undefined","caListeners","Set","latestIdentityUpdate","identityListeners","lastUpdateTime","certificateFile","privateKeyFile","Error","caCertificateFile","JSON","stringify","updateCertificates","Promise","allSettled","reject","then","certificateResult","privateKeyResult","caCertificateResult","status","Date","certificate","value","privateKey","caCertificate","listener","maybeStartWatchingFiles","timeSinceLastUpdate","getTime","Infinity","refreshIntervalMs","setInterval","maybeStopWatchingFiles","size","clearInterval","addCaCertificateListener","add","process","nextTick","removeCaCertificateListener","delete","addIdentityCertificateListener","removeIdentityCertificateListener","exports"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\certificate-provider.ts"],"sourcesContent":["/*\n * Copyright 2024 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as fs from 'fs';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { promisify } from 'util';\n\nconst TRACER_NAME = 'certificate_provider';\n\nfunction trace(text: string) {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nexport interface CaCertificateUpdate {\n  caCertificate: Buffer;\n}\n\nexport interface IdentityCertificateUpdate {\n  certificate: Buffer;\n  privateKey: Buffer;\n}\n\nexport interface CaCertificateUpdateListener {\n  (update: CaCertificateUpdate | null): void;\n}\n\nexport interface IdentityCertificateUpdateListener {\n  (update: IdentityCertificateUpdate | null) : void;\n}\n\nexport interface CertificateProvider {\n  addCaCertificateListener(listener: CaCertificateUpdateListener): void;\n  removeCaCertificateListener(listener: CaCertificateUpdateListener): void;\n  addIdentityCertificateListener(listener: IdentityCertificateUpdateListener): void;\n  removeIdentityCertificateListener(listener: IdentityCertificateUpdateListener): void;\n}\n\nexport interface FileWatcherCertificateProviderConfig {\n  certificateFile?: string | undefined;\n  privateKeyFile?: string | undefined;\n  caCertificateFile?: string | undefined;\n  refreshIntervalMs: number;\n}\n\nconst readFilePromise = promisify(fs.readFile);\n\nexport class FileWatcherCertificateProvider implements CertificateProvider {\n  private refreshTimer: NodeJS.Timeout | null = null;\n  private fileResultPromise: Promise<[PromiseSettledResult<Buffer>, PromiseSettledResult<Buffer>, PromiseSettledResult<Buffer>]> | null = null;\n  private latestCaUpdate: CaCertificateUpdate | null | undefined = undefined;\n  private caListeners: Set<CaCertificateUpdateListener> = new Set();\n  private latestIdentityUpdate: IdentityCertificateUpdate | null | undefined = undefined;\n  private identityListeners: Set<IdentityCertificateUpdateListener> = new Set();\n  private lastUpdateTime: Date | null = null;\n\n  constructor(\n    private config: FileWatcherCertificateProviderConfig\n  ) {\n    if ((config.certificateFile === undefined) !== (config.privateKeyFile === undefined)) {\n      throw new Error('certificateFile and privateKeyFile must be set or unset together');\n    }\n    if (config.certificateFile === undefined && config.caCertificateFile === undefined) {\n      throw new Error('At least one of certificateFile and caCertificateFile must be set');\n    }\n    trace('File watcher constructed with config ' + JSON.stringify(config));\n  }\n\n  private updateCertificates() {\n    if (this.fileResultPromise) {\n      return;\n    }\n    this.fileResultPromise = Promise.allSettled([\n      this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject<Buffer>(),\n      this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject<Buffer>(),\n      this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject<Buffer>()\n    ]);\n    this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {\n      if (!this.refreshTimer) {\n        return;\n      }\n      trace('File watcher read certificates certificate ' + certificateResult.status + ', privateKey ' + privateKeyResult.status + ', CA certificate ' + caCertificateResult.status);\n      this.lastUpdateTime = new Date();\n      this.fileResultPromise = null;\n      if (certificateResult.status === 'fulfilled' && privateKeyResult.status === 'fulfilled') {\n        this.latestIdentityUpdate = {\n          certificate: certificateResult.value,\n          privateKey: privateKeyResult.value\n        };\n      } else {\n        this.latestIdentityUpdate = null;\n      }\n      if (caCertificateResult.status === 'fulfilled') {\n        this.latestCaUpdate = {\n          caCertificate: caCertificateResult.value\n        };\n      } else {\n        this.latestCaUpdate = null;\n      }\n      for (const listener of this.identityListeners) {\n        listener(this.latestIdentityUpdate);\n      }\n      for (const listener of this.caListeners) {\n        listener(this.latestCaUpdate);\n      }\n    });\n    trace('File watcher initiated certificate update');\n  }\n\n  private maybeStartWatchingFiles() {\n    if (!this.refreshTimer) {\n      /* Perform the first read immediately, but only if there was not already\n       * a recent read, to avoid reading from the filesystem significantly more\n       * frequently than configured if the provider quickly switches between\n       * used and unused. */\n      const timeSinceLastUpdate = this.lastUpdateTime ? (new Date()).getTime() - this.lastUpdateTime.getTime() : Infinity;\n      if (timeSinceLastUpdate > this.config.refreshIntervalMs) {\n        this.updateCertificates();\n      }\n      if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {\n        // Clear out old updates if they are definitely stale\n        this.latestCaUpdate = undefined;\n        this.latestIdentityUpdate = undefined;\n      }\n      this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);\n      trace('File watcher started watching');\n    }\n  }\n\n  private maybeStopWatchingFiles() {\n    if (this.caListeners.size === 0 && this.identityListeners.size === 0) {\n      this.fileResultPromise = null;\n      if (this.refreshTimer) {\n        clearInterval(this.refreshTimer);\n        this.refreshTimer = null;\n      }\n    }\n  }\n\n  addCaCertificateListener(listener: CaCertificateUpdateListener): void {\n    this.caListeners.add(listener);\n    this.maybeStartWatchingFiles();\n    if (this.latestCaUpdate !== undefined) {\n      process.nextTick(listener, this.latestCaUpdate);\n    }\n  }\n  removeCaCertificateListener(listener: CaCertificateUpdateListener): void {\n    this.caListeners.delete(listener);\n    this.maybeStopWatchingFiles();\n  }\n  addIdentityCertificateListener(listener: IdentityCertificateUpdateListener): void {\n    this.identityListeners.add(listener);\n    this.maybeStartWatchingFiles();\n    if (this.latestIdentityUpdate !== undefined) {\n      process.nextTick(listener, this.latestIdentityUpdate);\n    }\n  }\n  removeIdentityCertificateListener(listener: IdentityCertificateUpdateListener): void {\n    this.identityListeners.delete(listener);\n    this.maybeStopWatchingFiles();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}