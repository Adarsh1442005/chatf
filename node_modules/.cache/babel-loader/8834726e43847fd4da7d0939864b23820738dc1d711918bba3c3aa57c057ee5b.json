{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelConnector = void 0;\nconst http2 = require(\"http2\");\nconst channelz_1 = require(\"./channelz\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst logging = require(\"./logging\");\nconst resolver_1 = require(\"./resolver\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net = require(\"net\");\nconst subchannel_call_1 = require(\"./subchannel-call\");\nconst call_number_1 = require(\"./call-number\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = require('../../package.json').version;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n  constructor(session, subchannelAddress, options,\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  remoteName) {\n    this.session = session;\n    this.options = options;\n    this.remoteName = remoteName;\n    /**\n     * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.\n     */\n    this.keepaliveTimer = null;\n    /**\n     * Indicates that the keepalive timer ran out while there were no active\n     * calls, and a ping should be sent the next time a call starts.\n     */\n    this.pendingSendKeepalivePing = false;\n    this.activeCalls = new Set();\n    this.disconnectListeners = [];\n    this.disconnectHandled = false;\n    this.channelzEnabled = true;\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    /* Populate subchannelAddressString and channelzRef before doing anything\n     * else, because they are used in the trace methods. */\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\n    } else {\n      this.streamTracker = new channelz_1.ChannelzCallTracker();\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    } else {\n      this.keepaliveTimeMs = -1;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    } else {\n      this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    session.once('close', () => {\n      this.trace('session closed');\n      this.handleDisconnect();\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      let tooManyPings = false;\n      /* See the last paragraph of\n       * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n      if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {\n        tooManyPings = true;\n      }\n      this.trace('connection closed by GOAWAY with code ' + errorCode + ' and data ' + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n      this.reportDisconnectToOwner(tooManyPings);\n    });\n    session.once('error', error => {\n      this.trace('connection closed with error ' + error.message);\n      this.handleDisconnect();\n    });\n    session.socket.once('close', hadError => {\n      this.trace('connection closed. hadError=' + hadError);\n      this.handleDisconnect();\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n    /* Start the keepalive timer last, because this can trigger trace logs,\n     * which should only happen after everything else is set up. */\n    if (this.keepaliveWithoutCalls) {\n      this.maybeStartKeepalivePingTimer();\n    }\n  }\n  getChannelzInfo() {\n    var _a, _b, _c;\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  reportDisconnectToOwner(tooManyPings) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  handleDisconnect() {\n    this.clearKeepaliveTimeout();\n    this.reportDisconnectToOwner(false);\n    for (const call of this.activeCalls) {\n      call.onDisconnect();\n    }\n    // Wait an event loop cycle before destroying the connection\n    setImmediate(() => {\n      this.session.destroy();\n    });\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n  canSendPing() {\n    return !this.session.destroyed && this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);\n  }\n  maybeSendPing() {\n    var _a, _b;\n    if (!this.canSendPing()) {\n      this.pendingSendKeepalivePing = true;\n      return;\n    }\n    if (this.keepaliveTimer) {\n      console.error('keepaliveTimeout is not null');\n      return;\n    }\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimer = setTimeout(() => {\n      this.keepaliveTimer = null;\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    let pingSendError = '';\n    try {\n      const pingSentSuccessfully = this.session.ping((err, duration, payload) => {\n        this.clearKeepaliveTimeout();\n        if (err) {\n          this.keepaliveTrace('Ping failed with error ' + err.message);\n          this.handleDisconnect();\n        } else {\n          this.keepaliveTrace('Received ping response');\n          this.maybeStartKeepalivePingTimer();\n        }\n      });\n      if (!pingSentSuccessfully) {\n        pingSendError = 'Ping returned false';\n      }\n    } catch (e) {\n      // grpc/grpc-node#2139\n      pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n    }\n    if (pingSendError) {\n      this.keepaliveTrace('Ping send failed: ' + pingSendError);\n      this.handleDisconnect();\n    }\n  }\n  /**\n   * Starts the keepalive ping timer if appropriate. If the timer already ran\n   * out while there were no active requests, instead send a ping immediately.\n   * If the ping timer is already running or a ping is currently in flight,\n   * instead do nothing and wait for them to resolve.\n   */\n  maybeStartKeepalivePingTimer() {\n    var _a, _b;\n    if (!this.canSendPing()) {\n      return;\n    }\n    if (this.pendingSendKeepalivePing) {\n      this.pendingSendKeepalivePing = false;\n      this.maybeSendPing();\n    } else if (!this.keepaliveTimer) {\n      this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n      this.keepaliveTimer = setTimeout(() => {\n        this.keepaliveTimer = null;\n        this.maybeSendPing();\n      }, this.keepaliveTimeMs);\n      (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n     * wait for those to resolve. */\n  }\n  /**\n   * Clears whichever keepalive timeout is currently active, if any.\n   */\n  clearKeepaliveTimeout() {\n    if (this.keepaliveTimer) {\n      clearTimeout(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n  }\n  removeActiveCall(call) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n    }\n  }\n  addActiveCall(call) {\n    this.activeCalls.add(call);\n    if (this.activeCalls.size === 1) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.maybeStartKeepalivePingTimer();\n      }\n    }\n  }\n  createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    this.internalsTrace('session.closed=' + this.session.closed + ' session.destroyed=' + this.session.destroyed + ' session.socket.destroyed=' + this.session.socket.destroyed);\n    let eventTracker;\n    // eslint-disable-next-line prefer-const\n    let call;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    }\n    call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n    this.addActiveCall(call);\n    return call;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n  getOptions() {\n    return this.options;\n  }\n  shutdown() {\n    this.session.close();\n    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n  }\n}\nclass Http2SubchannelConnector {\n  constructor(channelTarget) {\n    this.channelTarget = channelTarget;\n    this.session = null;\n    this.isShutdown = false;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\n  }\n  createSession(secureConnectResult, address, options) {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    if (secureConnectResult.socket.closed) {\n      return Promise.reject('Connection closed before starting HTTP/2 handshake');\n    }\n    return new Promise((resolve, reject) => {\n      var _a;\n      let remoteName = null;\n      let realTarget = this.channelTarget;\n      if ('grpc.http_connect_target' in options) {\n        const parsedTarget = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target']);\n        if (parsedTarget) {\n          realTarget = parsedTarget;\n          remoteName = (0, uri_parser_1.uriToString)(parsedTarget);\n        }\n      }\n      const scheme = secureConnectResult.secure ? 'https' : 'http';\n      const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\n      const closeHandler = () => {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.session = null;\n        // Leave time for error event to happen before rejecting\n        setImmediate(() => {\n          if (!reportedError) {\n            reportedError = true;\n            reject(`${errorMessage.trim()} (${new Date().toISOString()})`);\n          }\n        });\n      };\n      const errorHandler = error => {\n        var _a;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\n        errorMessage = error.message;\n        this.trace('connection failed with error ' + errorMessage);\n        if (!reportedError) {\n          reportedError = true;\n          reject(`${errorMessage} (${new Date().toISOString()})`);\n        }\n      };\n      const session = http2.connect(`${scheme}://${targetPath}`, {\n        createConnection: (authority, option) => {\n          return secureConnectResult.socket;\n        },\n        settings: {\n          initialWindowSize: (_a = options['grpc-node.flow_control_window']) !== null && _a !== void 0 ? _a : http2.getDefaultSettings().initialWindowSize\n        }\n      });\n      this.session = session;\n      let errorMessage = 'Failed to connect';\n      let reportedError = false;\n      session.unref();\n      session.once('remoteSettings', () => {\n        session.removeAllListeners();\n        secureConnectResult.socket.removeListener('close', closeHandler);\n        secureConnectResult.socket.removeListener('error', errorHandler);\n        resolve(new Http2Transport(session, address, options, remoteName));\n        this.session = null;\n      });\n      session.once('close', closeHandler);\n      session.once('error', errorHandler);\n      secureConnectResult.socket.once('close', closeHandler);\n      secureConnectResult.socket.once('error', errorHandler);\n    });\n  }\n  tcpConnect(address, options) {\n    return (0, http_proxy_1.getProxiedConnection)(address, options).then(proxiedSocket => {\n      if (proxiedSocket) {\n        return proxiedSocket;\n      } else {\n        return new Promise((resolve, reject) => {\n          const closeCallback = () => {\n            reject(new Error('Socket closed'));\n          };\n          const errorCallback = error => {\n            reject(error);\n          };\n          const socket = net.connect(address, () => {\n            socket.removeListener('close', closeCallback);\n            socket.removeListener('error', errorCallback);\n            resolve(socket);\n          });\n          socket.once('close', closeCallback);\n          socket.once('error', errorCallback);\n        });\n      }\n    });\n  }\n  async connect(address, secureConnector, options) {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    let tcpConnection = null;\n    let secureConnectResult = null;\n    const addressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n    try {\n      this.trace(addressString + ' Waiting for secureConnector to be ready');\n      await secureConnector.waitForReady();\n      this.trace(addressString + ' secureConnector is ready');\n      tcpConnection = await this.tcpConnect(address, options);\n      this.trace(addressString + ' Established TCP connection');\n      secureConnectResult = await secureConnector.connect(tcpConnection);\n      this.trace(addressString + ' Established secure connection');\n      return this.createSession(secureConnectResult, address, options);\n    } catch (e) {\n      tcpConnection === null || tcpConnection === void 0 ? void 0 : tcpConnection.destroy();\n      secureConnectResult === null || secureConnectResult === void 0 ? void 0 : secureConnectResult.socket.destroy();\n      throw e;\n    }\n  }\n  shutdown() {\n    var _a;\n    this.isShutdown = true;\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n    this.session = null;\n  }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;","map":{"version":3,"names":["http2","require","channelz_1","constants_1","http_proxy_1","logging","resolver_1","subchannel_address_1","uri_parser_1","net","subchannel_call_1","call_number_1","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","clientVersion","version","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","constants","KEEPALIVE_TIMEOUT_MS","tooManyPingsData","Buffer","from","Http2Transport","constructor","session","subchannelAddress","options","remoteName","keepaliveTimer","pendingSendKeepalivePing","activeCalls","Set","disconnectListeners","disconnectHandled","channelzEnabled","keepalivesSent","messagesSent","messagesReceived","lastMessageSentTimestamp","lastMessageReceivedTimestamp","subchannelAddressString","subchannelAddressToString","streamTracker","ChannelzCallTrackerStub","ChannelzCallTracker","channelzRef","registerChannelzSocket","getChannelzInfo","userAgent","filter","e","join","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","once","trace","handleDisconnect","errorCode","lastStreamID","opaqueData","tooManyPings","NGHTTP2_ENHANCE_YOUR_CALM","equals","toString","reportDisconnectToOwner","error","message","socket","hadError","isTracerEnabled","on","settings","JSON","stringify","maybeStartKeepalivePingTimer","sessionSocket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","_a","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","streamsStarted","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","localFlowControlWindow","_b","state","localWindowSize","remoteFlowControlWindow","_c","remoteWindowSize","text","LogVerbosity","DEBUG","id","keepaliveTrace","flowControlTrace","internalsTrace","forEach","listener","clearKeepaliveTimeout","call","onDisconnect","setImmediate","destroy","addDisconnectListener","push","canSendPing","destroyed","size","maybeSendPing","console","setTimeout","unref","pingSendError","pingSentSuccessfully","ping","err","duration","payload","Error","clearTimeout","removeActiveCall","delete","addActiveCall","add","ref","createCall","metadata","host","method","subchannelCallStatsTracker","headers","toHttp2Headers","http2Stream","request","closed","eventTracker","addCallStarted","addMessageSent","Date","addMessageReceived","onCallEnd","status","onStreamEnd","success","addCallSucceeded","addCallFailed","Http2SubchannelCall","getNextCallNumber","getChannelzRef","getPeerName","getOptions","shutdown","close","unregisterChannelzRef","Http2SubchannelConnector","channelTarget","isShutdown","uriToString","createSession","secureConnectResult","address","Promise","reject","resolve","realTarget","parsedTarget","parseUri","scheme","secure","targetPath","getDefaultAuthority","closeHandler","reportedError","errorMessage","trim","toISOString","errorHandler","connect","createConnection","authority","option","initialWindowSize","getDefaultSettings","removeAllListeners","removeListener","tcpConnect","getProxiedConnection","then","proxiedSocket","closeCallback","errorCallback","secureConnector","tcpConnection","addressString","waitForReady","exports"],"sources":["C:\\Users\\BIT\\chatboot\\node_modules\\@grpc\\grpc-js\\src\\transport.ts"],"sourcesContent":["/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport {\n  CipherNameAndProtocol,\n  TLSSocket,\n} from 'tls';\nimport { PartialStatusObject } from './call-interface';\nimport { SecureConnector, SecureConnectResult } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  ChannelzCallTracker,\n  ChannelzCallTrackerStub,\n  registerChannelzSocket,\n  SocketInfo,\n  SocketRef,\n  TlsInfo,\n  unregisterChannelzRef,\n} from './channelz';\nimport { LogVerbosity } from './constants';\nimport { getProxiedConnection } from './http_proxy';\nimport * as logging from './logging';\nimport { getDefaultAuthority } from './resolver';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { GrpcUri, parseUri, uriToString } from './uri-parser';\nimport * as net from 'net';\nimport {\n  Http2SubchannelCall,\n  SubchannelCall,\n  SubchannelCallInterceptingListener,\n} from './subchannel-call';\nimport { Metadata } from './metadata';\nimport { getNextCallNumber } from './call-number';\nimport { Socket } from 'net';\n\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\n\nconst clientVersion = require('../../package.json').version;\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface CallEventTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n  onCallEnd(status: PartialStatusObject): void;\n  onStreamEnd(success: boolean): void;\n}\n\nexport interface TransportDisconnectListener {\n  (tooManyPings: boolean): void;\n}\n\nexport interface Transport {\n  getChannelzRef(): SocketRef;\n  getPeerName(): string;\n  getOptions(): ChannelOptions;\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): SubchannelCall;\n  addDisconnectListener(listener: TransportDisconnectListener): void;\n  shutdown(): void;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nclass Http2Transport implements Transport {\n  /**\n   * The amount of time in between sending pings\n   */\n  private readonly keepaliveTimeMs: number;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private readonly keepaliveTimeoutMs: number;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private readonly keepaliveWithoutCalls: boolean;\n  /**\n   * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.\n   */\n  private keepaliveTimer: NodeJS.Timeout | null = null;\n  /**\n   * Indicates that the keepalive timer ran out while there were no active\n   * calls, and a ping should be sent the next time a call starts.\n   */\n  private pendingSendKeepalivePing = false;\n\n  private userAgent: string;\n\n  private activeCalls: Set<Http2SubchannelCall> = new Set();\n\n  private subchannelAddressString: string;\n\n  private disconnectListeners: TransportDisconnectListener[] = [];\n\n  private disconnectHandled = false;\n\n  // Channelz info\n  private channelzRef: SocketRef;\n  private readonly channelzEnabled: boolean = true;\n  private streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  constructor(\n    private session: http2.ClientHttp2Session,\n    subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    private remoteName: string | null\n  ) {\n    /* Populate subchannelAddressString and channelzRef before doing anything\n     * else, because they are used in the trace methods. */\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n      this.streamTracker = new ChannelzCallTrackerStub();\n    } else {\n      this.streamTracker = new ChannelzCallTracker();\n    }\n\n    this.channelzRef = registerChannelzSocket(\n      this.subchannelAddressString,\n      () => this.getChannelzInfo(),\n      this.channelzEnabled\n    );\n\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter(e => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    } else {\n      this.keepaliveTimeMs = -1;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    } else {\n      this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n\n    session.once('close', () => {\n      this.trace('session closed');\n      this.handleDisconnect();\n    });\n\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => {\n        let tooManyPings = false;\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (\n          errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n          opaqueData &&\n          opaqueData.equals(tooManyPingsData)\n        ) {\n          tooManyPings = true;\n        }\n        this.trace(\n          'connection closed by GOAWAY with code ' +\n            errorCode +\n            ' and data ' +\n            opaqueData?.toString()\n        );\n        this.reportDisconnectToOwner(tooManyPings);\n      }\n    );\n\n    session.once('error', error => {\n      this.trace('connection closed with error ' + (error as Error).message);\n      this.handleDisconnect();\n    });\n\n    session.socket.once('close', (hadError) => {\n      this.trace('connection closed. hadError=' + hadError);\n      this.handleDisconnect();\n    });\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n\n    /* Start the keepalive timer last, because this can trigger trace logs,\n     * which should only happen after everything else is set up. */\n    if (this.keepaliveWithoutCalls) {\n      this.maybeStartKeepalivePingTimer();\n    }\n  }\n\n  private getChannelzInfo(): SocketInfo {\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.remoteAddress,\n          sessionSocket.remotePort\n        )\n      : null;\n    const localAddress = sessionSocket.localAddress\n      ? stringToSubchannelAddress(\n          sessionSocket.localAddress,\n          sessionSocket.localPort\n        )\n      : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =\n        tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate:\n          certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate:\n          peerCertificate && 'raw' in peerCertificate\n            ? peerCertificate.raw\n            : null,\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp:\n        this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null,\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      FLOW_CONTROL_TRACER_NAME,\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'transport_internals',\n      '(' +\n        this.channelzRef.id +\n        ') ' +\n        this.subchannelAddressString +\n        ' ' +\n        text\n    );\n  }\n\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  private reportDisconnectToOwner(tooManyPings: boolean) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  private handleDisconnect() {\n    this.clearKeepaliveTimeout();\n    this.reportDisconnectToOwner(false);\n    for (const call of this.activeCalls) {\n      call.onDisconnect();\n    }\n    // Wait an event loop cycle before destroying the connection\n    setImmediate(() => {\n      this.session.destroy();\n    });\n  }\n\n  addDisconnectListener(listener: TransportDisconnectListener): void {\n    this.disconnectListeners.push(listener);\n  }\n\n  private canSendPing() {\n    return (\n      !this.session.destroyed &&\n      this.keepaliveTimeMs > 0 &&\n      (this.keepaliveWithoutCalls || this.activeCalls.size > 0)\n    );\n  }\n\n  private maybeSendPing() {\n    if (!this.canSendPing()) {\n      this.pendingSendKeepalivePing = true;\n      return;\n    }\n    if (this.keepaliveTimer) {\n      console.error('keepaliveTimeout is not null');\n      return;\n    }\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace(\n      'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'\n    );\n    this.keepaliveTimer = setTimeout(() => {\n      this.keepaliveTimer = null;\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    this.keepaliveTimer.unref?.();\n    let pingSendError = '';\n    try {\n      const pingSentSuccessfully = this.session.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          this.clearKeepaliveTimeout();\n          if (err) {\n            this.keepaliveTrace('Ping failed with error ' + err.message);\n            this.handleDisconnect();\n          } else {\n            this.keepaliveTrace('Received ping response');\n            this.maybeStartKeepalivePingTimer();\n          }\n        }\n      );\n      if (!pingSentSuccessfully) {\n        pingSendError = 'Ping returned false';\n      }\n    } catch (e) {\n      // grpc/grpc-node#2139\n      pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\n    }\n    if (pingSendError) {\n      this.keepaliveTrace('Ping send failed: ' + pingSendError);\n      this.handleDisconnect();\n    }\n  }\n\n  /**\n   * Starts the keepalive ping timer if appropriate. If the timer already ran\n   * out while there were no active requests, instead send a ping immediately.\n   * If the ping timer is already running or a ping is currently in flight,\n   * instead do nothing and wait for them to resolve.\n   */\n  private maybeStartKeepalivePingTimer() {\n    if (!this.canSendPing()) {\n      return;\n    }\n    if (this.pendingSendKeepalivePing) {\n      this.pendingSendKeepalivePing = false;\n      this.maybeSendPing();\n    } else if (!this.keepaliveTimer) {\n      this.keepaliveTrace(\n        'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'\n      );\n      this.keepaliveTimer = setTimeout(() => {\n        this.keepaliveTimer = null;\n        this.maybeSendPing();\n      }, this.keepaliveTimeMs);\n      this.keepaliveTimer.unref?.();\n    }\n    /* Otherwise, there is already either a keepalive timer or a ping pending,\n     * wait for those to resolve. */\n  }\n\n  /**\n   * Clears whichever keepalive timeout is currently active, if any.\n   */\n  private clearKeepaliveTimeout() {\n    if (this.keepaliveTimer) {\n      clearTimeout(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n  }\n\n  private removeActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n    }\n  }\n\n  private addActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.add(call);\n    if (this.activeCalls.size === 1) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.maybeStartKeepalivePingTimer();\n      }\n    }\n  }\n\n  createCall(\n    metadata: Metadata,\n    host: string,\n    method: string,\n    listener: SubchannelCallInterceptingListener,\n    subchannelCallStatsTracker: Partial<CallEventTracker>\n  ): Http2SubchannelCall {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session.state.localWindowSize +\n        ' remote window size: ' +\n        this.session.state.remoteWindowSize\n    );\n    this.internalsTrace(\n      'session.closed=' +\n        this.session.closed +\n        ' session.destroyed=' +\n        this.session.destroyed +\n        ' session.socket.destroyed=' +\n        this.session.socket.destroyed\n    );\n    let eventTracker: CallEventTracker;\n    // eslint-disable-next-line prefer-const\n    let call: Http2SubchannelCall;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        },\n      };\n    }\n    call = new Http2SubchannelCall(\n      http2Stream,\n      eventTracker,\n      listener,\n      this,\n      getNextCallNumber()\n    );\n    this.addActiveCall(call);\n    return call;\n  }\n\n  getChannelzRef(): SocketRef {\n    return this.channelzRef;\n  }\n\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  shutdown() {\n    this.session.close();\n    unregisterChannelzRef(this.channelzRef);\n  }\n}\n\nexport interface SubchannelConnector {\n  connect(\n    address: SubchannelAddress,\n    secureConnector: SecureConnector,\n    options: ChannelOptions\n  ): Promise<Transport>;\n  shutdown(): void;\n}\n\nexport class Http2SubchannelConnector implements SubchannelConnector {\n  private session: http2.ClientHttp2Session | null = null;\n  private isShutdown = false;\n  constructor(private channelTarget: GrpcUri) {}\n\n  private trace(text: string) {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      uriToString(this.channelTarget) + ' ' + text\n    );\n  }\n\n  private createSession(\n    secureConnectResult: SecureConnectResult,\n    address: SubchannelAddress,\n    options: ChannelOptions\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n\n    if (secureConnectResult.socket.closed) {\n      return Promise.reject('Connection closed before starting HTTP/2 handshake');\n    }\n\n    return new Promise<Http2Transport>((resolve, reject) => {\n      let remoteName: string | null = null;\n      let realTarget: GrpcUri = this.channelTarget;\n      if ('grpc.http_connect_target' in options) {\n        const parsedTarget = parseUri(options['grpc.http_connect_target']!);\n        if (parsedTarget) {\n          realTarget = parsedTarget;\n          remoteName = uriToString(parsedTarget);\n        }\n      }\n      const scheme = secureConnectResult.secure ? 'https' : 'http';\n      const targetPath = getDefaultAuthority(realTarget);\n      const closeHandler = () => {\n        this.session?.destroy();\n        this.session = null;\n        // Leave time for error event to happen before rejecting\n        setImmediate(() => {\n          if (!reportedError) {\n            reportedError = true;\n            reject(`${errorMessage.trim()} (${new Date().toISOString()})`);\n          }\n        });\n      };\n      const errorHandler = (error: Error) => {\n        this.session?.destroy();\n        errorMessage = (error as Error).message;\n        this.trace('connection failed with error ' + errorMessage);\n        if (!reportedError) {\n          reportedError = true;\n          reject(`${errorMessage} (${new Date().toISOString()})`);\n        }\n      };\n      const session = http2.connect(`${scheme}://${targetPath}`, {\n        createConnection: (authority, option) => {\n          return secureConnectResult.socket;\n        },\n        settings: {\n          initialWindowSize:\n            options['grpc-node.flow_control_window'] ??\n            http2.getDefaultSettings().initialWindowSize,\n        }\n      });\n      this.session = session;\n      let errorMessage = 'Failed to connect';\n      let reportedError = false;\n      session.unref();\n      session.once('remoteSettings', () => {\n        session.removeAllListeners();\n        secureConnectResult.socket.removeListener('close', closeHandler);\n        secureConnectResult.socket.removeListener('error', errorHandler);\n        resolve(new Http2Transport(session, address, options, remoteName));\n        this.session = null;\n      });\n      session.once('close', closeHandler);\n      session.once('error', errorHandler);\n      secureConnectResult.socket.once('close', closeHandler);\n      secureConnectResult.socket.once('error', errorHandler);\n    });\n  }\n\n  private tcpConnect(address: SubchannelAddress, options: ChannelOptions): Promise<Socket> {\n    return getProxiedConnection(address, options).then(proxiedSocket => {\n      if (proxiedSocket) {\n        return proxiedSocket;\n      } else {\n        return new Promise<Socket>((resolve, reject) => {\n          const closeCallback = () => {\n            reject(new Error('Socket closed'));\n          };\n          const errorCallback = (error: Error) => {\n            reject(error);\n          }\n          const socket = net.connect(address, () => {\n            socket.removeListener('close', closeCallback);\n            socket.removeListener('error', errorCallback);\n            resolve(socket);\n          });\n          socket.once('close', closeCallback);\n          socket.once('error', errorCallback);\n        });\n      }\n    });\n  }\n\n  async connect(\n    address: SubchannelAddress,\n    secureConnector: SecureConnector,\n    options: ChannelOptions\n  ): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    let tcpConnection: net.Socket | null = null;\n    let secureConnectResult: SecureConnectResult | null  = null;\n    const addressString = subchannelAddressToString(address);\n    try {\n      this.trace(addressString + ' Waiting for secureConnector to be ready');\n      await secureConnector.waitForReady();\n      this.trace(addressString + ' secureConnector is ready');\n      tcpConnection = await this.tcpConnect(address, options);\n      this.trace(addressString + ' Established TCP connection');\n      secureConnectResult = await secureConnector.connect(tcpConnection);\n      this.trace(addressString + ' Established secure connection');\n      return this.createSession(secureConnectResult, address, options);\n    } catch (e) {\n      tcpConnection?.destroy();\n      secureConnectResult?.socket.destroy();\n      throw e;\n    }\n  }\n\n  shutdown(): void {\n    this.isShutdown = true;\n    this.session?.close();\n    this.session = null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}